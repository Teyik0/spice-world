diff --git a/dist/cjs/FieldApi.cjs.map b/dist/cjs/FieldApi.cjs.map
index bd6f3e715f531996c7319a6921d2effb34fb4c3d..630d6bda388070ad8958759cbac18f7a80397669 100644
--- a/dist/cjs/FieldApi.cjs.map
+++ b/dist/cjs/FieldApi.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"FieldApi.cjs","sources":["../../src/FieldApi.ts"],"sourcesContent":["import { Derived, batch } from '@tanstack/store'\nimport {\n  isStandardSchemaValidator,\n  standardSchemaValidators,\n} from './standardSchemaValidator'\nimport { defaultFieldMeta } from './metaHelper'\nimport {\n  determineFieldLevelErrorSourceAndValue,\n  evaluate,\n  getAsyncValidatorArray,\n  getBy,\n  getSyncValidatorArray,\n  mergeOpts,\n} from './utils'\nimport { defaultValidationLogic } from './ValidationLogic'\nimport type { DeepKeys, DeepValue, UnwrapOneLevelOfArray } from './util-types'\nimport type {\n  StandardSchemaV1,\n  StandardSchemaV1Issue,\n  TStandardSchemaValidatorValue,\n} from './standardSchemaValidator'\nimport type {\n  FieldInfo,\n  FormApi,\n  FormAsyncValidateOrFn,\n  FormValidateAsyncFn,\n  FormValidateFn,\n  FormValidateOrFn,\n} from './FormApi'\nimport type {\n  ListenerCause,\n  UpdateMetaOptions,\n  ValidationCause,\n  ValidationError,\n  ValidationErrorMap,\n  ValidationErrorMapSource,\n} from './types'\nimport type { AsyncValidator, SyncValidator, Updater } from './utils'\n\n/**\n * @private\n */\n// TODO: Add the `Unwrap` type to the errors\ntype FieldErrorMapFromValidator<\n  TFormData,\n  TName extends DeepKeys<TFormData>,\n  TData extends DeepValue<TFormData, TName>,\n  TOnMount extends undefined | FieldValidateOrFn<TFormData, TName, TData>,\n  TOnChange extends undefined | FieldValidateOrFn<TFormData, TName, TData>,\n  TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TFormData, TName, TData>,\n  TOnBlur extends undefined | FieldValidateOrFn<TFormData, TName, TData>,\n  TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TFormData, TName, TData>,\n  TOnSubmit extends undefined | FieldValidateOrFn<TFormData, TName, TData>,\n  TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TFormData, TName, TData>,\n> = Partial<\n  Record<\n    DeepKeys<TFormData>,\n    ValidationErrorMap<\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync\n    >\n  >\n>\n\n/**\n * @private\n */\nexport type FieldValidateFn<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n> = (props: {\n  value: TData\n  fieldApi: FieldApi<\n    TParentData,\n    TName,\n    TData,\n    // This is technically an edge-type; which we try to keep non-`any`, but in this case\n    // It's referring to an inaccessible type from the field validate function inner types, so it's not a big deal\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any\n  >\n}) => unknown\n\n/**\n * @private\n */\nexport type FieldValidateOrFn<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n> =\n  | FieldValidateFn<TParentData, TName, TData>\n  | StandardSchemaV1<TData, unknown>\n\ntype StandardBrandedSchemaV1<T> = T & { __standardSchemaV1: true }\n\ntype UnwrapFormValidateOrFnForInner<\n  TValidateOrFn extends undefined | FormValidateOrFn<any>,\n> = [TValidateOrFn] extends [FormValidateFn<any>]\n  ? ReturnType<TValidateOrFn>\n  : [TValidateOrFn] extends [StandardSchemaV1<infer TOut, any>]\n    ? StandardBrandedSchemaV1<TOut>\n    : undefined\n\nexport type UnwrapFieldValidateOrFn<\n  TName extends string,\n  TValidateOrFn extends undefined | FieldValidateOrFn<any, any, any>,\n  TFormValidateOrFn extends undefined | FormValidateOrFn<any>,\n> =\n  | ([TFormValidateOrFn] extends [StandardSchemaV1<any, infer TStandardOut>]\n      ? TName extends keyof TStandardOut\n        ? StandardSchemaV1Issue[]\n        : undefined\n      : undefined)\n  | (UnwrapFormValidateOrFnForInner<TFormValidateOrFn> extends infer TFormValidateVal\n      ? TFormValidateVal extends { __standardSchemaV1: true }\n        ? [DeepValue<TFormValidateVal, TName>] extends [never]\n          ? undefined\n          : StandardSchemaV1Issue[]\n        : TFormValidateVal extends { fields: any }\n          ? TName extends keyof TFormValidateVal['fields']\n            ? TFormValidateVal['fields'][TName]\n            : undefined\n          : undefined\n      : never)\n  | ([TValidateOrFn] extends [FieldValidateFn<any, any, any>]\n      ? ReturnType<TValidateOrFn>\n      : [TValidateOrFn] extends [StandardSchemaV1<any, any>]\n        ? // TODO: Check if `disableErrorFlat` is enabled, if so, return StandardSchemaV1Issue[][]\n          StandardSchemaV1Issue[]\n        : undefined)\n\n/**\n * @private\n */\nexport type FieldValidateAsyncFn<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n> = (options: {\n  value: TData\n  fieldApi: FieldApi<\n    TParentData,\n    TName,\n    TData,\n    // This is technically an edge-type; which we try to keep non-`any`, but in this case\n    // It's referring to an inaccessible type from the field validate function inner types, so it's not a big deal\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any\n  >\n  signal: AbortSignal\n}) => unknown | Promise<unknown>\n\n/**\n * @private\n */\nexport type FieldAsyncValidateOrFn<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n> =\n  | FieldValidateAsyncFn<TParentData, TName, TData>\n  | StandardSchemaV1<TData, unknown>\n\ntype UnwrapFormAsyncValidateOrFnForInner<\n  TValidateOrFn extends undefined | FormAsyncValidateOrFn<any>,\n> = [TValidateOrFn] extends [FormValidateAsyncFn<any>]\n  ? Awaited<ReturnType<TValidateOrFn>>\n  : [TValidateOrFn] extends [StandardSchemaV1<infer TOut, any>]\n    ? StandardBrandedSchemaV1<TOut>\n    : undefined\n\nexport type UnwrapFieldAsyncValidateOrFn<\n  TName extends string,\n  TValidateOrFn extends undefined | FieldAsyncValidateOrFn<any, any, any>,\n  TFormValidateOrFn extends undefined | FormAsyncValidateOrFn<any>,\n> =\n  | ([TFormValidateOrFn] extends [StandardSchemaV1<any, infer TStandardOut>]\n      ? TName extends keyof TStandardOut\n        ? StandardSchemaV1Issue[]\n        : undefined\n      : undefined)\n  | (UnwrapFormAsyncValidateOrFnForInner<TFormValidateOrFn> extends infer TFormValidateVal\n      ? TFormValidateVal extends { __standardSchemaV1: true }\n        ? [DeepValue<TFormValidateVal, TName>] extends [never]\n          ? undefined\n          : StandardSchemaV1Issue[]\n        : TFormValidateVal extends { fields: any }\n          ? TName extends keyof TFormValidateVal['fields']\n            ? TFormValidateVal['fields'][TName]\n            : undefined\n          : undefined\n      : never)\n  | ([TValidateOrFn] extends [FieldValidateAsyncFn<any, any, any>]\n      ? Awaited<ReturnType<TValidateOrFn>>\n      : [TValidateOrFn] extends [StandardSchemaV1<any, any>]\n        ? // TODO: Check if `disableErrorFlat` is enabled, if so, return StandardSchemaV1Issue[][]\n          StandardSchemaV1Issue[]\n        : undefined)\n\n/**\n * @private\n */\nexport type FieldListenerFn<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n> = (props: {\n  value: TData\n  fieldApi: FieldApi<\n    TParentData,\n    TName,\n    TData,\n    // This is technically an edge-type; which we try to keep non-`any`, but in this case\n    // It's referring to an inaccessible type from the field listener function inner types, so it's not a big deal\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any\n  >\n}) => void\n\nexport interface FieldValidators<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName>,\n  TOnMount extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChange extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnBlur extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnSubmit extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnDynamic extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnDynamicAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n> {\n  /**\n   * An optional function, that runs on the mount event of input.\n   */\n  onMount?: TOnMount\n  /**\n   * An optional function, that runs on the change event of input.\n   *\n   * @example z.string().min(1)\n   */\n  onChange?: TOnChange\n  /**\n   * An optional property similar to `onChange` but async validation\n   *\n   * @example z.string().refine(async (val) => val.length > 3, { message: 'Testing 123' })\n   */\n  onChangeAsync?: TOnChangeAsync\n  /**\n   * An optional number to represent how long the `onChangeAsync` should wait before running\n   *\n   * If set to a number larger than 0, will debounce the async validation event by this length of time in milliseconds\n   */\n  onChangeAsyncDebounceMs?: number\n  /**\n   * An optional list of field names that should trigger this field's `onChange` and `onChangeAsync` events when its value changes\n   */\n  onChangeListenTo?: DeepKeys<TParentData>[]\n  /**\n   * An optional function, that runs on the blur event of input.\n   *\n   * @example z.string().min(1)\n   */\n  onBlur?: TOnBlur\n  /**\n   * An optional property similar to `onBlur` but async validation.\n   *\n   * @example z.string().refine(async (val) => val.length > 3, { message: 'Testing 123' })\n   */\n  onBlurAsync?: TOnBlurAsync\n\n  /**\n   * An optional number to represent how long the `onBlurAsync` should wait before running\n   *\n   * If set to a number larger than 0, will debounce the async validation event by this length of time in milliseconds\n   */\n  onBlurAsyncDebounceMs?: number\n  /**\n   * An optional list of field names that should trigger this field's `onBlur` and `onBlurAsync` events when its value changes\n   */\n  onBlurListenTo?: DeepKeys<TParentData>[]\n  /**\n   * An optional function, that runs on the submit event of form.\n   *\n   * @example z.string().min(1)\n   */\n  onSubmit?: TOnSubmit\n  /**\n   * An optional property similar to `onSubmit` but async validation.\n   *\n   * @example z.string().refine(async (val) => val.length > 3, { message: 'Testing 123' })\n   */\n  onSubmitAsync?: TOnSubmitAsync\n  onDynamic?: TOnDynamic\n  onDynamicAsync?: TOnDynamicAsync\n  onDynamicAsyncDebounceMs?: number\n}\n\nexport interface FieldListeners<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n> {\n  onChange?: FieldListenerFn<TParentData, TName, TData>\n  onChangeDebounceMs?: number\n  onBlur?: FieldListenerFn<TParentData, TName, TData>\n  onBlurDebounceMs?: number\n  onMount?: FieldListenerFn<TParentData, TName, TData>\n  onSubmit?: FieldListenerFn<TParentData, TName, TData>\n}\n\n/**\n * An object type representing the options for a field in a form.\n */\nexport interface FieldOptions<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName>,\n  TOnMount extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChange extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnBlur extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnSubmit extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnDynamic extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnDynamicAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n> {\n  /**\n   * The field name. The type will be `DeepKeys<TParentData>` to ensure your name is a deep key of the parent dataset.\n   */\n  name: TName\n  /**\n   * An optional default value for the field.\n   */\n  defaultValue?: NoInfer<TData>\n  /**\n   * The default time to debounce async validation if there is not a more specific debounce time passed.\n   */\n  asyncDebounceMs?: number\n  /**\n   * If `true`, always run async validation, even if there are errors emitted during synchronous validation.\n   */\n  asyncAlways?: boolean\n  /**\n   * A list of validators to pass to the field\n   */\n  validators?: FieldValidators<\n    TParentData,\n    TName,\n    TData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TOnDynamic,\n    TOnDynamicAsync\n  >\n  /**\n   * An optional object with default metadata for the field.\n   */\n  defaultMeta?: Partial<\n    FieldMeta<\n      TParentData,\n      TName,\n      TData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      any,\n      any,\n      any,\n      any,\n      any,\n      any,\n      any,\n      any,\n      any\n    >\n  >\n  /**\n   * A list of listeners which attach to the corresponding events\n   */\n  listeners?: FieldListeners<TParentData, TName, TData>\n  /**\n   * Disable the `flat(1)` operation on `field.errors`. This is useful if you want to keep the error structure as is. Not suggested for most use-cases.\n   */\n  disableErrorFlat?: boolean\n}\n\n/**\n * An object type representing the required options for the FieldApi class.\n */\nexport interface FieldApiOptions<\n  in out TParentData,\n  in out TName extends DeepKeys<TParentData>,\n  in out TData extends DeepValue<TParentData, TName>,\n  in out TOnMount extends\n    | undefined\n    | FieldValidateOrFn<TParentData, TName, TData>,\n  in out TOnChange extends\n    | undefined\n    | FieldValidateOrFn<TParentData, TName, TData>,\n  in out TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  in out TOnBlur extends\n    | undefined\n    | FieldValidateOrFn<TParentData, TName, TData>,\n  in out TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  in out TOnSubmit extends\n    | undefined\n    | FieldValidateOrFn<TParentData, TName, TData>,\n  in out TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  in out TOnDynamic extends\n    | undefined\n    | FieldValidateOrFn<TParentData, TName, TData>,\n  in out TOnDynamicAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  in out TFormOnMount extends undefined | FormValidateOrFn<TParentData>,\n  in out TFormOnChange extends undefined | FormValidateOrFn<TParentData>,\n  in out TFormOnChangeAsync extends\n    | undefined\n    | FormAsyncValidateOrFn<TParentData>,\n  in out TFormOnBlur extends undefined | FormValidateOrFn<TParentData>,\n  in out TFormOnBlurAsync extends\n    | undefined\n    | FormAsyncValidateOrFn<TParentData>,\n  in out TFormOnSubmit extends undefined | FormValidateOrFn<TParentData>,\n  in out TFormOnSubmitAsync extends\n    | undefined\n    | FormAsyncValidateOrFn<TParentData>,\n  in out TFormOnDynamic extends undefined | FormValidateOrFn<TParentData>,\n  in out TFormOnDynamicAsync extends\n    | undefined\n    | FormAsyncValidateOrFn<TParentData>,\n  in out TFormOnServer extends undefined | FormAsyncValidateOrFn<TParentData>,\n  in out TParentSubmitMeta,\n> extends FieldOptions<\n  TParentData,\n  TName,\n  TData,\n  TOnMount,\n  TOnChange,\n  TOnChangeAsync,\n  TOnBlur,\n  TOnBlurAsync,\n  TOnSubmit,\n  TOnSubmitAsync,\n  TOnDynamic,\n  TOnDynamicAsync\n> {\n  form: FormApi<\n    TParentData,\n    TFormOnMount,\n    TFormOnChange,\n    TFormOnChangeAsync,\n    TFormOnBlur,\n    TFormOnBlurAsync,\n    TFormOnSubmit,\n    TFormOnSubmitAsync,\n    TFormOnDynamic,\n    TFormOnDynamicAsync,\n    TFormOnServer,\n    TParentSubmitMeta\n  >\n}\n\nexport type FieldMetaBase<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName>,\n  TOnMount extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChange extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnBlur extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnSubmit extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnDynamic extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnDynamicAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TFormOnMount extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChange extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChangeAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnBlur extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnBlurAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnSubmit extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnDynamic extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n> = {\n  /**\n   * A flag indicating whether the field has been touched.\n   */\n  isTouched: boolean\n  /**\n   * A flag indicating whether the field has been blurred.\n   */\n  isBlurred: boolean\n  /**\n   * A flag that is `true` if the field's value has been modified by the user. Opposite of `isPristine`.\n   */\n  isDirty: boolean\n  /**\n   * A map of errors related to the field value.\n   */\n  errorMap: ValidationErrorMap<\n    UnwrapFieldValidateOrFn<TName, TOnMount, TFormOnMount>,\n    UnwrapFieldValidateOrFn<TName, TOnChange, TFormOnChange>,\n    UnwrapFieldAsyncValidateOrFn<TName, TOnChangeAsync, TFormOnChangeAsync>,\n    UnwrapFieldValidateOrFn<TName, TOnBlur, TFormOnBlur>,\n    UnwrapFieldAsyncValidateOrFn<TName, TOnBlurAsync, TFormOnBlurAsync>,\n    UnwrapFieldValidateOrFn<TName, TOnSubmit, TFormOnSubmit>,\n    UnwrapFieldAsyncValidateOrFn<TName, TOnSubmitAsync, TFormOnSubmitAsync>,\n    UnwrapFieldValidateOrFn<TName, TOnDynamic, TFormOnDynamic>,\n    UnwrapFieldAsyncValidateOrFn<TName, TOnDynamicAsync, TFormOnDynamicAsync>\n  >\n\n  /**\n   * @private allows tracking the source of the errors in the error map\n   */\n  errorSourceMap: ValidationErrorMapSource\n  /**\n   * A flag indicating whether the field is currently being validated.\n   */\n  isValidating: boolean\n}\n\nexport type AnyFieldMetaBase = FieldMetaBase<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any\n>\n\nexport type FieldMetaDerived<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName>,\n  TOnMount extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChange extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnBlur extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnSubmit extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnDynamic extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnDynamicAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TFormOnMount extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChange extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChangeAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnBlur extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnBlurAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnSubmit extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnDynamic extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n> = {\n  /**\n   * An array of errors related to the field value.\n   */\n  errors: Array<\n    | UnwrapOneLevelOfArray<\n        UnwrapFieldValidateOrFn<TName, TOnMount, TFormOnMount>\n      >\n    | UnwrapOneLevelOfArray<\n        UnwrapFieldValidateOrFn<TName, TOnChange, TFormOnChange>\n      >\n    | UnwrapOneLevelOfArray<\n        UnwrapFieldAsyncValidateOrFn<TName, TOnChangeAsync, TFormOnChangeAsync>\n      >\n    | UnwrapOneLevelOfArray<\n        UnwrapFieldValidateOrFn<TName, TOnBlur, TFormOnBlur>\n      >\n    | UnwrapOneLevelOfArray<\n        UnwrapFieldAsyncValidateOrFn<TName, TOnBlurAsync, TFormOnBlurAsync>\n      >\n    | UnwrapOneLevelOfArray<\n        UnwrapFieldValidateOrFn<TName, TOnSubmit, TFormOnSubmit>\n      >\n    | UnwrapOneLevelOfArray<\n        UnwrapFieldAsyncValidateOrFn<TName, TOnSubmitAsync, TFormOnSubmitAsync>\n      >\n    | UnwrapOneLevelOfArray<\n        UnwrapFieldValidateOrFn<TName, TOnDynamic, TFormOnDynamic>\n      >\n    | UnwrapOneLevelOfArray<\n        UnwrapFieldAsyncValidateOrFn<\n          TName,\n          TOnDynamicAsync,\n          TFormOnDynamicAsync\n        >\n      >\n  >\n  /**\n   * A flag that is `true` if the field's value has not been modified by the user. Opposite of `isDirty`.\n   */\n  isPristine: boolean\n  /**\n   * A boolean indicating if the field is valid. Evaluates `true` if there are no field errors.\n   */\n  isValid: boolean\n  /**\n   * A flag indicating whether the field's current value is the default value\n   */\n  isDefaultValue: boolean\n}\n\nexport type AnyFieldMetaDerived = FieldMetaDerived<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any\n>\n\n/**\n * An object type representing the metadata of a field in a form.\n */\nexport type FieldMeta<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName>,\n  TOnMount extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChange extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnBlur extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnSubmit extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnDynamic extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnDynamicAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TFormOnMount extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChange extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChangeAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnBlur extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnBlurAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnSubmit extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnDynamic extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n> = FieldMetaBase<\n  TParentData,\n  TName,\n  TData,\n  TOnMount,\n  TOnChange,\n  TOnChangeAsync,\n  TOnBlur,\n  TOnBlurAsync,\n  TOnSubmit,\n  TOnSubmitAsync,\n  TOnDynamic,\n  TOnDynamicAsync,\n  TFormOnMount,\n  TFormOnChange,\n  TFormOnChangeAsync,\n  TFormOnBlur,\n  TFormOnBlurAsync,\n  TFormOnSubmit,\n  TFormOnSubmitAsync,\n  TFormOnDynamic,\n  TFormOnDynamicAsync\n> &\n  FieldMetaDerived<\n    TParentData,\n    TName,\n    TData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TOnDynamic,\n    TOnDynamicAsync,\n    TFormOnMount,\n    TFormOnChange,\n    TFormOnChangeAsync,\n    TFormOnBlur,\n    TFormOnBlurAsync,\n    TFormOnSubmit,\n    TFormOnSubmitAsync,\n    TFormOnDynamic,\n    TFormOnDynamicAsync\n  >\n\nexport type AnyFieldMeta = FieldMeta<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any\n>\n\n/**\n * An object type representing the state of a field.\n */\nexport type FieldState<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName>,\n  TOnMount extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChange extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnBlur extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnSubmit extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnDynamic extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnDynamicAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TFormOnMount extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChange extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChangeAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnBlur extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnBlurAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnSubmit extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnDynamic extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n> = {\n  /**\n   * The current value of the field.\n   */\n  value: TData\n  /**\n   * The current metadata of the field.\n   */\n  meta: FieldMeta<\n    TParentData,\n    TName,\n    TData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TOnDynamic,\n    TOnDynamicAsync,\n    TFormOnMount,\n    TFormOnChange,\n    TFormOnChangeAsync,\n    TFormOnBlur,\n    TFormOnBlurAsync,\n    TFormOnSubmit,\n    TFormOnSubmitAsync,\n    TFormOnDynamic,\n    TFormOnDynamicAsync\n  >\n}\n\n/**\n * @public\n *\n * A type representing the Field API with all generics set to `any` for convenience.\n */\nexport type AnyFieldApi = FieldApi<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any\n>\n\n/**\n * We cannot use methods and must use arrow functions. Otherwise, our React adapters\n * will break due to loss of the method when using spread.\n */\n\n/**\n * A class representing the API for managing a form field.\n *\n * Normally, you will not need to create a new `FieldApi` instance directly.\n * Instead, you will use a framework hook/function like `useField` or `createField`\n * to create a new instance for you that uses your framework's reactivity model.\n * However, if you need to create a new instance manually, you can do so by calling\n * the `new FieldApi` constructor.\n */\nexport class FieldApi<\n  in out TParentData,\n  in out TName extends DeepKeys<TParentData>,\n  in out TData extends DeepValue<TParentData, TName>,\n  in out TOnMount extends\n    | undefined\n    | FieldValidateOrFn<TParentData, TName, TData>,\n  in out TOnChange extends\n    | undefined\n    | FieldValidateOrFn<TParentData, TName, TData>,\n  in out TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  in out TOnBlur extends\n    | undefined\n    | FieldValidateOrFn<TParentData, TName, TData>,\n  in out TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  in out TOnSubmit extends\n    | undefined\n    | FieldValidateOrFn<TParentData, TName, TData>,\n  in out TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  in out TOnDynamic extends\n    | undefined\n    | FieldValidateOrFn<TParentData, TName, TData>,\n  in out TOnDynamicAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  in out TFormOnMount extends undefined | FormValidateOrFn<TParentData>,\n  in out TFormOnChange extends undefined | FormValidateOrFn<TParentData>,\n  in out TFormOnChangeAsync extends\n    | undefined\n    | FormAsyncValidateOrFn<TParentData>,\n  in out TFormOnBlur extends undefined | FormValidateOrFn<TParentData>,\n  in out TFormOnBlurAsync extends\n    | undefined\n    | FormAsyncValidateOrFn<TParentData>,\n  in out TFormOnSubmit extends undefined | FormValidateOrFn<TParentData>,\n  in out TFormOnSubmitAsync extends\n    | undefined\n    | FormAsyncValidateOrFn<TParentData>,\n  in out TFormOnDynamic extends undefined | FormValidateOrFn<TParentData>,\n  in out TFormOnDynamicAsync extends\n    | undefined\n    | FormAsyncValidateOrFn<TParentData>,\n  in out TFormOnServer extends undefined | FormAsyncValidateOrFn<TParentData>,\n  in out TParentSubmitMeta,\n> {\n  /**\n   * A reference to the form API instance.\n   */\n  form: FieldApiOptions<\n    TParentData,\n    TName,\n    TData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TOnDynamic,\n    TOnDynamicAsync,\n    TFormOnMount,\n    TFormOnChange,\n    TFormOnChangeAsync,\n    TFormOnBlur,\n    TFormOnBlurAsync,\n    TFormOnSubmit,\n    TFormOnSubmitAsync,\n    TFormOnDynamic,\n    TFormOnDynamicAsync,\n    TFormOnServer,\n    TParentSubmitMeta\n  >['form']\n  /**\n   * The field name.\n   */\n  name: TName\n  /**\n   * The field options.\n   */\n  options: FieldApiOptions<\n    TParentData,\n    TName,\n    TData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TOnDynamic,\n    TOnDynamicAsync,\n    TFormOnMount,\n    TFormOnChange,\n    TFormOnChangeAsync,\n    TFormOnBlur,\n    TFormOnBlurAsync,\n    TFormOnSubmit,\n    TFormOnSubmitAsync,\n    TFormOnDynamic,\n    TFormOnDynamicAsync,\n    TFormOnServer,\n    TParentSubmitMeta\n  > = {} as any\n  /**\n   * The field state store.\n   */\n  store!: Derived<\n    FieldState<\n      TParentData,\n      TName,\n      TData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TFormOnMount,\n      TFormOnChange,\n      TFormOnChangeAsync,\n      TFormOnBlur,\n      TFormOnBlurAsync,\n      TFormOnSubmit,\n      TFormOnSubmitAsync,\n      TFormOnDynamic,\n      TFormOnDynamicAsync\n    >\n  >\n  /**\n   * The current field state.\n   */\n  get state() {\n    return this.store.state\n  }\n  timeoutIds: {\n    validations: Record<ValidationCause, ReturnType<typeof setTimeout> | null>\n    listeners: Record<ListenerCause, ReturnType<typeof setTimeout> | null>\n    formListeners: Record<ListenerCause, ReturnType<typeof setTimeout> | null>\n  }\n\n  /**\n   * Initializes a new `FieldApi` instance.\n   */\n  constructor(\n    opts: FieldApiOptions<\n      TParentData,\n      TName,\n      TData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TFormOnMount,\n      TFormOnChange,\n      TFormOnChangeAsync,\n      TFormOnBlur,\n      TFormOnBlurAsync,\n      TFormOnSubmit,\n      TFormOnSubmitAsync,\n      TFormOnDynamic,\n      TFormOnDynamicAsync,\n      TFormOnServer,\n      TParentSubmitMeta\n    >,\n  ) {\n    this.form = opts.form\n    this.name = opts.name\n    this.options = opts\n\n    this.timeoutIds = {\n      validations: {} as Record<ValidationCause, never>,\n      listeners: {} as Record<ListenerCause, never>,\n      formListeners: {} as Record<ListenerCause, never>,\n    }\n\n    this.store = new Derived({\n      deps: [this.form.store],\n      fn: () => {\n        const meta = this.form.getFieldMeta(this.name) ?? {\n          ...defaultFieldMeta,\n          ...opts.defaultMeta,\n        }\n\n        let value = this.form.getFieldValue(this.name)\n        if (\n          !meta.isTouched &&\n          (value as unknown) === undefined &&\n          this.options.defaultValue !== undefined &&\n          !evaluate(value, this.options.defaultValue)\n        ) {\n          value = this.options.defaultValue\n        }\n\n        return {\n          value,\n          meta,\n        } as FieldState<\n          TParentData,\n          TName,\n          TData,\n          TOnMount,\n          TOnChange,\n          TOnChangeAsync,\n          TOnBlur,\n          TOnBlurAsync,\n          TOnSubmit,\n          TOnSubmitAsync,\n          TOnDynamic,\n          TOnDynamicAsync,\n          TFormOnMount,\n          TFormOnChange,\n          TFormOnChangeAsync,\n          TFormOnBlur,\n          TFormOnBlurAsync,\n          TFormOnSubmit,\n          TFormOnSubmitAsync,\n          TFormOnDynamic,\n          TFormOnDynamicAsync\n        >\n      },\n    })\n  }\n\n  /**\n   * @private\n   */\n  runValidator<\n    TValue extends TStandardSchemaValidatorValue<TData> & {\n      fieldApi: AnyFieldApi\n    },\n    TType extends 'validate' | 'validateAsync',\n  >(props: {\n    validate: TType extends 'validate'\n      ? FieldValidateOrFn<any, any, any>\n      : FieldAsyncValidateOrFn<any, any, any>\n    value: TValue\n    type: TType\n    // When `api` is 'field', the return type cannot be `FormValidationError`\n  }): unknown {\n    if (isStandardSchemaValidator(props.validate)) {\n      return standardSchemaValidators[props.type](\n        props.value,\n        props.validate,\n      ) as never\n    }\n\n    return (props.validate as FieldValidateFn<any, any>)(props.value) as never\n  }\n\n  /**\n   * Mounts the field instance to the form.\n   */\n  mount = () => {\n    const cleanup = this.store.mount()\n\n    if (this.options.defaultValue !== undefined && !this.getMeta().isTouched) {\n      this.form.setFieldValue(this.name, this.options.defaultValue, {\n        dontUpdateMeta: true,\n      })\n    }\n\n    const info = this.getInfo()\n    info.instance = this as never\n\n    this.update(this.options as never)\n\n    const { onMount } = this.options.validators || {}\n\n    if (onMount) {\n      const error = this.runValidator({\n        validate: onMount,\n        value: {\n          value: this.state.value,\n          fieldApi: this,\n          validationSource: 'field',\n        },\n        type: 'validate',\n      })\n      if (error) {\n        this.setMeta(\n          (prev) =>\n            ({\n              ...prev,\n              // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n              errorMap: { ...prev?.errorMap, onMount: error },\n              errorSourceMap: {\n                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n                ...prev?.errorSourceMap,\n                onMount: 'field',\n              },\n            }) as never,\n        )\n      }\n    }\n\n    this.options.listeners?.onMount?.({\n      value: this.state.value,\n      fieldApi: this,\n    })\n\n    return cleanup\n  }\n\n  /**\n   * Updates the field instance with new options.\n   */\n  update = (\n    opts: FieldApiOptions<\n      TParentData,\n      TName,\n      TData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TFormOnMount,\n      TFormOnChange,\n      TFormOnChangeAsync,\n      TFormOnBlur,\n      TFormOnBlurAsync,\n      TFormOnSubmit,\n      TFormOnSubmitAsync,\n      TFormOnDynamic,\n      TFormOnDynamicAsync,\n      TFormOnServer,\n      TParentSubmitMeta\n    >,\n  ) => {\n    this.options = opts\n    this.name = opts.name\n\n    // Default Value\n    if (!this.state.meta.isTouched && this.options.defaultValue !== undefined) {\n      const formField = this.form.getFieldValue(this.name)\n      if (!evaluate(formField, opts.defaultValue)) {\n        this.form.setFieldValue(this.name, opts.defaultValue as never, {\n          dontUpdateMeta: true,\n          dontValidate: true,\n          dontRunListeners: true,\n        })\n      }\n    }\n\n    if (!this.form.getFieldMeta(this.name)) {\n      this.form.setFieldMeta(this.name, this.state.meta)\n    }\n  }\n\n  /**\n   * Gets the current field value.\n   * @deprecated Use `field.state.value` instead.\n   */\n  getValue = (): TData => {\n    return this.form.getFieldValue(this.name) as TData\n  }\n\n  /**\n   * Sets the field value and run the `change` validator.\n   */\n  setValue = (updater: Updater<TData>, options?: UpdateMetaOptions) => {\n    this.form.setFieldValue(\n      this.name,\n      updater as never,\n      mergeOpts(options, { dontRunListeners: true, dontValidate: true }),\n    )\n\n    if (!options?.dontRunListeners) {\n      this.triggerOnChangeListener()\n    }\n\n    if (!options?.dontValidate) {\n      this.validate('change')\n    }\n  }\n\n  getMeta = () => this.store.state.meta\n\n  /**\n   * Sets the field metadata.\n   */\n  setMeta = (\n    updater: Updater<\n      FieldMetaBase<\n        TParentData,\n        TName,\n        TData,\n        TOnMount,\n        TOnChange,\n        TOnChangeAsync,\n        TOnBlur,\n        TOnBlurAsync,\n        TOnSubmit,\n        TOnSubmitAsync,\n        TOnDynamic,\n        TOnDynamicAsync,\n        TFormOnMount,\n        TFormOnChange,\n        TFormOnChangeAsync,\n        TFormOnBlur,\n        TFormOnBlurAsync,\n        TFormOnSubmit,\n        TFormOnSubmitAsync,\n        TFormOnDynamic,\n        TFormOnDynamicAsync\n      >\n    >,\n  ) => this.form.setFieldMeta(this.name, updater)\n\n  /**\n   * Gets the field information object.\n   */\n  getInfo = () => this.form.getFieldInfo(this.name)\n\n  /**\n   * Pushes a new value to the field.\n   */\n  pushValue = (\n    value: TData extends any[] ? TData[number] : never,\n    options?: UpdateMetaOptions,\n  ) => {\n    this.form.pushFieldValue(\n      this.name,\n      value as any,\n      mergeOpts(options, { dontRunListeners: true }),\n    )\n\n    if (!options?.dontRunListeners) {\n      this.triggerOnChangeListener()\n    }\n  }\n\n  /**\n   * Inserts a value at the specified index, shifting the subsequent values to the right.\n   */\n  insertValue = (\n    index: number,\n    value: TData extends any[] ? TData[number] : never,\n    options?: UpdateMetaOptions,\n  ) => {\n    this.form.insertFieldValue(\n      this.name,\n      index,\n      value as any,\n      mergeOpts(options, { dontRunListeners: true }),\n    )\n\n    if (!options?.dontRunListeners) {\n      this.triggerOnChangeListener()\n    }\n  }\n\n  /**\n   * Replaces a value at the specified index.\n   */\n  replaceValue = (\n    index: number,\n    value: TData extends any[] ? TData[number] : never,\n    options?: UpdateMetaOptions,\n  ) => {\n    this.form.replaceFieldValue(\n      this.name,\n      index,\n      value as any,\n      mergeOpts(options, { dontRunListeners: true }),\n    )\n\n    if (!options?.dontRunListeners) {\n      this.triggerOnChangeListener()\n    }\n  }\n\n  /**\n   * Removes a value at the specified index.\n   */\n  removeValue = (index: number, options?: UpdateMetaOptions) => {\n    this.form.removeFieldValue(\n      this.name,\n      index,\n      mergeOpts(options, { dontRunListeners: true }),\n    )\n\n    if (!options?.dontRunListeners) {\n      this.triggerOnChangeListener()\n    }\n  }\n\n  /**\n   * Swaps the values at the specified indices.\n   */\n  swapValues = (\n    aIndex: number,\n    bIndex: number,\n    options?: UpdateMetaOptions,\n  ) => {\n    this.form.swapFieldValues(\n      this.name,\n      aIndex,\n      bIndex,\n      mergeOpts(options, { dontRunListeners: true }),\n    )\n\n    if (!options?.dontRunListeners) {\n      this.triggerOnChangeListener()\n    }\n  }\n\n  /**\n   * Moves the value at the first specified index to the second specified index.\n   */\n  moveValue = (aIndex: number, bIndex: number, options?: UpdateMetaOptions) => {\n    this.form.moveFieldValues(\n      this.name,\n      aIndex,\n      bIndex,\n      mergeOpts(options, { dontRunListeners: true }),\n    )\n\n    if (!options?.dontRunListeners) {\n      this.triggerOnChangeListener()\n    }\n  }\n\n  /**\n   * Clear all values from the array.\n   */\n  clearValues = (options?: UpdateMetaOptions) => {\n    this.form.clearFieldValues(\n      this.name,\n      mergeOpts(options, { dontRunListeners: true }),\n    )\n\n    if (!options?.dontRunListeners) {\n      this.triggerOnChangeListener()\n    }\n  }\n\n  /**\n   * @private\n   */\n  getLinkedFields = (cause: ValidationCause) => {\n    const fields = Object.values(this.form.fieldInfo) as FieldInfo<any>[]\n\n    const linkedFields: AnyFieldApi[] = []\n    for (const field of fields) {\n      if (!field.instance) continue\n      const { onChangeListenTo, onBlurListenTo } =\n        field.instance.options.validators || {}\n      if (cause === 'change' && onChangeListenTo?.includes(this.name)) {\n        linkedFields.push(field.instance)\n      }\n      if (cause === 'blur' && onBlurListenTo?.includes(this.name as string)) {\n        linkedFields.push(field.instance)\n      }\n    }\n\n    return linkedFields\n  }\n\n  /**\n   * @private\n   */\n  validateSync = (\n    cause: ValidationCause,\n    errorFromForm: ValidationErrorMap,\n  ) => {\n    const validates = getSyncValidatorArray(cause, {\n      ...this.options,\n      form: this.form,\n      validationLogic:\n        this.form.options.validationLogic || defaultValidationLogic,\n    })\n\n    const linkedFields = this.getLinkedFields(cause)\n    const linkedFieldValidates = linkedFields.reduce(\n      (acc, field) => {\n        const fieldValidates = getSyncValidatorArray(cause, {\n          ...field.options,\n          form: field.form,\n          validationLogic:\n            field.form.options.validationLogic || defaultValidationLogic,\n        })\n        fieldValidates.forEach((validate) => {\n          ;(validate as any).field = field\n        })\n        return acc.concat(fieldValidates as never)\n      },\n      [] as Array<\n        SyncValidator<any> & {\n          field: AnyFieldApi\n        }\n      >,\n    )\n\n    // Needs type cast as eslint errantly believes this is always falsy\n    let hasErrored = false as boolean\n\n    batch(() => {\n      const validateFieldFn = (\n        field: AnyFieldApi,\n        validateObj: SyncValidator<any>,\n      ) => {\n        const errorMapKey = getErrorMapKey(validateObj.cause)\n\n        const fieldLevelError = validateObj.validate\n          ? normalizeError(\n              field.runValidator({\n                validate: validateObj.validate,\n                value: {\n                  value: field.store.state.value,\n                  validationSource: 'field',\n                  fieldApi: field,\n                },\n                type: 'validate',\n              }),\n            )\n          : undefined\n\n        const formLevelError = errorFromForm[errorMapKey]\n\n        const { newErrorValue, newSource } =\n          determineFieldLevelErrorSourceAndValue({\n            formLevelError,\n            fieldLevelError,\n          })\n\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (field.state.meta.errorMap?.[errorMapKey] !== newErrorValue) {\n          field.setMeta((prev) => ({\n            ...prev,\n            errorMap: {\n              ...prev.errorMap,\n              [errorMapKey]: newErrorValue,\n            },\n            errorSourceMap: {\n              ...prev.errorSourceMap,\n              [errorMapKey]: newSource,\n            },\n          }))\n        }\n        if (newErrorValue) {\n          hasErrored = true\n        }\n      }\n\n      for (const validateObj of validates) {\n        validateFieldFn(this, validateObj)\n      }\n      for (const fieldValitateObj of linkedFieldValidates) {\n        if (!fieldValitateObj.validate) continue\n        validateFieldFn(fieldValitateObj.field, fieldValitateObj)\n      }\n    })\n\n    /**\n     *  when we have an error for onSubmit in the state, we want\n     *  to clear the error as soon as the user enters a valid value in the field\n     */\n    const submitErrKey = getErrorMapKey('submit')\n\n    if (\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      this.state.meta.errorMap?.[submitErrKey] &&\n      cause !== 'submit' &&\n      !hasErrored\n    ) {\n      this.setMeta((prev) => ({\n        ...prev,\n        errorMap: {\n          ...prev.errorMap,\n          [submitErrKey]: undefined,\n        },\n        errorSourceMap: {\n          ...prev.errorSourceMap,\n          [submitErrKey]: undefined,\n        },\n      }))\n    }\n\n    return { hasErrored }\n  }\n\n  /**\n   * @private\n   */\n  validateAsync = async (\n    cause: ValidationCause,\n    formValidationResultPromise: Promise<\n      FieldErrorMapFromValidator<\n        TParentData,\n        TName,\n        TData,\n        TOnMount,\n        TOnChange,\n        TOnChangeAsync,\n        TOnBlur,\n        TOnBlurAsync,\n        TOnSubmit,\n        TOnSubmitAsync\n      >\n    >,\n  ) => {\n    const validates = getAsyncValidatorArray(cause, {\n      ...this.options,\n      form: this.form,\n      validationLogic:\n        this.form.options.validationLogic || defaultValidationLogic,\n    })\n\n    // Get the field-specific error messages that are coming from the form's validator\n    const asyncFormValidationResults = await formValidationResultPromise\n\n    const linkedFields = this.getLinkedFields(cause)\n    const linkedFieldValidates = linkedFields.reduce(\n      (acc, field) => {\n        const fieldValidates = getAsyncValidatorArray(cause, {\n          ...field.options,\n          form: field.form,\n          validationLogic:\n            field.form.options.validationLogic || defaultValidationLogic,\n        })\n        fieldValidates.forEach((validate) => {\n          ;(validate as any).field = field\n        })\n        return acc.concat(fieldValidates as never)\n      },\n      [] as Array<\n        AsyncValidator<any> & {\n          field: AnyFieldApi\n        }\n      >,\n    )\n\n    /**\n     * We have to use a for loop and generate our promises this way, otherwise it won't be sync\n     * when there are no validators needed to be run\n     */\n    const validatesPromises: Promise<ValidationError | undefined>[] = []\n    const linkedPromises: Promise<ValidationError | undefined>[] = []\n\n    // Check if there are actual async validators to run before setting isValidating\n    // This prevents unnecessary re-renders when there are no async validators\n    // See: https://github.com/TanStack/form/issues/1130\n    const hasAsyncValidators =\n      validates.some((v) => v.validate) ||\n      linkedFieldValidates.some((v) => v.validate)\n\n    if (hasAsyncValidators) {\n      if (!this.state.meta.isValidating) {\n        this.setMeta((prev) => ({ ...prev, isValidating: true }))\n      }\n\n      for (const linkedField of linkedFields) {\n        linkedField.setMeta((prev) => ({ ...prev, isValidating: true }))\n      }\n    }\n\n    const validateFieldAsyncFn = (\n      field: AnyFieldApi,\n      validateObj: AsyncValidator<any>,\n      promises: Promise<ValidationError | undefined>[],\n    ) => {\n      const errorMapKey = getErrorMapKey(validateObj.cause)\n      const fieldValidatorMeta = field.getInfo().validationMetaMap[errorMapKey]\n\n      fieldValidatorMeta?.lastAbortController.abort()\n      const controller = new AbortController()\n\n      this.getInfo().validationMetaMap[errorMapKey] = {\n        lastAbortController: controller,\n      }\n\n      promises.push(\n        new Promise<ValidationError | undefined>(async (resolve) => {\n          let rawError!: ValidationError | undefined\n          try {\n            rawError = await new Promise((rawResolve, rawReject) => {\n              if (this.timeoutIds.validations[validateObj.cause]) {\n                clearTimeout(this.timeoutIds.validations[validateObj.cause]!)\n              }\n\n              this.timeoutIds.validations[validateObj.cause] = setTimeout(\n                async () => {\n                  if (controller.signal.aborted) return rawResolve(undefined)\n                  try {\n                    rawResolve(\n                      await this.runValidator({\n                        validate: validateObj.validate,\n                        value: {\n                          value: field.store.state.value,\n                          fieldApi: field,\n                          signal: controller.signal,\n                          validationSource: 'field',\n                        },\n                        type: 'validateAsync',\n                      }),\n                    )\n                  } catch (e) {\n                    rawReject(e)\n                  }\n                },\n                validateObj.debounceMs,\n              )\n            })\n          } catch (e: unknown) {\n            rawError = e as ValidationError\n          }\n          if (controller.signal.aborted) return resolve(undefined)\n\n          const fieldLevelError = normalizeError(rawError)\n          const formLevelError =\n            asyncFormValidationResults[this.name]?.[errorMapKey]\n\n          const { newErrorValue, newSource } =\n            determineFieldLevelErrorSourceAndValue({\n              formLevelError,\n              fieldLevelError,\n            })\n\n          field.setMeta((prev) => {\n            return {\n              ...prev,\n              errorMap: {\n                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n                ...prev?.errorMap,\n                [errorMapKey]: newErrorValue,\n              },\n              errorSourceMap: {\n                ...prev.errorSourceMap,\n                [errorMapKey]: newSource,\n              },\n            }\n          })\n\n          resolve(newErrorValue)\n        }),\n      )\n    }\n\n    // TODO: Dedupe this logic to reduce bundle size\n    for (const validateObj of validates) {\n      if (!validateObj.validate) continue\n      validateFieldAsyncFn(this, validateObj, validatesPromises)\n    }\n    for (const fieldValitateObj of linkedFieldValidates) {\n      if (!fieldValitateObj.validate) continue\n      validateFieldAsyncFn(\n        fieldValitateObj.field,\n        fieldValitateObj,\n        linkedPromises,\n      )\n    }\n\n    let results: ValidationError[] = []\n    if (validatesPromises.length || linkedPromises.length) {\n      results = await Promise.all(validatesPromises)\n      await Promise.all(linkedPromises)\n    }\n\n    // Only reset isValidating if we set it to true earlier\n    if (hasAsyncValidators) {\n      this.setMeta((prev) => ({ ...prev, isValidating: false }))\n\n      for (const linkedField of linkedFields) {\n        linkedField.setMeta((prev) => ({ ...prev, isValidating: false }))\n      }\n    }\n\n    return results.filter(Boolean)\n  }\n\n  /**\n   * Validates the field value.\n   */\n  validate = (\n    cause: ValidationCause,\n    opts?: { skipFormValidation?: boolean },\n  ): ValidationError[] | Promise<ValidationError[]> => {\n    // If the field is pristine, do not validate\n    if (!this.state.meta.isTouched) return []\n\n    // Attempt to sync validate first\n    const { fieldsErrorMap } = opts?.skipFormValidation\n      ? { fieldsErrorMap: {} as never }\n      : this.form.validateSync(cause)\n    const { hasErrored } = this.validateSync(\n      cause,\n      fieldsErrorMap[this.name] ?? {},\n    )\n\n    if (hasErrored && !this.options.asyncAlways) {\n      this.getInfo().validationMetaMap[\n        getErrorMapKey(cause)\n      ]?.lastAbortController.abort()\n      return this.state.meta.errors\n    }\n\n    // No error? Attempt async validation\n    const formValidationResultPromise = opts?.skipFormValidation\n      ? Promise.resolve({})\n      : this.form.validateAsync(cause)\n    return this.validateAsync(cause, formValidationResultPromise)\n  }\n\n  /**\n   * Handles the change event.\n   */\n  handleChange = (updater: Updater<TData>) => {\n    this.setValue(updater)\n  }\n\n  /**\n   * Handles the blur event.\n   */\n  handleBlur = () => {\n    const prevTouched = this.state.meta.isTouched\n    if (!prevTouched) {\n      this.setMeta((prev) => ({ ...prev, isTouched: true }))\n    }\n    if (!this.state.meta.isBlurred) {\n      this.setMeta((prev) => ({ ...prev, isBlurred: true }))\n    }\n    this.validate('blur')\n\n    this.triggerOnBlurListener()\n  }\n\n  /**\n   * Updates the field's errorMap\n   */\n  setErrorMap = (\n    errorMap: ValidationErrorMap<\n      UnwrapFieldValidateOrFn<TName, TOnMount, TFormOnMount>,\n      UnwrapFieldValidateOrFn<TName, TOnChange, TFormOnChange>,\n      UnwrapFieldAsyncValidateOrFn<TName, TOnChangeAsync, TFormOnChangeAsync>,\n      UnwrapFieldValidateOrFn<TName, TOnBlur, TFormOnBlur>,\n      UnwrapFieldAsyncValidateOrFn<TName, TOnBlurAsync, TFormOnBlurAsync>,\n      UnwrapFieldValidateOrFn<TName, TOnSubmit, TFormOnSubmit>,\n      UnwrapFieldAsyncValidateOrFn<TName, TOnSubmitAsync, TFormOnSubmitAsync>,\n      UnwrapFieldValidateOrFn<TName, TOnDynamic, TFormOnDynamic>,\n      UnwrapFieldAsyncValidateOrFn<TName, TOnDynamicAsync, TFormOnDynamicAsync>\n    >,\n  ) => {\n    this.setMeta((prev) => ({\n      ...prev,\n      errorMap: {\n        ...prev.errorMap,\n        ...errorMap,\n      },\n    }))\n  }\n\n  /**\n   * Parses the field's value with the given schema and returns\n   * issues (if any). This method does NOT set any internal errors.\n   * @param schema The standard schema to parse this field's value with.\n   */\n  parseValueWithSchema = (schema: StandardSchemaV1<TData, unknown>) => {\n    return standardSchemaValidators.validate(\n      { value: this.state.value, validationSource: 'field' },\n      schema,\n    )\n  }\n\n  /**\n   * Parses the field's value with the given schema and returns\n   * issues (if any). This method does NOT set any internal errors.\n   * @param schema The standard schema to parse this field's value with.\n   */\n  parseValueWithSchemaAsync = (schema: StandardSchemaV1<TData, unknown>) => {\n    return standardSchemaValidators.validateAsync(\n      { value: this.state.value, validationSource: 'field' },\n      schema,\n    )\n  }\n\n  private triggerOnBlurListener() {\n    const formDebounceMs = this.form.options.listeners?.onBlurDebounceMs\n    if (formDebounceMs && formDebounceMs > 0) {\n      if (this.timeoutIds.formListeners.blur) {\n        clearTimeout(this.timeoutIds.formListeners.blur)\n      }\n\n      this.timeoutIds.formListeners.blur = setTimeout(() => {\n        this.form.options.listeners?.onBlur?.({\n          formApi: this.form,\n          fieldApi: this,\n        })\n      }, formDebounceMs)\n    } else {\n      this.form.options.listeners?.onBlur?.({\n        formApi: this.form,\n        fieldApi: this,\n      })\n    }\n\n    const fieldDebounceMs = this.options.listeners?.onBlurDebounceMs\n    if (fieldDebounceMs && fieldDebounceMs > 0) {\n      if (this.timeoutIds.listeners.blur) {\n        clearTimeout(this.timeoutIds.listeners.blur)\n      }\n\n      this.timeoutIds.listeners.blur = setTimeout(() => {\n        this.options.listeners?.onBlur?.({\n          value: this.state.value,\n          fieldApi: this,\n        })\n      }, fieldDebounceMs)\n    } else {\n      this.options.listeners?.onBlur?.({\n        value: this.state.value,\n        fieldApi: this,\n      })\n    }\n  }\n\n  /**\n   * @private\n   */\n  triggerOnChangeListener = () => {\n    const formDebounceMs = this.form.options.listeners?.onChangeDebounceMs\n    if (formDebounceMs && formDebounceMs > 0) {\n      if (this.timeoutIds.formListeners.change) {\n        clearTimeout(this.timeoutIds.formListeners.change)\n      }\n\n      this.timeoutIds.formListeners.change = setTimeout(() => {\n        this.form.options.listeners?.onChange?.({\n          formApi: this.form,\n          fieldApi: this,\n        })\n      }, formDebounceMs)\n    } else {\n      this.form.options.listeners?.onChange?.({\n        formApi: this.form,\n        fieldApi: this,\n      })\n    }\n\n    const fieldDebounceMs = this.options.listeners?.onChangeDebounceMs\n    if (fieldDebounceMs && fieldDebounceMs > 0) {\n      if (this.timeoutIds.listeners.change) {\n        clearTimeout(this.timeoutIds.listeners.change)\n      }\n\n      this.timeoutIds.listeners.change = setTimeout(() => {\n        this.options.listeners?.onChange?.({\n          value: this.state.value,\n          fieldApi: this,\n        })\n      }, fieldDebounceMs)\n    } else {\n      this.options.listeners?.onChange?.({\n        value: this.state.value,\n        fieldApi: this,\n      })\n    }\n  }\n}\n\nfunction normalizeError(rawError?: ValidationError) {\n  if (rawError) {\n    return rawError\n  }\n\n  return undefined\n}\n\nfunction getErrorMapKey(cause: ValidationCause) {\n  switch (cause) {\n    case 'submit':\n      return 'onSubmit'\n    case 'blur':\n      return 'onBlur'\n    case 'mount':\n      return 'onMount'\n    case 'server':\n      return 'onServer'\n    case 'dynamic':\n      return 'onDynamic'\n    case 'change':\n    default:\n      return 'onChange'\n  }\n}\n"],"names":["opts","evaluate","mergeOpts","getSyncValidatorArray","defaultValidationLogic","batch","determineFieldLevelErrorSourceAndValue","getAsyncValidatorArray","standardSchemaValidators","Derived","defaultFieldMeta","isStandardSchemaValidator"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"FieldApi.cjs","sources":["../../src/FieldApi.ts"],"sourcesContent":["import { Derived, batch } from '@tanstack/store'\nimport {\n  isStandardSchemaValidator,\n  standardSchemaValidators,\n} from './standardSchemaValidator'\nimport { defaultFieldMeta } from './metaHelper'\nimport {\n  determineFieldLevelErrorSourceAndValue,\n  evaluate,\n  getAsyncValidatorArray,\n  getBy,\n  getSyncValidatorArray,\n  mergeOpts,\n} from './utils'\nimport { defaultValidationLogic } from './ValidationLogic'\nimport type { DeepKeys, DeepValue, UnwrapOneLevelOfArray } from './util-types'\nimport type {\n  StandardSchemaV1,\n  StandardSchemaV1Issue,\n  TStandardSchemaValidatorValue,\n} from './standardSchemaValidator'\nimport type {\n  FieldInfo,\n  FormApi,\n  FormAsyncValidateOrFn,\n  FormValidateAsyncFn,\n  FormValidateFn,\n  FormValidateOrFn,\n} from './FormApi'\nimport type {\n  ListenerCause,\n  UpdateMetaOptions,\n  ValidationCause,\n  ValidationError,\n  ValidationErrorMap,\n  ValidationErrorMapSource,\n} from './types'\nimport type { AsyncValidator, SyncValidator, Updater } from './utils'\n\n/**\n * @private\n */\n// TODO: Add the `Unwrap` type to the errors\ntype FieldErrorMapFromValidator<\n  TFormData,\n  TName extends DeepKeys<TFormData>,\n  TData extends DeepValue<TFormData, TName>,\n  TOnMount extends undefined | FieldValidateOrFn<TFormData, TName, TData>,\n  TOnChange extends undefined | FieldValidateOrFn<TFormData, TName, TData>,\n  TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TFormData, TName, TData>,\n  TOnBlur extends undefined | FieldValidateOrFn<TFormData, TName, TData>,\n  TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TFormData, TName, TData>,\n  TOnSubmit extends undefined | FieldValidateOrFn<TFormData, TName, TData>,\n  TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TFormData, TName, TData>,\n> = Partial<\n  Record<\n    DeepKeys<TFormData>,\n    ValidationErrorMap<\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync\n    >\n  >\n>\n\n/**\n * @private\n */\nexport type FieldValidateFn<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n> = (props: {\n  value: TData\n  fieldApi: FieldApi<\n    TParentData,\n    TName,\n    TData,\n    // This is technically an edge-type; which we try to keep non-`any`, but in this case\n    // It's referring to an inaccessible type from the field validate function inner types, so it's not a big deal\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any\n  >\n}) => unknown\n\n/**\n * @private\n */\nexport type FieldValidateOrFn<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n> =\n  | FieldValidateFn<TParentData, TName, TData>\n  | StandardSchemaV1<TData, unknown>\n\ntype StandardBrandedSchemaV1<T> = T & { __standardSchemaV1: true }\n\ntype UnwrapFormValidateOrFnForInner<\n  TValidateOrFn extends undefined | FormValidateOrFn<any>,\n> = [TValidateOrFn] extends [FormValidateFn<any>]\n  ? ReturnType<TValidateOrFn>\n  : [TValidateOrFn] extends [StandardSchemaV1<infer TOut, any>]\n    ? StandardBrandedSchemaV1<TOut>\n    : undefined\n\nexport type UnwrapFieldValidateOrFn<\n  TName extends string,\n  TValidateOrFn extends undefined | FieldValidateOrFn<any, any, any>,\n  TFormValidateOrFn extends undefined | FormValidateOrFn<any>,\n> =\n  | ([TFormValidateOrFn] extends [StandardSchemaV1<any, infer TStandardOut>]\n      ? TName extends keyof TStandardOut\n        ? StandardSchemaV1Issue[]\n        : undefined\n      : undefined)\n  | (UnwrapFormValidateOrFnForInner<TFormValidateOrFn> extends infer TFormValidateVal\n      ? TFormValidateVal extends { __standardSchemaV1: true }\n        ? [DeepValue<TFormValidateVal, TName>] extends [never]\n          ? undefined\n          : StandardSchemaV1Issue[]\n        : TFormValidateVal extends { fields: any }\n          ? TName extends keyof TFormValidateVal['fields']\n            ? TFormValidateVal['fields'][TName]\n            : undefined\n          : undefined\n      : never)\n  | ([TValidateOrFn] extends [FieldValidateFn<any, any, any>]\n      ? ReturnType<TValidateOrFn>\n      : [TValidateOrFn] extends [StandardSchemaV1<any, any>]\n        ? // TODO: Check if `disableErrorFlat` is enabled, if so, return StandardSchemaV1Issue[][]\n          StandardSchemaV1Issue[]\n        : undefined)\n\n/**\n * @private\n */\nexport type FieldValidateAsyncFn<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n> = (options: {\n  value: TData\n  fieldApi: FieldApi<\n    TParentData,\n    TName,\n    TData,\n    // This is technically an edge-type; which we try to keep non-`any`, but in this case\n    // It's referring to an inaccessible type from the field validate function inner types, so it's not a big deal\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any\n  >\n  signal: AbortSignal\n}) => unknown | Promise<unknown>\n\n/**\n * @private\n */\nexport type FieldAsyncValidateOrFn<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n> =\n  | FieldValidateAsyncFn<TParentData, TName, TData>\n  | StandardSchemaV1<TData, unknown>\n\ntype UnwrapFormAsyncValidateOrFnForInner<\n  TValidateOrFn extends undefined | FormAsyncValidateOrFn<any>,\n> = [TValidateOrFn] extends [FormValidateAsyncFn<any>]\n  ? Awaited<ReturnType<TValidateOrFn>>\n  : [TValidateOrFn] extends [StandardSchemaV1<infer TOut, any>]\n    ? StandardBrandedSchemaV1<TOut>\n    : undefined\n\nexport type UnwrapFieldAsyncValidateOrFn<\n  TName extends string,\n  TValidateOrFn extends undefined | FieldAsyncValidateOrFn<any, any, any>,\n  TFormValidateOrFn extends undefined | FormAsyncValidateOrFn<any>,\n> =\n  | ([TFormValidateOrFn] extends [StandardSchemaV1<any, infer TStandardOut>]\n      ? TName extends keyof TStandardOut\n        ? StandardSchemaV1Issue[]\n        : undefined\n      : undefined)\n  | (UnwrapFormAsyncValidateOrFnForInner<TFormValidateOrFn> extends infer TFormValidateVal\n      ? TFormValidateVal extends { __standardSchemaV1: true }\n        ? [DeepValue<TFormValidateVal, TName>] extends [never]\n          ? undefined\n          : StandardSchemaV1Issue[]\n        : TFormValidateVal extends { fields: any }\n          ? TName extends keyof TFormValidateVal['fields']\n            ? TFormValidateVal['fields'][TName]\n            : undefined\n          : undefined\n      : never)\n  | ([TValidateOrFn] extends [FieldValidateAsyncFn<any, any, any>]\n      ? Awaited<ReturnType<TValidateOrFn>>\n      : [TValidateOrFn] extends [StandardSchemaV1<any, any>]\n        ? // TODO: Check if `disableErrorFlat` is enabled, if so, return StandardSchemaV1Issue[][]\n          StandardSchemaV1Issue[]\n        : undefined)\n\n/**\n * @private\n */\nexport type FieldListenerFn<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n> = (props: {\n  value: TData\n  fieldApi: FieldApi<\n    TParentData,\n    TName,\n    TData,\n    // This is technically an edge-type; which we try to keep non-`any`, but in this case\n    // It's referring to an inaccessible type from the field listener function inner types, so it's not a big deal\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any\n  >\n}) => void\n\nexport interface FieldValidators<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName>,\n  TOnMount extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChange extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnBlur extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnSubmit extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnDynamic extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnDynamicAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n> {\n  /**\n   * An optional function, that runs on the mount event of input.\n   */\n  onMount?: TOnMount\n  /**\n   * An optional function, that runs on the change event of input.\n   *\n   * @example z.string().min(1)\n   */\n  onChange?: TOnChange\n  /**\n   * An optional property similar to `onChange` but async validation\n   *\n   * @example z.string().refine(async (val) => val.length > 3, { message: 'Testing 123' })\n   */\n  onChangeAsync?: TOnChangeAsync\n  /**\n   * An optional number to represent how long the `onChangeAsync` should wait before running\n   *\n   * If set to a number larger than 0, will debounce the async validation event by this length of time in milliseconds\n   */\n  onChangeAsyncDebounceMs?: number\n  /**\n   * An optional list of field names that should trigger this field's `onChange` and `onChangeAsync` events when its value changes\n   */\n  onChangeListenTo?: DeepKeys<TParentData>[]\n  /**\n   * An optional function, that runs on the blur event of input.\n   *\n   * @example z.string().min(1)\n   */\n  onBlur?: TOnBlur\n  /**\n   * An optional property similar to `onBlur` but async validation.\n   *\n   * @example z.string().refine(async (val) => val.length > 3, { message: 'Testing 123' })\n   */\n  onBlurAsync?: TOnBlurAsync\n\n  /**\n   * An optional number to represent how long the `onBlurAsync` should wait before running\n   *\n   * If set to a number larger than 0, will debounce the async validation event by this length of time in milliseconds\n   */\n  onBlurAsyncDebounceMs?: number\n  /**\n   * An optional list of field names that should trigger this field's `onBlur` and `onBlurAsync` events when its value changes\n   */\n  onBlurListenTo?: DeepKeys<TParentData>[]\n  /**\n   * An optional function, that runs on the submit event of form.\n   *\n   * @example z.string().min(1)\n   */\n  onSubmit?: TOnSubmit\n  /**\n   * An optional property similar to `onSubmit` but async validation.\n   *\n   * @example z.string().refine(async (val) => val.length > 3, { message: 'Testing 123' })\n   */\n  onSubmitAsync?: TOnSubmitAsync\n  onDynamic?: TOnDynamic\n  onDynamicAsync?: TOnDynamicAsync\n  onDynamicAsyncDebounceMs?: number\n}\n\nexport interface FieldListeners<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n> {\n  onChange?: FieldListenerFn<TParentData, TName, TData>\n  onChangeDebounceMs?: number\n  onBlur?: FieldListenerFn<TParentData, TName, TData>\n  onBlurDebounceMs?: number\n  onMount?: FieldListenerFn<TParentData, TName, TData>\n  onSubmit?: FieldListenerFn<TParentData, TName, TData>\n}\n\n/**\n * An object type representing the options for a field in a form.\n */\nexport interface FieldOptions<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName>,\n  TOnMount extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChange extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnBlur extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnSubmit extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnDynamic extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnDynamicAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n> {\n  /**\n   * The field name. The type will be `DeepKeys<TParentData>` to ensure your name is a deep key of the parent dataset.\n   */\n  name: TName\n  /**\n   * An optional default value for the field.\n   */\n  defaultValue?: NoInfer<TData>\n  /**\n   * The default time to debounce async validation if there is not a more specific debounce time passed.\n   */\n  asyncDebounceMs?: number\n  /**\n   * If `true`, always run async validation, even if there are errors emitted during synchronous validation.\n   */\n  asyncAlways?: boolean\n  /**\n   * A list of validators to pass to the field\n   */\n  validators?: FieldValidators<\n    TParentData,\n    TName,\n    TData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TOnDynamic,\n    TOnDynamicAsync\n  >\n  /**\n   * An optional object with default metadata for the field.\n   */\n  defaultMeta?: Partial<\n    FieldMeta<\n      TParentData,\n      TName,\n      TData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      any,\n      any,\n      any,\n      any,\n      any,\n      any,\n      any,\n      any,\n      any\n    >\n  >\n  /**\n   * A list of listeners which attach to the corresponding events\n   */\n  listeners?: FieldListeners<TParentData, TName, TData>\n  /**\n   * Disable the `flat(1)` operation on `field.errors`. This is useful if you want to keep the error structure as is. Not suggested for most use-cases.\n   */\n  disableErrorFlat?: boolean\n}\n\n/**\n * An object type representing the required options for the FieldApi class.\n */\nexport interface FieldApiOptions<\n  in out TParentData,\n  in out TName extends DeepKeys<TParentData>,\n  in out TData extends DeepValue<TParentData, TName>,\n  in out TOnMount extends\n    | undefined\n    | FieldValidateOrFn<TParentData, TName, TData>,\n  in out TOnChange extends\n    | undefined\n    | FieldValidateOrFn<TParentData, TName, TData>,\n  in out TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  in out TOnBlur extends\n    | undefined\n    | FieldValidateOrFn<TParentData, TName, TData>,\n  in out TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  in out TOnSubmit extends\n    | undefined\n    | FieldValidateOrFn<TParentData, TName, TData>,\n  in out TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  in out TOnDynamic extends\n    | undefined\n    | FieldValidateOrFn<TParentData, TName, TData>,\n  in out TOnDynamicAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  in out TFormOnMount extends undefined | FormValidateOrFn<TParentData>,\n  in out TFormOnChange extends undefined | FormValidateOrFn<TParentData>,\n  in out TFormOnChangeAsync extends\n    | undefined\n    | FormAsyncValidateOrFn<TParentData>,\n  in out TFormOnBlur extends undefined | FormValidateOrFn<TParentData>,\n  in out TFormOnBlurAsync extends\n    | undefined\n    | FormAsyncValidateOrFn<TParentData>,\n  in out TFormOnSubmit extends undefined | FormValidateOrFn<TParentData>,\n  in out TFormOnSubmitAsync extends\n    | undefined\n    | FormAsyncValidateOrFn<TParentData>,\n  in out TFormOnDynamic extends undefined | FormValidateOrFn<TParentData>,\n  in out TFormOnDynamicAsync extends\n    | undefined\n    | FormAsyncValidateOrFn<TParentData>,\n  in out TFormOnServer extends undefined | FormAsyncValidateOrFn<TParentData>,\n  in out TParentSubmitMeta,\n> extends FieldOptions<\n  TParentData,\n  TName,\n  TData,\n  TOnMount,\n  TOnChange,\n  TOnChangeAsync,\n  TOnBlur,\n  TOnBlurAsync,\n  TOnSubmit,\n  TOnSubmitAsync,\n  TOnDynamic,\n  TOnDynamicAsync\n> {\n  form: FormApi<\n    TParentData,\n    TFormOnMount,\n    TFormOnChange,\n    TFormOnChangeAsync,\n    TFormOnBlur,\n    TFormOnBlurAsync,\n    TFormOnSubmit,\n    TFormOnSubmitAsync,\n    TFormOnDynamic,\n    TFormOnDynamicAsync,\n    TFormOnServer,\n    TParentSubmitMeta\n  >\n}\n\nexport type FieldMetaBase<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName>,\n  TOnMount extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChange extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnBlur extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnSubmit extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnDynamic extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnDynamicAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TFormOnMount extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChange extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChangeAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnBlur extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnBlurAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnSubmit extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnDynamic extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n> = {\n  /**\n   * A flag indicating whether the field has been touched.\n   */\n  isTouched: boolean\n  /**\n   * A flag indicating whether the field has been blurred.\n   */\n  isBlurred: boolean\n  /**\n   * A flag that is `true` if the field's value has been modified by the user. Opposite of `isPristine`.\n   */\n  isDirty: boolean\n  /**\n   * A map of errors related to the field value.\n   */\n  errorMap: ValidationErrorMap<\n    UnwrapFieldValidateOrFn<TName, TOnMount, TFormOnMount>,\n    UnwrapFieldValidateOrFn<TName, TOnChange, TFormOnChange>,\n    UnwrapFieldAsyncValidateOrFn<TName, TOnChangeAsync, TFormOnChangeAsync>,\n    UnwrapFieldValidateOrFn<TName, TOnBlur, TFormOnBlur>,\n    UnwrapFieldAsyncValidateOrFn<TName, TOnBlurAsync, TFormOnBlurAsync>,\n    UnwrapFieldValidateOrFn<TName, TOnSubmit, TFormOnSubmit>,\n    UnwrapFieldAsyncValidateOrFn<TName, TOnSubmitAsync, TFormOnSubmitAsync>,\n    UnwrapFieldValidateOrFn<TName, TOnDynamic, TFormOnDynamic>,\n    UnwrapFieldAsyncValidateOrFn<TName, TOnDynamicAsync, TFormOnDynamicAsync>\n  >\n\n  /**\n   * @private allows tracking the source of the errors in the error map\n   */\n  errorSourceMap: ValidationErrorMapSource\n  /**\n   * A flag indicating whether the field is currently being validated.\n   */\n  isValidating: boolean\n}\n\nexport type AnyFieldMetaBase = FieldMetaBase<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any\n>\n\nexport type FieldMetaDerived<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName>,\n  TOnMount extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChange extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnBlur extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnSubmit extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnDynamic extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnDynamicAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TFormOnMount extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChange extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChangeAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnBlur extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnBlurAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnSubmit extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnDynamic extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n> = {\n  /**\n   * An array of errors related to the field value.\n   */\n  errors: Array<\n    | UnwrapOneLevelOfArray<\n        UnwrapFieldValidateOrFn<TName, TOnMount, TFormOnMount>\n      >\n    | UnwrapOneLevelOfArray<\n        UnwrapFieldValidateOrFn<TName, TOnChange, TFormOnChange>\n      >\n    | UnwrapOneLevelOfArray<\n        UnwrapFieldAsyncValidateOrFn<TName, TOnChangeAsync, TFormOnChangeAsync>\n      >\n    | UnwrapOneLevelOfArray<\n        UnwrapFieldValidateOrFn<TName, TOnBlur, TFormOnBlur>\n      >\n    | UnwrapOneLevelOfArray<\n        UnwrapFieldAsyncValidateOrFn<TName, TOnBlurAsync, TFormOnBlurAsync>\n      >\n    | UnwrapOneLevelOfArray<\n        UnwrapFieldValidateOrFn<TName, TOnSubmit, TFormOnSubmit>\n      >\n    | UnwrapOneLevelOfArray<\n        UnwrapFieldAsyncValidateOrFn<TName, TOnSubmitAsync, TFormOnSubmitAsync>\n      >\n    | UnwrapOneLevelOfArray<\n        UnwrapFieldValidateOrFn<TName, TOnDynamic, TFormOnDynamic>\n      >\n    | UnwrapOneLevelOfArray<\n        UnwrapFieldAsyncValidateOrFn<\n          TName,\n          TOnDynamicAsync,\n          TFormOnDynamicAsync\n        >\n      >\n  >\n  /**\n   * A flag that is `true` if the field's value has not been modified by the user. Opposite of `isDirty`.\n   */\n  isPristine: boolean\n  /**\n   * A boolean indicating if the field is valid. Evaluates `true` if there are no field errors.\n   */\n  isValid: boolean\n  /**\n   * A flag indicating whether the field's current value is the default value\n   */\n  isDefaultValue: boolean\n}\n\nexport type AnyFieldMetaDerived = FieldMetaDerived<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any\n>\n\n/**\n * An object type representing the metadata of a field in a form.\n */\nexport type FieldMeta<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName>,\n  TOnMount extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChange extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnBlur extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnSubmit extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnDynamic extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnDynamicAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TFormOnMount extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChange extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChangeAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnBlur extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnBlurAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnSubmit extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnDynamic extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n> = FieldMetaBase<\n  TParentData,\n  TName,\n  TData,\n  TOnMount,\n  TOnChange,\n  TOnChangeAsync,\n  TOnBlur,\n  TOnBlurAsync,\n  TOnSubmit,\n  TOnSubmitAsync,\n  TOnDynamic,\n  TOnDynamicAsync,\n  TFormOnMount,\n  TFormOnChange,\n  TFormOnChangeAsync,\n  TFormOnBlur,\n  TFormOnBlurAsync,\n  TFormOnSubmit,\n  TFormOnSubmitAsync,\n  TFormOnDynamic,\n  TFormOnDynamicAsync\n> &\n  FieldMetaDerived<\n    TParentData,\n    TName,\n    TData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TOnDynamic,\n    TOnDynamicAsync,\n    TFormOnMount,\n    TFormOnChange,\n    TFormOnChangeAsync,\n    TFormOnBlur,\n    TFormOnBlurAsync,\n    TFormOnSubmit,\n    TFormOnSubmitAsync,\n    TFormOnDynamic,\n    TFormOnDynamicAsync\n  >\n\nexport type AnyFieldMeta = FieldMeta<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any\n>\n\n/**\n * An object type representing the state of a field.\n */\nexport type FieldState<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName>,\n  TOnMount extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChange extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnBlur extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnSubmit extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnDynamic extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnDynamicAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TFormOnMount extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChange extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChangeAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnBlur extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnBlurAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnSubmit extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnDynamic extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n> = {\n  /**\n   * The current value of the field.\n   */\n  value: TData\n  /**\n   * The current metadata of the field.\n   */\n  meta: FieldMeta<\n    TParentData,\n    TName,\n    TData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TOnDynamic,\n    TOnDynamicAsync,\n    TFormOnMount,\n    TFormOnChange,\n    TFormOnChangeAsync,\n    TFormOnBlur,\n    TFormOnBlurAsync,\n    TFormOnSubmit,\n    TFormOnSubmitAsync,\n    TFormOnDynamic,\n    TFormOnDynamicAsync\n  >\n}\n\n/**\n * @public\n *\n * A type representing the Field API with all generics set to `any` for convenience.\n */\nexport type AnyFieldApi = FieldApi<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any\n>\n\n/**\n * We cannot use methods and must use arrow functions. Otherwise, our React adapters\n * will break due to loss of the method when using spread.\n */\n\n/**\n * A class representing the API for managing a form field.\n *\n * Normally, you will not need to create a new `FieldApi` instance directly.\n * Instead, you will use a framework hook/function like `useField` or `createField`\n * to create a new instance for you that uses your framework's reactivity model.\n * However, if you need to create a new instance manually, you can do so by calling\n * the `new FieldApi` constructor.\n */\nexport class FieldApi<\n  in out TParentData,\n  in out TName extends DeepKeys<TParentData>,\n  in out TData extends DeepValue<TParentData, TName>,\n  in out TOnMount extends\n    | undefined\n    | FieldValidateOrFn<TParentData, TName, TData>,\n  in out TOnChange extends\n    | undefined\n    | FieldValidateOrFn<TParentData, TName, TData>,\n  in out TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  in out TOnBlur extends\n    | undefined\n    | FieldValidateOrFn<TParentData, TName, TData>,\n  in out TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  in out TOnSubmit extends\n    | undefined\n    | FieldValidateOrFn<TParentData, TName, TData>,\n  in out TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  in out TOnDynamic extends\n    | undefined\n    | FieldValidateOrFn<TParentData, TName, TData>,\n  in out TOnDynamicAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  in out TFormOnMount extends undefined | FormValidateOrFn<TParentData>,\n  in out TFormOnChange extends undefined | FormValidateOrFn<TParentData>,\n  in out TFormOnChangeAsync extends\n    | undefined\n    | FormAsyncValidateOrFn<TParentData>,\n  in out TFormOnBlur extends undefined | FormValidateOrFn<TParentData>,\n  in out TFormOnBlurAsync extends\n    | undefined\n    | FormAsyncValidateOrFn<TParentData>,\n  in out TFormOnSubmit extends undefined | FormValidateOrFn<TParentData>,\n  in out TFormOnSubmitAsync extends\n    | undefined\n    | FormAsyncValidateOrFn<TParentData>,\n  in out TFormOnDynamic extends undefined | FormValidateOrFn<TParentData>,\n  in out TFormOnDynamicAsync extends\n    | undefined\n    | FormAsyncValidateOrFn<TParentData>,\n  in out TFormOnServer extends undefined | FormAsyncValidateOrFn<TParentData>,\n  in out TParentSubmitMeta,\n> {\n  /**\n   * A reference to the form API instance.\n   */\n  form: FieldApiOptions<\n    TParentData,\n    TName,\n    TData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TOnDynamic,\n    TOnDynamicAsync,\n    TFormOnMount,\n    TFormOnChange,\n    TFormOnChangeAsync,\n    TFormOnBlur,\n    TFormOnBlurAsync,\n    TFormOnSubmit,\n    TFormOnSubmitAsync,\n    TFormOnDynamic,\n    TFormOnDynamicAsync,\n    TFormOnServer,\n    TParentSubmitMeta\n  >['form']\n  /**\n   * The field name.\n   */\n  name: TName\n  /**\n   * The field options.\n   */\n  options: FieldApiOptions<\n    TParentData,\n    TName,\n    TData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TOnDynamic,\n    TOnDynamicAsync,\n    TFormOnMount,\n    TFormOnChange,\n    TFormOnChangeAsync,\n    TFormOnBlur,\n    TFormOnBlurAsync,\n    TFormOnSubmit,\n    TFormOnSubmitAsync,\n    TFormOnDynamic,\n    TFormOnDynamicAsync,\n    TFormOnServer,\n    TParentSubmitMeta\n  > = {} as any\n  /**\n   * The field state store.\n   */\n  store!: Derived<\n    FieldState<\n      TParentData,\n      TName,\n      TData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TFormOnMount,\n      TFormOnChange,\n      TFormOnChangeAsync,\n      TFormOnBlur,\n      TFormOnBlurAsync,\n      TFormOnSubmit,\n      TFormOnSubmitAsync,\n      TFormOnDynamic,\n      TFormOnDynamicAsync\n    >\n  >\n  /**\n   * The current field state.\n   */\n  get state() {\n    return this.store.state\n  }\n  timeoutIds: {\n    validations: Record<ValidationCause, ReturnType<typeof setTimeout> | null>\n    listeners: Record<ListenerCause, ReturnType<typeof setTimeout> | null>\n    formListeners: Record<ListenerCause, ReturnType<typeof setTimeout> | null>\n  }\n\n  /**\n   * Initializes a new `FieldApi` instance.\n   */\n  constructor(\n    opts: FieldApiOptions<\n      TParentData,\n      TName,\n      TData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TFormOnMount,\n      TFormOnChange,\n      TFormOnChangeAsync,\n      TFormOnBlur,\n      TFormOnBlurAsync,\n      TFormOnSubmit,\n      TFormOnSubmitAsync,\n      TFormOnDynamic,\n      TFormOnDynamicAsync,\n      TFormOnServer,\n      TParentSubmitMeta\n    >,\n  ) {\n    this.form = opts.form\n    this.name = opts.name\n    this.options = opts\n\n    this.timeoutIds = {\n      validations: {} as Record<ValidationCause, never>,\n      listeners: {} as Record<ListenerCause, never>,\n      formListeners: {} as Record<ListenerCause, never>,\n    }\n\n    this.store = new Derived({\n      deps: [this.form.store],\n      fn: () => {\n        const meta = this.form.getFieldMeta(this.name) ?? {\n          ...defaultFieldMeta,\n          ...opts.defaultMeta,\n        }\n\n        let value = this.form.getFieldValue(this.name)\n        if (\n          !meta.isTouched &&\n          (value as unknown) === undefined &&\n          this.options.defaultValue !== undefined &&\n          !evaluate(value, this.options.defaultValue)\n        ) {\n          value = this.options.defaultValue\n        }\n\n        return {\n          value,\n          meta,\n        } as FieldState<\n          TParentData,\n          TName,\n          TData,\n          TOnMount,\n          TOnChange,\n          TOnChangeAsync,\n          TOnBlur,\n          TOnBlurAsync,\n          TOnSubmit,\n          TOnSubmitAsync,\n          TOnDynamic,\n          TOnDynamicAsync,\n          TFormOnMount,\n          TFormOnChange,\n          TFormOnChangeAsync,\n          TFormOnBlur,\n          TFormOnBlurAsync,\n          TFormOnSubmit,\n          TFormOnSubmitAsync,\n          TFormOnDynamic,\n          TFormOnDynamicAsync\n        >\n      },\n    })\n  }\n\n  /**\n   * @private\n   */\n  runValidator<\n    TValue extends TStandardSchemaValidatorValue<TData> & {\n      fieldApi: AnyFieldApi\n    },\n    TType extends 'validate' | 'validateAsync',\n  >(props: {\n    validate: TType extends 'validate'\n      ? FieldValidateOrFn<any, any, any>\n      : FieldAsyncValidateOrFn<any, any, any>\n    value: TValue\n    type: TType\n    // When `api` is 'field', the return type cannot be `FormValidationError`\n  }): unknown {\n    if (isStandardSchemaValidator(props.validate)) {\n      return standardSchemaValidators[props.type](\n        props.value,\n        props.validate,\n      ) as never\n    }\n\n    return (props.validate as FieldValidateFn<any, any>)(props.value) as never\n  }\n\n  /**\n   * Mounts the field instance to the form.\n   */\n  mount = () => {\n    const cleanup = this.store.mount()\n\n    if (this.options.defaultValue !== undefined && !this.getMeta().isTouched) {\n      this.form.setFieldValue(this.name, this.options.defaultValue, {\n        dontUpdateMeta: true,\n      })\n    }\n\n    const info = this.getInfo()\n    info.instance = this as never\n\n    this.update(this.options as never)\n    const { onMount } = this.options.validators || {}\n\n    if (onMount) {\n      const error = this.runValidator({\n        validate: onMount,\n        value: {\n          value: this.state.value,\n          fieldApi: this,\n          validationSource: 'field',\n        },\n        type: 'validate',\n      })\n      if (error) {\n        this.setMeta(\n          (prev) =>\n            ({\n              ...prev,\n              // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n              errorMap: { ...prev?.errorMap, onMount: error },\n              errorSourceMap: {\n                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n                ...prev?.errorSourceMap,\n                onMount: 'field',\n              },\n            }) as never,\n        )\n      }\n    }\n\n    this.options.listeners?.onMount?.({\n      value: this.state.value,\n      fieldApi: this,\n    })\n\n    return cleanup\n  }\n\n  /**\n   * Updates the field instance with new options.\n   */\n  update = (\n    opts: FieldApiOptions<\n      TParentData,\n      TName,\n      TData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TFormOnMount,\n      TFormOnChange,\n      TFormOnChangeAsync,\n      TFormOnBlur,\n      TFormOnBlurAsync,\n      TFormOnSubmit,\n      TFormOnSubmitAsync,\n      TFormOnDynamic,\n      TFormOnDynamicAsync,\n      TFormOnServer,\n      TParentSubmitMeta\n    >,\n  ) => {\n    this.options = opts\n    this.name = opts.name\n\n    // Default Value\n    if (!this.state.meta.isTouched && this.options.defaultValue !== undefined) {\n      const formField = this.form.getFieldValue(this.name)\n      if (!evaluate(formField, opts.defaultValue)) {\n        this.form.setFieldValue(this.name, opts.defaultValue as never, {\n          dontUpdateMeta: true,\n          dontValidate: true,\n          dontRunListeners: true,\n        })\n      }\n    }\n\n    if (!this.form.getFieldMeta(this.name)) {\n      this.form.setFieldMeta(this.name, this.state.meta)\n    }\n  }\n\n  /**\n   * Gets the current field value.\n   * @deprecated Use `field.state.value` instead.\n   */\n  getValue = (): TData => {\n    return this.form.getFieldValue(this.name) as TData\n  }\n\n  /**\n   * Sets the field value and run the `change` validator.\n   */\n  setValue = (updater: Updater<TData>, options?: UpdateMetaOptions) => {\n    this.form.setFieldValue(\n      this.name,\n      updater as never,\n      mergeOpts(options, { dontRunListeners: true, dontValidate: true }),\n    )\n\n    if (!options?.dontRunListeners) {\n      this.triggerOnChangeListener()\n    }\n\n    if (!options?.dontValidate) {\n      this.validate('change')\n    }\n  }\n\n  getMeta = () => this.store.state.meta\n\n  /**\n   * Sets the field metadata.\n   */\n  setMeta = (\n    updater: Updater<\n      FieldMetaBase<\n        TParentData,\n        TName,\n        TData,\n        TOnMount,\n        TOnChange,\n        TOnChangeAsync,\n        TOnBlur,\n        TOnBlurAsync,\n        TOnSubmit,\n        TOnSubmitAsync,\n        TOnDynamic,\n        TOnDynamicAsync,\n        TFormOnMount,\n        TFormOnChange,\n        TFormOnChangeAsync,\n        TFormOnBlur,\n        TFormOnBlurAsync,\n        TFormOnSubmit,\n        TFormOnSubmitAsync,\n        TFormOnDynamic,\n        TFormOnDynamicAsync\n      >\n    >,\n  ) => this.form.setFieldMeta(this.name, updater)\n\n  /**\n   * Gets the field information object.\n   */\n  getInfo = () => this.form.getFieldInfo(this.name)\n\n  /**\n   * Pushes a new value to the field.\n   */\n  pushValue = (\n    value: TData extends any[] ? TData[number] : never,\n    options?: UpdateMetaOptions,\n  ) => {\n    this.form.pushFieldValue(\n      this.name,\n      value as any,\n      mergeOpts(options, { dontRunListeners: true }),\n    )\n\n    if (!options?.dontRunListeners) {\n      this.triggerOnChangeListener()\n    }\n  }\n\n  /**\n   * Inserts a value at the specified index, shifting the subsequent values to the right.\n   */\n  insertValue = (\n    index: number,\n    value: TData extends any[] ? TData[number] : never,\n    options?: UpdateMetaOptions,\n  ) => {\n    this.form.insertFieldValue(\n      this.name,\n      index,\n      value as any,\n      mergeOpts(options, { dontRunListeners: true }),\n    )\n\n    if (!options?.dontRunListeners) {\n      this.triggerOnChangeListener()\n    }\n  }\n\n  /**\n   * Replaces a value at the specified index.\n   */\n  replaceValue = (\n    index: number,\n    value: TData extends any[] ? TData[number] : never,\n    options?: UpdateMetaOptions,\n  ) => {\n    this.form.replaceFieldValue(\n      this.name,\n      index,\n      value as any,\n      mergeOpts(options, { dontRunListeners: true }),\n    )\n\n    if (!options?.dontRunListeners) {\n      this.triggerOnChangeListener()\n    }\n  }\n\n  /**\n   * Removes a value at the specified index.\n   */\n  removeValue = (index: number, options?: UpdateMetaOptions) => {\n    this.form.removeFieldValue(\n      this.name,\n      index,\n      mergeOpts(options, { dontRunListeners: true }),\n    )\n\n    if (!options?.dontRunListeners) {\n      this.triggerOnChangeListener()\n    }\n  }\n\n  /**\n   * Swaps the values at the specified indices.\n   */\n  swapValues = (\n    aIndex: number,\n    bIndex: number,\n    options?: UpdateMetaOptions,\n  ) => {\n    this.form.swapFieldValues(\n      this.name,\n      aIndex,\n      bIndex,\n      mergeOpts(options, { dontRunListeners: true }),\n    )\n\n    if (!options?.dontRunListeners) {\n      this.triggerOnChangeListener()\n    }\n  }\n\n  /**\n   * Moves the value at the first specified index to the second specified index.\n   */\n  moveValue = (aIndex: number, bIndex: number, options?: UpdateMetaOptions) => {\n    this.form.moveFieldValues(\n      this.name,\n      aIndex,\n      bIndex,\n      mergeOpts(options, { dontRunListeners: true }),\n    )\n\n    if (!options?.dontRunListeners) {\n      this.triggerOnChangeListener()\n    }\n  }\n\n  /**\n   * Clear all values from the array.\n   */\n  clearValues = (options?: UpdateMetaOptions) => {\n    this.form.clearFieldValues(\n      this.name,\n      mergeOpts(options, { dontRunListeners: true }),\n    )\n\n    if (!options?.dontRunListeners) {\n      this.triggerOnChangeListener()\n    }\n  }\n\n  /**\n   * @private\n   */\n  getLinkedFields = (cause: ValidationCause) => {\n    const fields = Object.values(this.form.fieldInfo) as FieldInfo<any>[]\n\n    const linkedFields: AnyFieldApi[] = []\n    for (const field of fields) {\n      if (!field.instance) continue\n      const { onChangeListenTo, onBlurListenTo } =\n        field.instance.options.validators || {}\n      if (cause === 'change' && onChangeListenTo?.includes(this.name)) {\n        linkedFields.push(field.instance)\n      }\n      if (cause === 'blur' && onBlurListenTo?.includes(this.name as string)) {\n        linkedFields.push(field.instance)\n      }\n    }\n\n    return linkedFields\n  }\n\n  /**\n   * @private\n   */\n  validateSync = (\n    cause: ValidationCause,\n    errorFromForm: ValidationErrorMap,\n  ) => {\n    const validates = getSyncValidatorArray(cause, {\n      ...this.options,\n      form: this.form,\n      validationLogic:\n        this.form.options.validationLogic || defaultValidationLogic,\n    })\n\n    const linkedFields = this.getLinkedFields(cause)\n    const linkedFieldValidates = linkedFields.reduce(\n      (acc, field) => {\n        const fieldValidates = getSyncValidatorArray(cause, {\n          ...field.options,\n          form: field.form,\n          validationLogic:\n            field.form.options.validationLogic || defaultValidationLogic,\n        })\n        fieldValidates.forEach((validate) => {\n          ;(validate as any).field = field\n        })\n        return acc.concat(fieldValidates as never)\n      },\n      [] as Array<\n        SyncValidator<any> & {\n          field: AnyFieldApi\n        }\n      >,\n    )\n\n    // Needs type cast as eslint errantly believes this is always falsy\n    let hasErrored = false as boolean\n\n    batch(() => {\n      const validateFieldFn = (\n        field: AnyFieldApi,\n        validateObj: SyncValidator<any>,\n      ) => {\n        const errorMapKey = getErrorMapKey(validateObj.cause)\n\n        const fieldLevelError = validateObj.validate\n          ? normalizeError(\n              field.runValidator({\n                validate: validateObj.validate,\n                value: {\n                  value: field.store.state.value,\n                  validationSource: 'field',\n                  fieldApi: field,\n                },\n                type: 'validate',\n              }),\n            )\n          : undefined\n\n        const formLevelError = errorFromForm[errorMapKey]\n\n        const { newErrorValue, newSource } =\n          determineFieldLevelErrorSourceAndValue({\n            formLevelError,\n            fieldLevelError,\n          })\n\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (field.state.meta.errorMap?.[errorMapKey] !== newErrorValue) {\n          field.setMeta((prev) => ({\n            ...prev,\n            errorMap: {\n              ...prev.errorMap,\n              [errorMapKey]: newErrorValue,\n            },\n            errorSourceMap: {\n              ...prev.errorSourceMap,\n              [errorMapKey]: newSource,\n            },\n          }))\n        }\n        if (newErrorValue) {\n          hasErrored = true\n        }\n      }\n\n      for (const validateObj of validates) {\n        validateFieldFn(this, validateObj)\n      }\n      for (const fieldValitateObj of linkedFieldValidates) {\n        if (!fieldValitateObj.validate) continue\n        validateFieldFn(fieldValitateObj.field, fieldValitateObj)\n      }\n    })\n\n    /**\n     *  when we have an error for onSubmit in the state, we want\n     *  to clear the error as soon as the user enters a valid value in the field\n     */\n    const submitErrKey = getErrorMapKey('submit')\n\n    if (\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      this.state.meta.errorMap?.[submitErrKey] &&\n      cause !== 'submit' &&\n      !hasErrored\n    ) {\n      this.setMeta((prev) => ({\n        ...prev,\n        errorMap: {\n          ...prev.errorMap,\n          [submitErrKey]: undefined,\n        },\n        errorSourceMap: {\n          ...prev.errorSourceMap,\n          [submitErrKey]: undefined,\n        },\n      }))\n    }\n\n    return { hasErrored }\n  }\n\n  /**\n   * @private\n   */\n  validateAsync = async (\n    cause: ValidationCause,\n    formValidationResultPromise: Promise<\n      FieldErrorMapFromValidator<\n        TParentData,\n        TName,\n        TData,\n        TOnMount,\n        TOnChange,\n        TOnChangeAsync,\n        TOnBlur,\n        TOnBlurAsync,\n        TOnSubmit,\n        TOnSubmitAsync\n      >\n    >,\n  ) => {\n    const validates = getAsyncValidatorArray(cause, {\n      ...this.options,\n      form: this.form,\n      validationLogic:\n        this.form.options.validationLogic || defaultValidationLogic,\n    })\n\n    // Get the field-specific error messages that are coming from the form's validator\n    const asyncFormValidationResults = await formValidationResultPromise\n\n    const linkedFields = this.getLinkedFields(cause)\n    const linkedFieldValidates = linkedFields.reduce(\n      (acc, field) => {\n        const fieldValidates = getAsyncValidatorArray(cause, {\n          ...field.options,\n          form: field.form,\n          validationLogic:\n            field.form.options.validationLogic || defaultValidationLogic,\n        })\n        fieldValidates.forEach((validate) => {\n          ;(validate as any).field = field\n        })\n        return acc.concat(fieldValidates as never)\n      },\n      [] as Array<\n        AsyncValidator<any> & {\n          field: AnyFieldApi\n        }\n      >,\n    )\n\n    /**\n     * We have to use a for loop and generate our promises this way, otherwise it won't be sync\n     * when there are no validators needed to be run\n     */\n    const validatesPromises: Promise<ValidationError | undefined>[] = []\n    const linkedPromises: Promise<ValidationError | undefined>[] = []\n\n    // Check if there are actual async validators to run before setting isValidating\n    // This prevents unnecessary re-renders when there are no async validators\n    // See: https://github.com/TanStack/form/issues/1130\n    const hasAsyncValidators =\n      validates.some((v) => v.validate) ||\n      linkedFieldValidates.some((v) => v.validate)\n\n    if (hasAsyncValidators) {\n      if (!this.state.meta.isValidating) {\n        this.setMeta((prev) => ({ ...prev, isValidating: true }))\n      }\n\n      for (const linkedField of linkedFields) {\n        linkedField.setMeta((prev) => ({ ...prev, isValidating: true }))\n      }\n    }\n\n    const validateFieldAsyncFn = (\n      field: AnyFieldApi,\n      validateObj: AsyncValidator<any>,\n      promises: Promise<ValidationError | undefined>[],\n    ) => {\n      const errorMapKey = getErrorMapKey(validateObj.cause)\n      const fieldValidatorMeta = field.getInfo().validationMetaMap[errorMapKey]\n\n      fieldValidatorMeta?.lastAbortController.abort()\n      const controller = new AbortController()\n\n      this.getInfo().validationMetaMap[errorMapKey] = {\n        lastAbortController: controller,\n      }\n\n      promises.push(\n        new Promise<ValidationError | undefined>(async (resolve) => {\n          let rawError!: ValidationError | undefined\n          try {\n            rawError = await new Promise((rawResolve, rawReject) => {\n              if (this.timeoutIds.validations[validateObj.cause]) {\n                clearTimeout(this.timeoutIds.validations[validateObj.cause]!)\n              }\n\n              this.timeoutIds.validations[validateObj.cause] = setTimeout(\n                async () => {\n                  if (controller.signal.aborted) return rawResolve(undefined)\n                  try {\n                    rawResolve(\n                      await this.runValidator({\n                        validate: validateObj.validate,\n                        value: {\n                          value: field.store.state.value,\n                          fieldApi: field,\n                          signal: controller.signal,\n                          validationSource: 'field',\n                        },\n                        type: 'validateAsync',\n                      }),\n                    )\n                  } catch (e) {\n                    rawReject(e)\n                  }\n                },\n                validateObj.debounceMs,\n              )\n            })\n          } catch (e: unknown) {\n            rawError = e as ValidationError\n          }\n          if (controller.signal.aborted) return resolve(undefined)\n\n          const fieldLevelError = normalizeError(rawError)\n          const formLevelError =\n            asyncFormValidationResults[this.name]?.[errorMapKey]\n\n          const { newErrorValue, newSource } =\n            determineFieldLevelErrorSourceAndValue({\n              formLevelError,\n              fieldLevelError,\n            })\n\n          field.setMeta((prev) => {\n            return {\n              ...prev,\n              errorMap: {\n                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n                ...prev?.errorMap,\n                [errorMapKey]: newErrorValue,\n              },\n              errorSourceMap: {\n                ...prev.errorSourceMap,\n                [errorMapKey]: newSource,\n              },\n            }\n          })\n\n          resolve(newErrorValue)\n        }),\n      )\n    }\n\n    // TODO: Dedupe this logic to reduce bundle size\n    for (const validateObj of validates) {\n      if (!validateObj.validate) continue\n      validateFieldAsyncFn(this, validateObj, validatesPromises)\n    }\n    for (const fieldValitateObj of linkedFieldValidates) {\n      if (!fieldValitateObj.validate) continue\n      validateFieldAsyncFn(\n        fieldValitateObj.field,\n        fieldValitateObj,\n        linkedPromises,\n      )\n    }\n\n    let results: ValidationError[] = []\n    if (validatesPromises.length || linkedPromises.length) {\n      results = await Promise.all(validatesPromises)\n      await Promise.all(linkedPromises)\n    }\n\n    // Only reset isValidating if we set it to true earlier\n    if (hasAsyncValidators) {\n      this.setMeta((prev) => ({ ...prev, isValidating: false }))\n\n      for (const linkedField of linkedFields) {\n        linkedField.setMeta((prev) => ({ ...prev, isValidating: false }))\n      }\n    }\n\n    return results.filter(Boolean)\n  }\n\n  /**\n   * Validates the field value.\n   */\n  validate = (\n    cause: ValidationCause,\n    opts?: { skipFormValidation?: boolean },\n  ): ValidationError[] | Promise<ValidationError[]> => {\n    // If the field is pristine, do not validate\n    if (!this.state.meta.isTouched) return []\n\n    // Attempt to sync validate first\n    const { fieldsErrorMap } = opts?.skipFormValidation\n      ? { fieldsErrorMap: {} as never }\n      : this.form.validateSync(cause)\n    const { hasErrored } = this.validateSync(\n      cause,\n      fieldsErrorMap[this.name] ?? {},\n    )\n\n    if (hasErrored && !this.options.asyncAlways) {\n      this.getInfo().validationMetaMap[\n        getErrorMapKey(cause)\n      ]?.lastAbortController.abort()\n      return this.state.meta.errors\n    }\n\n    // No error? Attempt async validation\n    const formValidationResultPromise = opts?.skipFormValidation\n      ? Promise.resolve({})\n      : this.form.validateAsync(cause)\n    return this.validateAsync(cause, formValidationResultPromise)\n  }\n\n  /**\n   * Handles the change event.\n   */\n  handleChange = (updater: Updater<TData>) => {\n    this.setValue(updater)\n  }\n\n  /**\n   * Handles the blur event.\n   */\n  handleBlur = () => {\n    const prevTouched = this.state.meta.isTouched\n    if (!prevTouched) {\n      this.setMeta((prev) => ({ ...prev, isTouched: true }))\n    }\n    if (!this.state.meta.isBlurred) {\n      this.setMeta((prev) => ({ ...prev, isBlurred: true }))\n    }\n    this.validate('blur')\n\n    this.triggerOnBlurListener()\n  }\n\n  /**\n   * Updates the field's errorMap\n   */\n  setErrorMap = (\n    errorMap: ValidationErrorMap<\n      UnwrapFieldValidateOrFn<TName, TOnMount, TFormOnMount>,\n      UnwrapFieldValidateOrFn<TName, TOnChange, TFormOnChange>,\n      UnwrapFieldAsyncValidateOrFn<TName, TOnChangeAsync, TFormOnChangeAsync>,\n      UnwrapFieldValidateOrFn<TName, TOnBlur, TFormOnBlur>,\n      UnwrapFieldAsyncValidateOrFn<TName, TOnBlurAsync, TFormOnBlurAsync>,\n      UnwrapFieldValidateOrFn<TName, TOnSubmit, TFormOnSubmit>,\n      UnwrapFieldAsyncValidateOrFn<TName, TOnSubmitAsync, TFormOnSubmitAsync>,\n      UnwrapFieldValidateOrFn<TName, TOnDynamic, TFormOnDynamic>,\n      UnwrapFieldAsyncValidateOrFn<TName, TOnDynamicAsync, TFormOnDynamicAsync>\n    >,\n  ) => {\n    this.setMeta((prev) => ({\n      ...prev,\n      errorMap: {\n        ...prev.errorMap,\n        ...errorMap,\n      },\n    }))\n  }\n\n  /**\n   * Parses the field's value with the given schema and returns\n   * issues (if any). This method does NOT set any internal errors.\n   * @param schema The standard schema to parse this field's value with.\n   */\n  parseValueWithSchema = (schema: StandardSchemaV1<TData, unknown>) => {\n    return standardSchemaValidators.validate(\n      { value: this.state.value, validationSource: 'field' },\n      schema,\n    )\n  }\n\n  /**\n   * Parses the field's value with the given schema and returns\n   * issues (if any). This method does NOT set any internal errors.\n   * @param schema The standard schema to parse this field's value with.\n   */\n  parseValueWithSchemaAsync = (schema: StandardSchemaV1<TData, unknown>) => {\n    return standardSchemaValidators.validateAsync(\n      { value: this.state.value, validationSource: 'field' },\n      schema,\n    )\n  }\n\n  private triggerOnBlurListener() {\n    const formDebounceMs = this.form.options.listeners?.onBlurDebounceMs\n    if (formDebounceMs && formDebounceMs > 0) {\n      if (this.timeoutIds.formListeners.blur) {\n        clearTimeout(this.timeoutIds.formListeners.blur)\n      }\n\n      this.timeoutIds.formListeners.blur = setTimeout(() => {\n        this.form.options.listeners?.onBlur?.({\n          formApi: this.form,\n          fieldApi: this,\n        })\n      }, formDebounceMs)\n    } else {\n      this.form.options.listeners?.onBlur?.({\n        formApi: this.form,\n        fieldApi: this,\n      })\n    }\n\n    const fieldDebounceMs = this.options.listeners?.onBlurDebounceMs\n    if (fieldDebounceMs && fieldDebounceMs > 0) {\n      if (this.timeoutIds.listeners.blur) {\n        clearTimeout(this.timeoutIds.listeners.blur)\n      }\n\n      this.timeoutIds.listeners.blur = setTimeout(() => {\n        this.options.listeners?.onBlur?.({\n          value: this.state.value,\n          fieldApi: this,\n        })\n      }, fieldDebounceMs)\n    } else {\n      this.options.listeners?.onBlur?.({\n        value: this.state.value,\n        fieldApi: this,\n      })\n    }\n  }\n\n  /**\n   * @private\n   */\n  triggerOnChangeListener = () => {\n    const formDebounceMs = this.form.options.listeners?.onChangeDebounceMs\n    if (formDebounceMs && formDebounceMs > 0) {\n      if (this.timeoutIds.formListeners.change) {\n        clearTimeout(this.timeoutIds.formListeners.change)\n      }\n\n      this.timeoutIds.formListeners.change = setTimeout(() => {\n        this.form.options.listeners?.onChange?.({\n          formApi: this.form,\n          fieldApi: this,\n        })\n      }, formDebounceMs)\n    } else {\n      this.form.options.listeners?.onChange?.({\n        formApi: this.form,\n        fieldApi: this,\n      })\n    }\n\n    const fieldDebounceMs = this.options.listeners?.onChangeDebounceMs\n    if (fieldDebounceMs && fieldDebounceMs > 0) {\n      if (this.timeoutIds.listeners.change) {\n        clearTimeout(this.timeoutIds.listeners.change)\n      }\n\n      this.timeoutIds.listeners.change = setTimeout(() => {\n        this.options.listeners?.onChange?.({\n          value: this.state.value,\n          fieldApi: this,\n        })\n      }, fieldDebounceMs)\n    } else {\n      this.options.listeners?.onChange?.({\n        value: this.state.value,\n        fieldApi: this,\n      })\n    }\n  }\n}\n\nfunction normalizeError(rawError?: ValidationError) {\n  if (rawError) {\n    return rawError\n  }\n\n  return undefined\n}\n\nfunction getErrorMapKey(cause: ValidationCause) {\n  switch (cause) {\n    case 'submit':\n      return 'onSubmit'\n    case 'blur':\n      return 'onBlur'\n    case 'mount':\n      return 'onMount'\n    case 'server':\n      return 'onServer'\n    case 'dynamic':\n      return 'onDynamic'\n    case 'change':\n    default:\n      return 'onChange'\n  }\n}\n"],"names":["opts","evaluate","mergeOpts","getSyncValidatorArray","defaultValidationLogic","batch","determineFieldLevelErrorSourceAndValue","getAsyncValidatorArray","standardSchemaValidators","Derived","defaultFieldMeta","isStandardSchemaValidator"],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/cjs/FormApi.cjs b/dist/cjs/FormApi.cjs
index d2ae3eb395faac411ed70bd79cd4c22c930d96fd..979b3a71ea0112e7a138adfc7bf532a861e2c7a4 100644
--- a/dist/cjs/FormApi.cjs
+++ b/dist/cjs/FormApi.cjs
@@ -37,44 +37,7 @@ class FormApi {
     this.mount = () => {
       const cleanupFieldMetaDerived = this.fieldMetaDerived.mount();
       const cleanupStoreDerived = this.store.mount();
-      const cleanupDevtoolBroadcast = this.store.subscribe(() => {
-        utils.throttleFormState(this);
-      });
-      const cleanupFormStateListener = EventClient.formEventClient.on(
-        "request-form-state",
-        (e) => {
-          if (e.payload.id === this._formId) {
-            EventClient.formEventClient.emit("form-api", {
-              id: this._formId,
-              state: this.store.state,
-              options: this.options
-            });
-          }
-        }
-      );
-      const cleanupFormResetListener = EventClient.formEventClient.on(
-        "request-form-reset",
-        (e) => {
-          if (e.payload.id === this._formId) {
-            this.reset();
-          }
-        }
-      );
-      const cleanupFormForceSubmitListener = EventClient.formEventClient.on(
-        "request-form-force-submit",
-        (e) => {
-          if (e.payload.id === this._formId) {
-            this._devtoolsSubmissionOverride = true;
-            this.handleSubmit();
-            this._devtoolsSubmissionOverride = false;
-          }
-        }
-      );
       const cleanup = () => {
-        cleanupFormForceSubmitListener();
-        cleanupFormResetListener();
-        cleanupFormStateListener();
-        cleanupDevtoolBroadcast();
         cleanupFieldMetaDerived();
         cleanupStoreDerived();
         EventClient.formEventClient.emit("form-unmounted", {
@@ -213,15 +176,14 @@ class FormApi {
           });
           const { formError, fieldErrors } = normalizeError(rawError);
           const errorMapKey = getErrorMapKey(validateObj.cause);
-          const allFieldsToProcess = /* @__PURE__ */ new Set([
-            ...Object.keys(this.state.fieldMeta),
-            ...Object.keys(fieldErrors || {})
-          ]);
-          for (const field of allFieldsToProcess) {
-            if (this.baseStore.state.fieldMetaBase[field] === void 0 && !fieldErrors?.[field]) {
+          for (const field of Object.keys(
+            this.state.fieldMeta
+          )) {
+            if (this.baseStore.state.fieldMetaBase[field] === void 0) {
               continue;
             }
-            const fieldMeta = this.getFieldMeta(field) ?? metaHelper.defaultFieldMeta;
+            const fieldMeta = this.getFieldMeta(field);
+            if (!fieldMeta) continue;
             const {
               errorMap: currentErrorMap,
               errorSourceMap: currentErrorMapSource
@@ -229,8 +191,12 @@ class FormApi {
             const newFormValidatorError = fieldErrors?.[field];
             const { newErrorValue, newSource } = utils.determineFormLevelErrorSourceAndValue({
               newFormValidatorError,
-              isPreviousErrorFromFormValidator: currentErrorMapSource[errorMapKey] === "form",
-              previousErrorValue: currentErrorMap[errorMapKey]
+              isPreviousErrorFromFormValidator: (
+                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
+                currentErrorMapSource?.[errorMapKey] === "form"
+              ),
+              // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
+              previousErrorValue: currentErrorMap?.[errorMapKey]
             });
             if (newSource === "form") {
               currentValidationErrorMap[field] = {
@@ -238,8 +204,11 @@ class FormApi {
                 [errorMapKey]: newFormValidatorError
               };
             }
-            if (currentErrorMap[errorMapKey] !== newErrorValue) {
-              this.setFieldMeta(field, (prev = metaHelper.defaultFieldMeta) => ({
+            if (
+              // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
+              currentErrorMap?.[errorMapKey] !== newErrorValue
+            ) {
+              this.setFieldMeta(field, (prev) => ({
                 ...prev,
                 errorMap: {
                   ...prev.errorMap,
@@ -278,6 +247,28 @@ class FormApi {
             }
           }));
         }
+        if (cause !== "submit" && !hasErrored) {
+          for (const field of Object.keys(
+            this.state.fieldMeta
+          )) {
+            const fieldMeta = this.getFieldMeta(field);
+            if (fieldMeta && // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
+            fieldMeta.errorMap?.[submitErrKey] !== void 0 && // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
+            fieldMeta.errorSourceMap?.[submitErrKey] === "form") {
+              this.setFieldMeta(field, (prev) => ({
+                ...prev,
+                errorMap: {
+                  ...prev.errorMap,
+                  [submitErrKey]: void 0
+                },
+                errorSourceMap: {
+                  ...prev.errorSourceMap,
+                  [submitErrKey]: void 0
+                }
+              }));
+            }
+          }
+        }
         const serverErrKey = getErrorMapKey("server");
         if (
           // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
@@ -291,6 +282,28 @@ class FormApi {
             }
           }));
         }
+        if (cause !== "server" && !hasErrored) {
+          for (const field of Object.keys(
+            this.state.fieldMeta
+          )) {
+            const fieldMeta = this.getFieldMeta(field);
+            if (fieldMeta && // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
+            fieldMeta.errorMap?.[serverErrKey] !== void 0 && // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
+            fieldMeta.errorSourceMap?.[serverErrKey] === "form") {
+              this.setFieldMeta(field, (prev) => ({
+                ...prev,
+                errorMap: {
+                  ...prev.errorMap,
+                  [serverErrKey]: void 0
+                },
+                errorSourceMap: {
+                  ...prev.errorSourceMap,
+                  [serverErrKey]: void 0
+                }
+              }));
+            }
+          }
+        }
       });
       return { hasErrored, fieldsErrorMap: currentValidationErrorMap };
     };
@@ -1000,6 +1013,30 @@ class FormApi {
     });
     this.handleSubmit = this.handleSubmit.bind(this);
     this.update(opts || {});
+    this.store.subscribe(() => {
+      utils.throttleFormState(this);
+    });
+    EventClient.formEventClient.on("request-form-state", (e) => {
+      if (e.payload.id === this._formId) {
+        EventClient.formEventClient.emit("form-api", {
+          id: this._formId,
+          state: this.store.state,
+          options: this.options
+        });
+      }
+    });
+    EventClient.formEventClient.on("request-form-reset", (e) => {
+      if (e.payload.id === this._formId) {
+        this.reset();
+      }
+    });
+    EventClient.formEventClient.on("request-form-force-submit", (e) => {
+      if (e.payload.id === this._formId) {
+        this._devtoolsSubmissionOverride = true;
+        this.handleSubmit();
+        this._devtoolsSubmissionOverride = false;
+      }
+    });
   }
   get state() {
     return this.store.state;
diff --git a/dist/cjs/FormApi.cjs.map b/dist/cjs/FormApi.cjs.map
index 3de97511cf4d2b46deb3a25f194422fa180efa4c..aebe73a3e1586cc7b1f3279d61c5c31d0e805171 100644
--- a/dist/cjs/FormApi.cjs.map
+++ b/dist/cjs/FormApi.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"FormApi.cjs","sources":["../../src/FormApi.ts"],"sourcesContent":["import { Derived, Store, batch } from '@tanstack/store'\nimport {\n  deleteBy,\n  determineFormLevelErrorSourceAndValue,\n  evaluate,\n  functionalUpdate,\n  getAsyncValidatorArray,\n  getBy,\n  getSyncValidatorArray,\n  isGlobalFormValidationError,\n  isNonEmptyArray,\n  mergeOpts,\n  setBy,\n  throttleFormState,\n  uuid,\n} from './utils'\nimport { defaultValidationLogic } from './ValidationLogic'\nimport {\n  isStandardSchemaValidator,\n  standardSchemaValidators,\n} from './standardSchemaValidator'\nimport { defaultFieldMeta, metaHelper } from './metaHelper'\nimport { formEventClient } from './EventClient'\n\n// types\nimport type { ValidationLogicFn } from './ValidationLogic'\nimport type {\n  StandardSchemaV1,\n  StandardSchemaV1Issue,\n  TStandardSchemaValidatorValue,\n} from './standardSchemaValidator'\nimport type {\n  AnyFieldApi,\n  AnyFieldMeta,\n  AnyFieldMetaBase,\n  FieldApi,\n} from './FieldApi'\nimport type {\n  ExtractGlobalFormError,\n  FieldManipulator,\n  FormValidationError,\n  FormValidationErrorMap,\n  ListenerCause,\n  UpdateMetaOptions,\n  ValidationCause,\n  ValidationError,\n  ValidationErrorMap,\n  ValidationErrorMapKeys,\n} from './types'\nimport type { DeepKeys, DeepKeysOfType, DeepValue } from './util-types'\nimport type { Updater } from './utils'\n\n/**\n * @private\n */\n// TODO: Add the `Unwrap` type to the errors\ntype FormErrorMapFromValidator<\n  TFormData,\n  TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnDynamic extends undefined | FormValidateOrFn<TFormData>,\n  TOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n> = Partial<\n  Record<\n    DeepKeys<TFormData>,\n    ValidationErrorMap<\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync\n    >\n  >\n>\n\nexport type FormValidateFn<TFormData> = (props: {\n  value: TFormData\n  formApi: FormApi<\n    TFormData,\n    // This is technically an edge-type; which we try to keep non-`any`, but in this case\n    // It's referring to an inaccessible type from the field validate function inner types, so it's not a big deal\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any\n  >\n}) => unknown\n\n/**\n * @private\n */\nexport type FormValidateOrFn<TFormData> =\n  | FormValidateFn<TFormData>\n  | StandardSchemaV1<TFormData, unknown>\n\nexport type UnwrapFormValidateOrFn<\n  TValidateOrFn extends undefined | FormValidateOrFn<any>,\n> = [TValidateOrFn] extends [FormValidateFn<any>]\n  ? ExtractGlobalFormError<ReturnType<TValidateOrFn>>\n  : [TValidateOrFn] extends [StandardSchemaV1<any, any>]\n    ? Record<string, StandardSchemaV1Issue[]>\n    : undefined\n\n/**\n * @private\n */\nexport type FormValidateAsyncFn<TFormData> = (props: {\n  value: TFormData\n  formApi: FormApi<\n    TFormData,\n    // This is technically an edge-type; which we try to keep non-`any`, but in this case\n    // It's referring to an inaccessible type from the field validate function inner types, so it's not a big deal\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any\n  >\n  signal: AbortSignal\n}) => unknown | Promise<unknown>\n\nexport type FormValidator<TFormData, TType, TFn = unknown> = {\n  validate(options: { value: TType }, fn: TFn): ValidationError\n  validateAsync(\n    options: { value: TType },\n    fn: TFn,\n  ): Promise<FormValidationError<TFormData>>\n}\n\ntype ValidationPromiseResult<TFormData> =\n  | {\n      fieldErrors: Partial<Record<DeepKeys<TFormData>, ValidationError>>\n      errorMapKey: ValidationErrorMapKeys\n    }\n  | undefined\n\n/**\n * @private\n */\nexport type FormAsyncValidateOrFn<TFormData> =\n  | FormValidateAsyncFn<TFormData>\n  | StandardSchemaV1<TFormData, unknown>\n\nexport type UnwrapFormAsyncValidateOrFn<\n  TValidateOrFn extends undefined | FormAsyncValidateOrFn<any>,\n> = [TValidateOrFn] extends [FormValidateAsyncFn<any>]\n  ? ExtractGlobalFormError<Awaited<ReturnType<TValidateOrFn>>>\n  : [TValidateOrFn] extends [StandardSchemaV1<any, any>]\n    ? Record<string, StandardSchemaV1Issue[]>\n    : undefined\n\nexport interface FormValidators<\n  TFormData,\n  TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnDynamic extends undefined | FormValidateOrFn<TFormData>,\n  TOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n> {\n  /**\n   * Optional function that fires as soon as the component mounts.\n   */\n  onMount?: TOnMount\n  /**\n   * Optional function that checks the validity of your data whenever a value changes\n   */\n  onChange?: TOnChange\n  /**\n   * Optional onChange asynchronous counterpart to onChange. Useful for more complex validation logic that might involve server requests.\n   */\n  onChangeAsync?: TOnChangeAsync\n  /**\n   * The default time in milliseconds that if set to a number larger than 0, will debounce the async validation event by this length of time in milliseconds.\n   */\n  onChangeAsyncDebounceMs?: number\n  /**\n   * Optional function that validates the form data when a field loses focus, returns a `FormValidationError`\n   */\n  onBlur?: TOnBlur\n  /**\n   * Optional onBlur asynchronous validation method for when a field loses focus returns a ` FormValidationError` or a promise of `Promise<FormValidationError>`\n   */\n  onBlurAsync?: TOnBlurAsync\n  /**\n   * The default time in milliseconds that if set to a number larger than 0, will debounce the async validation event by this length of time in milliseconds.\n   */\n  onBlurAsyncDebounceMs?: number\n  onSubmit?: TOnSubmit\n  onSubmitAsync?: TOnSubmitAsync\n  onDynamic?: TOnDynamic\n  onDynamicAsync?: TOnDynamicAsync\n  onDynamicAsyncDebounceMs?: number\n}\n\n/**\n * @private\n */\nexport interface FormTransform<\n  TFormData,\n  TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnDynamic extends undefined | FormValidateOrFn<TFormData>,\n  TOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnServer extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TSubmitMeta = never,\n> {\n  fn: (\n    formBase: FormApi<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer,\n      TSubmitMeta\n    >,\n  ) => FormApi<\n    TFormData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TOnDynamic,\n    TOnDynamicAsync,\n    TOnServer,\n    TSubmitMeta\n  >\n  deps: unknown[]\n}\n\nexport interface FormListeners<\n  TFormData,\n  TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnDynamic extends undefined | FormValidateOrFn<TFormData>,\n  TOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnServer extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TSubmitMeta = never,\n> {\n  onChange?: (props: {\n    formApi: FormApi<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer,\n      TSubmitMeta\n    >\n    fieldApi: AnyFieldApi\n  }) => void\n  onChangeDebounceMs?: number\n\n  onBlur?: (props: {\n    formApi: FormApi<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer,\n      TSubmitMeta\n    >\n    fieldApi: AnyFieldApi\n  }) => void\n  onBlurDebounceMs?: number\n\n  onMount?: (props: {\n    formApi: FormApi<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer,\n      TSubmitMeta\n    >\n  }) => void\n\n  onSubmit?: (props: {\n    formApi: FormApi<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer,\n      TSubmitMeta\n    >\n    meta: TSubmitMeta\n  }) => void\n}\n\n/**\n * An object representing the base properties of a form, unrelated to any validators\n */\nexport interface BaseFormOptions<in out TFormData, in out TSubmitMeta = never> {\n  /**\n   * Set initial values for your form.\n   */\n  defaultValues?: TFormData\n  /**\n   * onSubmitMeta, the data passed from the handleSubmit handler, to the onSubmit function props\n   */\n  onSubmitMeta?: TSubmitMeta\n}\n\n/**\n * An object representing the options for a form.\n */\nexport interface FormOptions<\n  in out TFormData,\n  in out TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnDynamic extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnServer extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TSubmitMeta = never,\n> extends BaseFormOptions<TFormData, TSubmitMeta> {\n  /**\n   * The form name, used for devtools and identification\n   */\n  formId?: string\n  /**\n   * The default state for the form.\n   */\n  defaultState?: Partial<\n    FormState<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer\n    >\n  >\n  /**\n   * If true, always run async validation, even when sync validation has produced an error. Defaults to undefined.\n   */\n  asyncAlways?: boolean\n  /**\n   * Optional time in milliseconds if you want to introduce a delay before firing off an async action.\n   */\n  asyncDebounceMs?: number\n  /**\n   * If true, allows the form to be submitted in an invalid state i.e. canSubmit will remain true regardless of validation errors. Defaults to undefined.\n   */\n  canSubmitWhenInvalid?: boolean\n  /**\n   * A list of validators to pass to the form\n   */\n  validators?: FormValidators<\n    TFormData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TOnDynamic,\n    TOnDynamicAsync\n  >\n\n  validationLogic?: ValidationLogicFn\n\n  /**\n   * form level listeners\n   */\n  listeners?: FormListeners<\n    TFormData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TOnDynamic,\n    TOnDynamicAsync,\n    TOnServer,\n    TSubmitMeta\n  >\n\n  /**\n   * A function to be called when the form is submitted, what should happen once the user submits a valid form returns `any` or a promise `Promise<any>`\n   */\n  onSubmit?: (props: {\n    value: TFormData\n    formApi: FormApi<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer,\n      TSubmitMeta\n    >\n    meta: TSubmitMeta\n  }) => any | Promise<any>\n  /**\n   * Specify an action for scenarios where the user tries to submit an invalid form.\n   */\n  onSubmitInvalid?: (props: {\n    value: TFormData\n    formApi: FormApi<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer,\n      TSubmitMeta\n    >\n    meta: TSubmitMeta\n  }) => void\n  transform?: FormTransform<\n    NoInfer<TFormData>,\n    NoInfer<TOnMount>,\n    NoInfer<TOnChange>,\n    NoInfer<TOnChangeAsync>,\n    NoInfer<TOnBlur>,\n    NoInfer<TOnBlurAsync>,\n    NoInfer<TOnSubmit>,\n    NoInfer<TOnSubmitAsync>,\n    NoInfer<TOnDynamic>,\n    NoInfer<TOnDynamicAsync>,\n    NoInfer<TOnServer>,\n    NoInfer<TSubmitMeta>\n  >\n}\n\nexport type AnyFormOptions = FormOptions<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any\n>\n\n/**\n * An object representing the validation metadata for a field. Not intended for public usage.\n */\nexport type ValidationMeta = {\n  /**\n   * An abort controller stored in memory to cancel previous async validation attempts.\n   */\n  lastAbortController: AbortController\n}\n\n/**\n * An object representing the field information for a specific field within the form.\n */\nexport type FieldInfo<TFormData> = {\n  /**\n   * An instance of the FieldAPI.\n   */\n  instance: FieldApi<\n    TFormData,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any\n  > | null\n  /**\n   * A record of field validation internal handling.\n   */\n  validationMetaMap: Record<ValidationErrorMapKeys, ValidationMeta | undefined>\n}\n\n/**\n * An object representing the current state of the form.\n */\nexport type BaseFormState<\n  in out TFormData,\n  in out TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnDynamic extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnServer extends undefined | FormAsyncValidateOrFn<TFormData>,\n> = {\n  /**\n   * The current values of the form fields.\n   */\n  values: TFormData\n  /**\n   * The error map for the form itself.\n   */\n  errorMap: ValidationErrorMap<\n    UnwrapFormValidateOrFn<TOnMount>,\n    UnwrapFormValidateOrFn<TOnChange>,\n    UnwrapFormAsyncValidateOrFn<TOnChangeAsync>,\n    UnwrapFormValidateOrFn<TOnBlur>,\n    UnwrapFormAsyncValidateOrFn<TOnBlurAsync>,\n    UnwrapFormValidateOrFn<TOnSubmit>,\n    UnwrapFormAsyncValidateOrFn<TOnSubmitAsync>,\n    UnwrapFormValidateOrFn<TOnDynamic>,\n    UnwrapFormAsyncValidateOrFn<TOnDynamicAsync>,\n    UnwrapFormAsyncValidateOrFn<TOnServer>\n  >\n  /**\n   * An internal mechanism used for keeping track of validation logic in a form.\n   */\n  validationMetaMap: Record<ValidationErrorMapKeys, ValidationMeta | undefined>\n  /**\n   * A record of field metadata for each field in the form, not including the derived properties, like `errors` and such\n   */\n  fieldMetaBase: Partial<Record<DeepKeys<TFormData>, AnyFieldMetaBase>>\n  /**\n   * A boolean indicating if the form is currently in the process of being submitted after `handleSubmit` is called.\n   *\n   * Goes back to `false` when submission completes for one of the following reasons:\n   * - the validation step returned errors.\n   * - the `onSubmit` function has completed.\n   *\n   * Note: if you're running async operations in your `onSubmit` function make sure to await them to ensure `isSubmitting` is set to `false` only when the async operation completes.\n   *\n   * This is useful for displaying loading indicators or disabling form inputs during submission.\n   *\n   */\n  isSubmitting: boolean\n  /**\n   * A boolean indicating if the `onSubmit` function has completed successfully.\n   *\n   * Goes back to `false` at each new submission attempt.\n   *\n   * Note: you can use isSubmitting to check if the form is currently submitting.\n   */\n  isSubmitted: boolean\n  /**\n   * A boolean indicating if the form or any of its fields are currently validating.\n   */\n  isValidating: boolean\n  /**\n   * A counter for tracking the number of submission attempts.\n   */\n  submissionAttempts: number\n  /**\n   * A boolean indicating if the last submission was successful.\n   */\n  isSubmitSuccessful: boolean\n  /**\n   * @private, used to force a re-evaluation of the form state when options change\n   */\n  _force_re_eval?: boolean\n}\n\nexport type DerivedFormState<\n  in out TFormData,\n  in out TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnDynamic extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnServer extends undefined | FormAsyncValidateOrFn<TFormData>,\n> = {\n  /**\n   * A boolean indicating if the form is currently validating.\n   */\n  isFormValidating: boolean\n  /**\n   * A boolean indicating if the form is valid.\n   */\n  isFormValid: boolean\n  /**\n   * The error array for the form itself.\n   */\n  errors: Array<\n    | UnwrapFormValidateOrFn<TOnMount>\n    | UnwrapFormValidateOrFn<TOnChange>\n    | UnwrapFormAsyncValidateOrFn<TOnChangeAsync>\n    | UnwrapFormValidateOrFn<TOnBlur>\n    | UnwrapFormAsyncValidateOrFn<TOnBlurAsync>\n    | UnwrapFormValidateOrFn<TOnSubmit>\n    | UnwrapFormAsyncValidateOrFn<TOnSubmitAsync>\n    | UnwrapFormValidateOrFn<TOnDynamic>\n    | UnwrapFormAsyncValidateOrFn<TOnDynamicAsync>\n    | UnwrapFormAsyncValidateOrFn<TOnServer>\n  >\n  /**\n   * A boolean indicating if any of the form fields are currently validating.\n   */\n  isFieldsValidating: boolean\n  /**\n   * A boolean indicating if all the form fields are valid. Evaluates `true` if there are no field errors.\n   */\n  isFieldsValid: boolean\n  /**\n   * A boolean indicating if any of the form fields have been touched.\n   */\n  isTouched: boolean\n  /**\n   * A boolean indicating if any of the form fields have been blurred.\n   */\n  isBlurred: boolean\n  /**\n   * A boolean indicating if any of the form's fields' values have been modified by the user. Evaluates `true` if the user have modified at least one of the fields. Opposite of `isPristine`.\n   */\n  isDirty: boolean\n  /**\n   * A boolean indicating if none of the form's fields' values have been modified by the user. Evaluates `true` if the user have not modified any of the fields. Opposite of `isDirty`.\n   */\n  isPristine: boolean\n  /**\n   * A boolean indicating if all of the form's fields are the same as default values.\n   */\n  isDefaultValue: boolean\n  /**\n   * A boolean indicating if the form and all its fields are valid. Evaluates `true` if there are no errors.\n   */\n  isValid: boolean\n  /**\n   * A boolean indicating if the form can be submitted based on its current state.\n   */\n  canSubmit: boolean\n  /**\n   * A record of field metadata for each field in the form.\n   */\n  fieldMeta: Partial<Record<DeepKeys<TFormData>, AnyFieldMeta>>\n}\n\nexport interface FormState<\n  in out TFormData,\n  in out TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnDynamic extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnServer extends undefined | FormAsyncValidateOrFn<TFormData>,\n>\n  extends\n    BaseFormState<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer\n    >,\n    DerivedFormState<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer\n    > {}\n\nexport type AnyFormState = FormState<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any\n>\n\nfunction getDefaultFormState<\n  TFormData,\n  TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnDynamic extends undefined | FormValidateOrFn<TFormData>,\n  TOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnServer extends undefined | FormAsyncValidateOrFn<TFormData>,\n>(\n  defaultState: Partial<\n    FormState<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer\n    >\n  >,\n): BaseFormState<\n  TFormData,\n  TOnMount,\n  TOnChange,\n  TOnChangeAsync,\n  TOnBlur,\n  TOnBlurAsync,\n  TOnSubmit,\n  TOnSubmitAsync,\n  TOnDynamic,\n  TOnDynamicAsync,\n  TOnServer\n> {\n  return {\n    values: defaultState.values ?? ({} as never),\n    errorMap: defaultState.errorMap ?? {},\n    fieldMetaBase: defaultState.fieldMetaBase ?? ({} as never),\n    isSubmitted: defaultState.isSubmitted ?? false,\n    isSubmitting: defaultState.isSubmitting ?? false,\n    isValidating: defaultState.isValidating ?? false,\n    submissionAttempts: defaultState.submissionAttempts ?? 0,\n    isSubmitSuccessful: defaultState.isSubmitSuccessful ?? false,\n    validationMetaMap: defaultState.validationMetaMap ?? {\n      onChange: undefined,\n      onBlur: undefined,\n      onSubmit: undefined,\n      onMount: undefined,\n      onServer: undefined,\n      onDynamic: undefined,\n    },\n  }\n}\n\n/**\n * @public\n *\n * A type representing the Form API with all generics set to `any` for convenience.\n */\nexport type AnyFormApi = FormApi<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any\n>\n\n/**\n * We cannot use methods and must use arrow functions. Otherwise, our React adapters\n * will break due to loss of the method when using spread.\n */\n\n/**\n * A class representing the Form API. It handles the logic and interactions with the form state.\n *\n * Normally, you will not need to create a new `FormApi` instance directly. Instead, you will use a framework\n * hook/function like `useForm` or `createForm` to create a new instance for you that uses your framework's reactivity model.\n * However, if you need to create a new instance manually, you can do so by calling the `new FormApi` constructor.\n */\nexport class FormApi<\n  in out TFormData,\n  in out TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnDynamic extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnServer extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TSubmitMeta = never,\n> implements FieldManipulator<TFormData, TSubmitMeta> {\n  /**\n   * The options for the form.\n   */\n  options: FormOptions<\n    TFormData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TOnDynamic,\n    TOnDynamicAsync,\n    TOnServer,\n    TSubmitMeta\n  > = {}\n  baseStore!: Store<\n    BaseFormState<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer\n    >\n  >\n  fieldMetaDerived: Derived<\n    FormState<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer\n    >['fieldMeta']\n  >\n  store: Derived<\n    FormState<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer\n    >\n  >\n  /**\n   * A record of field information for each field in the form.\n   */\n  fieldInfo: Record<DeepKeys<TFormData>, FieldInfo<TFormData>> = {} as any\n\n  get state() {\n    return this.store.state\n  }\n\n  /**\n   * @private\n   */\n  prevTransformArray: unknown[] = []\n\n  /**\n   * @private\n   */\n  timeoutIds: {\n    validations: Record<ValidationCause, ReturnType<typeof setTimeout> | null>\n    listeners: Record<ListenerCause, ReturnType<typeof setTimeout> | null>\n    formListeners: Record<ListenerCause, ReturnType<typeof setTimeout> | null>\n  }\n  /**\n   * @private\n   */\n  _formId: string\n  /**\n   * @private\n   */\n  private _devtoolsSubmissionOverride: boolean\n\n  /**\n   * Constructs a new `FormApi` instance with the given form options.\n   */\n  constructor(\n    opts?: FormOptions<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer,\n      TSubmitMeta\n    >,\n  ) {\n    this.timeoutIds = {\n      validations: {} as Record<ValidationCause, never>,\n      listeners: {} as Record<ListenerCause, never>,\n      formListeners: {} as Record<ListenerCause, never>,\n    }\n\n    this._formId = opts?.formId ?? uuid()\n\n    this._devtoolsSubmissionOverride = false\n\n    this.baseStore = new Store(\n      getDefaultFormState({\n        ...(opts?.defaultState as any),\n        values: opts?.defaultValues ?? opts?.defaultState?.values,\n        isFormValid: true,\n      }),\n    )\n\n    this.fieldMetaDerived = new Derived({\n      deps: [this.baseStore],\n      fn: ({ prevDepVals, currDepVals, prevVal: _prevVal }) => {\n        const prevVal = _prevVal as\n          | Record<DeepKeys<TFormData>, AnyFieldMeta>\n          | undefined\n        const prevBaseStore = prevDepVals?.[0]\n        const currBaseStore = currDepVals[0]\n\n        let originalMetaCount = 0\n\n        const fieldMeta: FormState<\n          TFormData,\n          TOnMount,\n          TOnChange,\n          TOnChangeAsync,\n          TOnBlur,\n          TOnBlurAsync,\n          TOnSubmit,\n          TOnSubmitAsync,\n          TOnDynamic,\n          TOnDynamicAsync,\n          TOnServer\n        >['fieldMeta'] = {}\n\n        for (const fieldName of Object.keys(\n          currBaseStore.fieldMetaBase,\n        ) as Array<keyof typeof currBaseStore.fieldMetaBase>) {\n          const currBaseMeta = currBaseStore.fieldMetaBase[\n            fieldName as never\n          ] as AnyFieldMetaBase\n\n          const prevBaseMeta = prevBaseStore?.fieldMetaBase[\n            fieldName as never\n          ] as AnyFieldMetaBase | undefined\n\n          const prevFieldInfo =\n            prevVal?.[fieldName as never as keyof typeof prevVal]\n\n          const curFieldVal = getBy(currBaseStore.values, fieldName)\n\n          let fieldErrors = prevFieldInfo?.errors\n          if (\n            !prevBaseMeta ||\n            currBaseMeta.errorMap !== prevBaseMeta.errorMap\n          ) {\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            fieldErrors = Object.values(currBaseMeta.errorMap ?? {}).filter(\n              (val) => val !== undefined,\n            )\n\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            const fieldInstance = this.getFieldInfo(fieldName)?.instance\n\n            if (fieldInstance && !fieldInstance.options.disableErrorFlat) {\n              fieldErrors = fieldErrors.flat(1)\n            }\n          }\n\n          // As primitives, we don't need to aggressively persist the same referential value for performance reasons\n          const isFieldValid = !isNonEmptyArray(fieldErrors)\n          const isFieldPristine = !currBaseMeta.isDirty\n          const isDefaultValue =\n            evaluate(\n              curFieldVal,\n              getBy(this.options.defaultValues, fieldName),\n            ) ||\n            evaluate(\n              curFieldVal,\n              // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n              this.getFieldInfo(fieldName)?.instance?.options.defaultValue,\n            )\n\n          if (\n            prevFieldInfo &&\n            prevFieldInfo.isPristine === isFieldPristine &&\n            prevFieldInfo.isValid === isFieldValid &&\n            prevFieldInfo.isDefaultValue === isDefaultValue &&\n            prevFieldInfo.errors === fieldErrors &&\n            currBaseMeta === prevBaseMeta\n          ) {\n            fieldMeta[fieldName] = prevFieldInfo\n            originalMetaCount++\n            continue\n          }\n\n          fieldMeta[fieldName] = {\n            ...currBaseMeta,\n            errors: fieldErrors ?? [],\n            isPristine: isFieldPristine,\n            isValid: isFieldValid,\n            isDefaultValue: isDefaultValue,\n          } satisfies AnyFieldMeta as AnyFieldMeta\n        }\n\n        if (!Object.keys(currBaseStore.fieldMetaBase).length) return fieldMeta\n\n        if (\n          prevVal &&\n          originalMetaCount === Object.keys(currBaseStore.fieldMetaBase).length\n        ) {\n          return prevVal\n        }\n\n        return fieldMeta\n      },\n    })\n\n    this.store = new Derived({\n      deps: [this.baseStore, this.fieldMetaDerived],\n      fn: ({ prevDepVals, currDepVals, prevVal: _prevVal }) => {\n        const prevVal = _prevVal as\n          | FormState<\n              TFormData,\n              TOnMount,\n              TOnChange,\n              TOnChangeAsync,\n              TOnBlur,\n              TOnBlurAsync,\n              TOnSubmit,\n              TOnSubmitAsync,\n              TOnDynamic,\n              TOnDynamicAsync,\n              TOnServer\n            >\n          | undefined\n        const prevBaseStore = prevDepVals?.[0]\n        const currBaseStore = currDepVals[0]\n        const currFieldMeta = currDepVals[1]\n\n        // Computed state\n        const fieldMetaValues = Object.values(currFieldMeta).filter(\n          Boolean,\n        ) as AnyFieldMeta[]\n\n        const isFieldsValidating = fieldMetaValues.some(\n          (field) => field.isValidating,\n        )\n\n        const isFieldsValid = fieldMetaValues.every((field) => field.isValid)\n\n        const isTouched = fieldMetaValues.some((field) => field.isTouched)\n        const isBlurred = fieldMetaValues.some((field) => field.isBlurred)\n        const isDefaultValue = fieldMetaValues.every(\n          (field) => field.isDefaultValue,\n        )\n\n        const shouldInvalidateOnMount =\n          // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n          isTouched && currBaseStore.errorMap?.onMount\n\n        const isDirty = fieldMetaValues.some((field) => field.isDirty)\n        const isPristine = !isDirty\n\n        const hasOnMountError = Boolean(\n          // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n          currBaseStore.errorMap?.onMount ||\n          // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n          fieldMetaValues.some((f) => f?.errorMap?.onMount),\n        )\n\n        const isValidating = !!isFieldsValidating\n\n        // As `errors` is not a primitive, we need to aggressively persist the same referencial value for performance reasons\n        let errors = prevVal?.errors ?? []\n        if (\n          !prevBaseStore ||\n          currBaseStore.errorMap !== prevBaseStore.errorMap\n        ) {\n          errors = Object.values(currBaseStore.errorMap).reduce<\n            Array<\n              | UnwrapFormValidateOrFn<TOnMount>\n              | UnwrapFormValidateOrFn<TOnChange>\n              | UnwrapFormAsyncValidateOrFn<TOnChangeAsync>\n              | UnwrapFormValidateOrFn<TOnBlur>\n              | UnwrapFormAsyncValidateOrFn<TOnBlurAsync>\n              | UnwrapFormValidateOrFn<TOnSubmit>\n              | UnwrapFormAsyncValidateOrFn<TOnSubmitAsync>\n              | UnwrapFormAsyncValidateOrFn<TOnServer>\n            >\n          >((prev, curr) => {\n            if (curr === undefined) return prev\n\n            if (curr && isGlobalFormValidationError(curr)) {\n              prev.push(curr.form as never)\n              return prev\n            }\n            prev.push(curr as never)\n            return prev\n          }, [])\n        }\n\n        const isFormValid = errors.length === 0\n        const isValid = isFieldsValid && isFormValid\n        const submitInvalid = this.options.canSubmitWhenInvalid ?? false\n        const canSubmit =\n          (currBaseStore.submissionAttempts === 0 &&\n            !isTouched &&\n            !hasOnMountError) ||\n          (!isValidating && !currBaseStore.isSubmitting && isValid) ||\n          submitInvalid\n\n        let errorMap = currBaseStore.errorMap\n        if (shouldInvalidateOnMount) {\n          errors = errors.filter(\n            (err) => err !== currBaseStore.errorMap.onMount,\n          )\n          errorMap = Object.assign(errorMap, { onMount: undefined })\n        }\n\n        if (\n          prevVal &&\n          prevBaseStore &&\n          prevVal.errorMap === errorMap &&\n          prevVal.fieldMeta === this.fieldMetaDerived.state &&\n          prevVal.errors === errors &&\n          prevVal.isFieldsValidating === isFieldsValidating &&\n          prevVal.isFieldsValid === isFieldsValid &&\n          prevVal.isFormValid === isFormValid &&\n          prevVal.isValid === isValid &&\n          prevVal.canSubmit === canSubmit &&\n          prevVal.isTouched === isTouched &&\n          prevVal.isBlurred === isBlurred &&\n          prevVal.isPristine === isPristine &&\n          prevVal.isDefaultValue === isDefaultValue &&\n          prevVal.isDirty === isDirty &&\n          evaluate(prevBaseStore, currBaseStore)\n        ) {\n          return prevVal\n        }\n\n        let state = {\n          ...currBaseStore,\n          errorMap,\n          fieldMeta: this.fieldMetaDerived.state,\n          errors,\n          isFieldsValidating,\n          isFieldsValid,\n          isFormValid,\n          isValid,\n          canSubmit,\n          isTouched,\n          isBlurred,\n          isPristine,\n          isDefaultValue,\n          isDirty,\n        } as FormState<\n          TFormData,\n          TOnMount,\n          TOnChange,\n          TOnChangeAsync,\n          TOnBlur,\n          TOnBlurAsync,\n          TOnSubmit,\n          TOnSubmitAsync,\n          TOnDynamic,\n          TOnDynamicAsync,\n          TOnServer\n        >\n\n        // Only run transform if state has shallowly changed - IE how React.useEffect works\n        const transformArray = this.options.transform?.deps ?? []\n        const shouldTransform =\n          transformArray.length !== this.prevTransformArray.length ||\n          transformArray.some((val, i) => val !== this.prevTransformArray[i])\n\n        if (shouldTransform) {\n          const newObj = Object.assign({}, this, { state })\n          // This mutates the state\n          this.options.transform?.fn(newObj)\n          state = newObj.state\n          this.prevTransformArray = transformArray\n        }\n\n        return state\n      },\n    })\n\n    this.handleSubmit = this.handleSubmit.bind(this)\n\n    this.update(opts || {})\n  }\n\n  get formId(): string {\n    return this._formId\n  }\n\n  /**\n   * @private\n   */\n  runValidator<\n    TValue extends TStandardSchemaValidatorValue<TFormData> & {\n      formApi: AnyFormApi\n    },\n    TType extends 'validate' | 'validateAsync',\n  >(props: {\n    validate: TType extends 'validate'\n      ? FormValidateOrFn<TFormData>\n      : FormAsyncValidateOrFn<TFormData>\n    value: TValue\n    type: TType\n  }): unknown {\n    if (isStandardSchemaValidator(props.validate)) {\n      return standardSchemaValidators[props.type](\n        props.value,\n        props.validate,\n      ) as never\n    }\n\n    return (props.validate as FormValidateFn<any>)(props.value) as never\n  }\n\n  mount = () => {\n    const cleanupFieldMetaDerived = this.fieldMetaDerived.mount()\n    const cleanupStoreDerived = this.store.mount()\n\n    // devtool broadcasts\n    const cleanupDevtoolBroadcast = this.store.subscribe(() => {\n      throttleFormState(this)\n    })\n\n    // devtool requests\n    const cleanupFormStateListener = formEventClient.on(\n      'request-form-state',\n      (e) => {\n        if (e.payload.id === this._formId) {\n          formEventClient.emit('form-api', {\n            id: this._formId,\n            state: this.store.state,\n            options: this.options,\n          })\n        }\n      },\n    )\n\n    const cleanupFormResetListener = formEventClient.on(\n      'request-form-reset',\n      (e) => {\n        if (e.payload.id === this._formId) {\n          this.reset()\n        }\n      },\n    )\n\n    const cleanupFormForceSubmitListener = formEventClient.on(\n      'request-form-force-submit',\n      (e) => {\n        if (e.payload.id === this._formId) {\n          this._devtoolsSubmissionOverride = true\n          this.handleSubmit()\n          this._devtoolsSubmissionOverride = false\n        }\n      },\n    )\n\n    const cleanup = () => {\n      cleanupFormForceSubmitListener()\n      cleanupFormResetListener()\n      cleanupFormStateListener()\n      cleanupDevtoolBroadcast()\n      cleanupFieldMetaDerived()\n      cleanupStoreDerived()\n\n      // broadcast form unmount for devtools\n      formEventClient.emit('form-unmounted', {\n        id: this._formId,\n      })\n    }\n\n    this.options.listeners?.onMount?.({ formApi: this })\n\n    const { onMount } = this.options.validators || {}\n\n    // broadcast form state for devtools on mounting\n    formEventClient.emit('form-api', {\n      id: this._formId,\n      state: this.store.state,\n      options: this.options,\n    })\n\n    // if no validation skip\n    if (!onMount) return cleanup\n\n    // validate\n    this.validateSync('mount')\n    return cleanup\n  }\n\n  /**\n   * Updates the form options and form state.\n   */\n  update = (\n    options?: FormOptions<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer,\n      TSubmitMeta\n    >,\n  ) => {\n    if (!options) return\n\n    const oldOptions = this.options\n\n    // Options need to be updated first so that when the store is updated, the state is correct for the derived state\n    this.options = options\n\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    const shouldUpdateReeval = !!options.transform?.deps?.some(\n      (val, i) => val !== this.prevTransformArray[i],\n    )\n\n    const shouldUpdateValues =\n      options.defaultValues &&\n      !evaluate(options.defaultValues, oldOptions.defaultValues) &&\n      !this.state.isTouched\n\n    const shouldUpdateState =\n      !evaluate(options.defaultState, oldOptions.defaultState) &&\n      !this.state.isTouched\n\n    if (!shouldUpdateValues && !shouldUpdateState && !shouldUpdateReeval) return\n\n    batch(() => {\n      this.baseStore.setState(() =>\n        getDefaultFormState(\n          Object.assign(\n            {},\n            this.state as any,\n\n            shouldUpdateState ? options.defaultState : {},\n\n            shouldUpdateValues\n              ? {\n                  values: options.defaultValues,\n                }\n              : {},\n\n            shouldUpdateReeval\n              ? { _force_re_eval: !this.state._force_re_eval }\n              : {},\n          ),\n        ),\n      )\n    })\n\n    formEventClient.emit('form-api', {\n      id: this._formId,\n      state: this.store.state,\n      options: this.options,\n    })\n  }\n\n  /**\n   * Resets the form state to the default values.\n   * If values are provided, the form will be reset to those values instead and the default values will be updated.\n   *\n   * @param values - Optional values to reset the form to.\n   * @param opts - Optional options to control the reset behavior.\n   */\n  reset = (values?: TFormData, opts?: { keepDefaultValues?: boolean }) => {\n    const { fieldMeta: currentFieldMeta } = this.state\n    const fieldMetaBase = this.resetFieldMeta(currentFieldMeta)\n\n    if (values && !opts?.keepDefaultValues) {\n      this.options = {\n        ...this.options,\n        defaultValues: values,\n      }\n    }\n\n    this.baseStore.setState(() =>\n      getDefaultFormState({\n        ...(this.options.defaultState as any),\n        values:\n          values ??\n          this.options.defaultValues ??\n          this.options.defaultState?.values,\n        fieldMetaBase,\n      }),\n    )\n  }\n\n  /**\n   * Validates all fields using the correct handlers for a given validation cause.\n   */\n  validateAllFields = async (cause: ValidationCause) => {\n    const fieldValidationPromises: Promise<ValidationError[]>[] = [] as any\n    batch(() => {\n      void (Object.values(this.fieldInfo) as FieldInfo<any>[]).forEach(\n        (field) => {\n          if (!field.instance) return\n          const fieldInstance = field.instance\n          // Validate the field\n          fieldValidationPromises.push(\n            // Remember, `validate` is either a sync operation or a promise\n            Promise.resolve().then(() =>\n              fieldInstance.validate(cause, { skipFormValidation: true }),\n            ),\n          )\n          // If any fields are not touched\n          if (!field.instance.state.meta.isTouched) {\n            // Mark them as touched\n            field.instance.setMeta((prev) => ({ ...prev, isTouched: true }))\n          }\n        },\n      )\n    })\n\n    const fieldErrorMapMap = await Promise.all(fieldValidationPromises)\n    return fieldErrorMapMap.flat()\n  }\n\n  /**\n   * Validates the children of a specified array in the form starting from a given index until the end using the correct handlers for a given validation type.\n   */\n  validateArrayFieldsStartingFrom = async <\n    TField extends DeepKeysOfType<TFormData, any[]>,\n  >(\n    field: TField,\n    index: number,\n    cause: ValidationCause,\n  ) => {\n    const currentValue = this.getFieldValue(field)\n\n    const lastIndex = Array.isArray(currentValue)\n      ? Math.max((currentValue as Array<unknown>).length - 1, 0)\n      : null\n\n    // We have to validate all fields that have shifted (at least the current field)\n    const fieldKeysToValidate = [`${field}[${index}]`]\n    for (let i = index + 1; i <= (lastIndex ?? 0); i++) {\n      fieldKeysToValidate.push(`${field}[${i}]`)\n    }\n\n    // We also have to include all fields that are nested in the shifted fields\n    const fieldsToValidate = Object.keys(this.fieldInfo).filter((fieldKey) =>\n      fieldKeysToValidate.some((key) => fieldKey.startsWith(key)),\n    ) as DeepKeys<TFormData>[]\n\n    // Validate the fields\n    const fieldValidationPromises: Promise<ValidationError[]>[] = [] as any\n    batch(() => {\n      fieldsToValidate.forEach((nestedField) => {\n        fieldValidationPromises.push(\n          Promise.resolve().then(() => this.validateField(nestedField, cause)),\n        )\n      })\n    })\n\n    const fieldErrorMapMap = await Promise.all(fieldValidationPromises)\n    return fieldErrorMapMap.flat()\n  }\n\n  /**\n   * Validates a specified field in the form using the correct handlers for a given validation type.\n   */\n  validateField = <TField extends DeepKeys<TFormData>>(\n    field: TField,\n    cause: ValidationCause,\n  ) => {\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    const fieldInstance = this.fieldInfo[field]?.instance\n    if (!fieldInstance) return []\n\n    // If the field is not touched (same logic as in validateAllFields)\n    if (!fieldInstance.state.meta.isTouched) {\n      // Mark it as touched\n      fieldInstance.setMeta((prev) => ({ ...prev, isTouched: true }))\n    }\n\n    return fieldInstance.validate(cause)\n  }\n\n  /**\n   * TODO: This code is copied from FieldApi, we should refactor to share\n   * @private\n   */\n  validateSync = (\n    cause: ValidationCause,\n  ): {\n    hasErrored: boolean\n    fieldsErrorMap: FormErrorMapFromValidator<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync\n    >\n  } => {\n    const validates = getSyncValidatorArray(cause, {\n      ...this.options,\n      form: this,\n      validationLogic: this.options.validationLogic || defaultValidationLogic,\n    })\n\n    let hasErrored = false as boolean\n\n    // This map will only include fields that have errors in the current validation cycle\n    const currentValidationErrorMap: FormErrorMapFromValidator<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync\n    > = {}\n\n    batch(() => {\n      for (const validateObj of validates) {\n        if (!validateObj.validate) continue\n\n        const rawError = this.runValidator({\n          validate: validateObj.validate,\n          value: {\n            value: this.state.values,\n            formApi: this,\n            validationSource: 'form',\n          },\n          type: 'validate',\n        })\n\n        const { formError, fieldErrors } = normalizeError<TFormData>(rawError)\n\n        const errorMapKey = getErrorMapKey(validateObj.cause)\n\n        const allFieldsToProcess = new Set([\n          ...Object.keys(this.state.fieldMeta),\n          ...Object.keys(fieldErrors || {}),\n        ] as DeepKeys<TFormData>[])\n\n        for (const field of allFieldsToProcess) {\n          if (\n            this.baseStore.state.fieldMetaBase[field] === undefined &&\n            !fieldErrors?.[field]\n          ) {\n            continue\n          }\n\n          const fieldMeta = this.getFieldMeta(field) ?? defaultFieldMeta\n          const {\n            errorMap: currentErrorMap,\n            errorSourceMap: currentErrorMapSource,\n          } = fieldMeta\n\n          const newFormValidatorError = fieldErrors?.[field]\n\n          const { newErrorValue, newSource } =\n            determineFormLevelErrorSourceAndValue({\n              newFormValidatorError,\n              isPreviousErrorFromFormValidator:\n                currentErrorMapSource[errorMapKey] === 'form',\n              previousErrorValue: currentErrorMap[errorMapKey],\n            })\n\n          if (newSource === 'form') {\n            currentValidationErrorMap[field] = {\n              ...currentValidationErrorMap[field],\n              [errorMapKey]: newFormValidatorError,\n            }\n          }\n\n          if (currentErrorMap[errorMapKey] !== newErrorValue) {\n            this.setFieldMeta(field, (prev = defaultFieldMeta) => ({\n              ...prev,\n              errorMap: {\n                ...prev.errorMap,\n                [errorMapKey]: newErrorValue,\n              },\n              errorSourceMap: {\n                ...prev.errorSourceMap,\n                [errorMapKey]: newSource,\n              },\n            }))\n          }\n        }\n\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (this.state.errorMap?.[errorMapKey] !== formError) {\n          this.baseStore.setState((prev) => ({\n            ...prev,\n            errorMap: {\n              ...prev.errorMap,\n              [errorMapKey]: formError,\n            },\n          }))\n        }\n\n        if (formError || fieldErrors) {\n          hasErrored = true\n        }\n      }\n\n      /**\n       *  when we have an error for onSubmit in the state, we want\n       *  to clear the error as soon as the user enters a valid value in the field\n       */\n      const submitErrKey = getErrorMapKey('submit')\n      if (\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        this.state.errorMap?.[submitErrKey] &&\n        cause !== 'submit' &&\n        !hasErrored\n      ) {\n        this.baseStore.setState((prev) => ({\n          ...prev,\n          errorMap: {\n            ...prev.errorMap,\n            [submitErrKey]: undefined,\n          },\n        }))\n      }\n\n      /**\n       *  when we have an error for onServer in the state, we want\n       *  to clear the error as soon as the user enters a valid value in the field\n       */\n      const serverErrKey = getErrorMapKey('server')\n      if (\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        this.state.errorMap?.[serverErrKey] &&\n        cause !== 'server' &&\n        !hasErrored\n      ) {\n        this.baseStore.setState((prev) => ({\n          ...prev,\n          errorMap: {\n            ...prev.errorMap,\n            [serverErrKey]: undefined,\n          },\n        }))\n      }\n    })\n\n    return { hasErrored, fieldsErrorMap: currentValidationErrorMap }\n  }\n\n  /**\n   * @private\n   */\n  validateAsync = async (\n    cause: ValidationCause,\n  ): Promise<\n    FormErrorMapFromValidator<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync\n    >\n  > => {\n    const validates = getAsyncValidatorArray(cause, {\n      ...this.options,\n      form: this,\n      validationLogic: this.options.validationLogic || defaultValidationLogic,\n    })\n\n    if (!this.state.isFormValidating) {\n      this.baseStore.setState((prev) => ({ ...prev, isFormValidating: true }))\n    }\n\n    /**\n     * We have to use a for loop and generate our promises this way, otherwise it won't be sync\n     * when there are no validators needed to be run\n     */\n    const promises: Promise<ValidationPromiseResult<TFormData>>[] = []\n\n    let fieldErrorsFromFormValidators:\n      | Partial<Record<DeepKeys<TFormData>, ValidationError>>\n      | undefined\n\n    for (const validateObj of validates) {\n      if (!validateObj.validate) continue\n      const key = getErrorMapKey(validateObj.cause)\n      const fieldValidatorMeta = this.state.validationMetaMap[key]\n\n      fieldValidatorMeta?.lastAbortController.abort()\n      const controller = new AbortController()\n\n      this.state.validationMetaMap[key] = {\n        lastAbortController: controller,\n      }\n\n      promises.push(\n        new Promise<ValidationPromiseResult<TFormData>>(async (resolve) => {\n          let rawError!:\n            | ValidationError\n            | FormValidationError<unknown>\n            | undefined\n          try {\n            rawError = await new Promise((rawResolve, rawReject) => {\n              setTimeout(async () => {\n                if (controller.signal.aborted) return rawResolve(undefined)\n                try {\n                  rawResolve(\n                    await this.runValidator({\n                      validate: validateObj.validate!,\n                      value: {\n                        value: this.state.values,\n                        formApi: this,\n                        validationSource: 'form',\n                        signal: controller.signal,\n                      },\n                      type: 'validateAsync',\n                    }),\n                  )\n                } catch (e) {\n                  rawReject(e)\n                }\n              }, validateObj.debounceMs)\n            })\n          } catch (e: unknown) {\n            rawError = e as ValidationError\n          }\n          const { formError, fieldErrors: fieldErrorsFromNormalizeError } =\n            normalizeError<TFormData>(rawError)\n\n          if (fieldErrorsFromNormalizeError) {\n            fieldErrorsFromFormValidators = fieldErrorsFromFormValidators\n              ? {\n                  ...fieldErrorsFromFormValidators,\n                  ...fieldErrorsFromNormalizeError,\n                }\n              : fieldErrorsFromNormalizeError\n          }\n          const errorMapKey = getErrorMapKey(validateObj.cause)\n\n          for (const field of Object.keys(\n            this.state.fieldMeta,\n          ) as DeepKeys<TFormData>[]) {\n            if (this.baseStore.state.fieldMetaBase[field] === undefined) {\n              continue\n            }\n\n            const fieldMeta = this.getFieldMeta(field)\n            if (!fieldMeta) continue\n\n            const {\n              errorMap: currentErrorMap,\n              errorSourceMap: currentErrorMapSource,\n            } = fieldMeta\n\n            const newFormValidatorError = fieldErrorsFromFormValidators?.[field]\n\n            const { newErrorValue, newSource } =\n              determineFormLevelErrorSourceAndValue({\n                newFormValidatorError,\n                isPreviousErrorFromFormValidator:\n                  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n                  currentErrorMapSource?.[errorMapKey] === 'form',\n                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n                previousErrorValue: currentErrorMap?.[errorMapKey],\n              })\n\n            if (\n              // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n              currentErrorMap?.[errorMapKey] !== newErrorValue\n            ) {\n              this.setFieldMeta(field, (prev) => ({\n                ...prev,\n                errorMap: {\n                  ...prev.errorMap,\n                  [errorMapKey]: newErrorValue,\n                },\n                errorSourceMap: {\n                  ...prev.errorSourceMap,\n                  [errorMapKey]: newSource,\n                },\n              }))\n            }\n          }\n\n          this.baseStore.setState((prev) => ({\n            ...prev,\n            errorMap: {\n              ...prev.errorMap,\n              [errorMapKey]: formError,\n            },\n          }))\n\n          resolve(\n            fieldErrorsFromFormValidators\n              ? { fieldErrors: fieldErrorsFromFormValidators, errorMapKey }\n              : undefined,\n          )\n        }),\n      )\n    }\n\n    let results: ValidationPromiseResult<TFormData>[] = []\n\n    const fieldsErrorMap: FormErrorMapFromValidator<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync\n    > = {}\n    if (promises.length) {\n      results = await Promise.all(promises)\n      for (const fieldValidationResult of results) {\n        if (fieldValidationResult?.fieldErrors) {\n          const { errorMapKey } = fieldValidationResult\n\n          for (const [field, fieldError] of Object.entries(\n            fieldValidationResult.fieldErrors,\n          )) {\n            const oldErrorMap =\n              fieldsErrorMap[field as DeepKeys<TFormData>] || {}\n            const newErrorMap = {\n              ...oldErrorMap,\n              [errorMapKey]: fieldError,\n            }\n            fieldsErrorMap[field as DeepKeys<TFormData>] = newErrorMap\n          }\n        }\n      }\n    }\n\n    this.baseStore.setState((prev) => ({\n      ...prev,\n      isFormValidating: false,\n    }))\n\n    return fieldsErrorMap\n  }\n\n  /**\n   * @private\n   */\n  validate = (\n    cause: ValidationCause,\n  ):\n    | FormErrorMapFromValidator<\n        TFormData,\n        TOnMount,\n        TOnChange,\n        TOnChangeAsync,\n        TOnBlur,\n        TOnBlurAsync,\n        TOnSubmit,\n        TOnSubmitAsync,\n        TOnDynamic,\n        TOnDynamicAsync\n      >\n    | Promise<\n        FormErrorMapFromValidator<\n          TFormData,\n          TOnMount,\n          TOnChange,\n          TOnChangeAsync,\n          TOnBlur,\n          TOnBlurAsync,\n          TOnSubmit,\n          TOnSubmitAsync,\n          TOnDynamic,\n          TOnDynamicAsync\n        >\n      > => {\n    // Attempt to sync validate first\n    const { hasErrored, fieldsErrorMap } = this.validateSync(cause)\n\n    if (hasErrored && !this.options.asyncAlways) {\n      return fieldsErrorMap\n    }\n\n    // No error? Attempt async validation\n    return this.validateAsync(cause)\n  }\n\n  // Needs to edgecase in the React adapter specifically to avoid type errors\n  handleSubmit(): Promise<void>\n  handleSubmit(submitMeta: TSubmitMeta): Promise<void>\n  handleSubmit(submitMeta?: TSubmitMeta): Promise<void> {\n    return this._handleSubmit(submitMeta)\n  }\n\n  /**\n   * Handles the form submission, performs validation, and calls the appropriate onSubmit or onSubmitInvalid callbacks.\n   */\n  _handleSubmit = async (submitMeta?: TSubmitMeta): Promise<void> => {\n    this.baseStore.setState((old) => ({\n      ...old,\n      // Submission attempts mark the form as not submitted\n      isSubmitted: false,\n      // Count submission attempts\n      submissionAttempts: old.submissionAttempts + 1,\n      isSubmitSuccessful: false, // Reset isSubmitSuccessful at the start of submission\n    }))\n\n    batch(() => {\n      void (Object.values(this.fieldInfo) as FieldInfo<any>[]).forEach(\n        (field) => {\n          if (!field.instance) return\n          // If any fields are not touched\n          if (!field.instance.state.meta.isTouched) {\n            // Mark them as touched\n            field.instance.setMeta((prev) => ({ ...prev, isTouched: true }))\n          }\n        },\n      )\n    })\n\n    const submitMetaArg =\n      submitMeta ?? (this.options.onSubmitMeta as TSubmitMeta)\n\n    if (!this.state.canSubmit && !this._devtoolsSubmissionOverride) {\n      this.options.onSubmitInvalid?.({\n        value: this.state.values,\n        formApi: this,\n        meta: submitMetaArg,\n      })\n      return\n    }\n\n    this.baseStore.setState((d) => ({ ...d, isSubmitting: true }))\n\n    const done = () => {\n      this.baseStore.setState((prev) => ({ ...prev, isSubmitting: false }))\n    }\n\n    await this.validateAllFields('submit')\n\n    if (!this.state.isFieldsValid) {\n      done()\n\n      this.options.onSubmitInvalid?.({\n        value: this.state.values,\n        formApi: this,\n        meta: submitMetaArg,\n      })\n\n      formEventClient.emit('form-submission', {\n        id: this._formId,\n        submissionAttempt: this.state.submissionAttempts,\n        successful: false,\n        stage: 'validateAllFields',\n        errors: (Object.values(this.state.fieldMeta) as AnyFieldMeta[])\n          .map((meta: AnyFieldMeta) => meta.errors)\n          .flat(),\n      })\n      return\n    }\n\n    await this.validate('submit')\n\n    // Fields are invalid, do not submit\n    if (!this.state.isValid) {\n      done()\n\n      this.options.onSubmitInvalid?.({\n        value: this.state.values,\n        formApi: this,\n        meta: submitMetaArg,\n      })\n\n      formEventClient.emit('form-submission', {\n        id: this._formId,\n        submissionAttempt: this.state.submissionAttempts,\n        successful: false,\n        stage: 'validate',\n        errors: this.state.errors,\n      })\n\n      return\n    }\n\n    batch(() => {\n      void (Object.values(this.fieldInfo) as FieldInfo<TFormData>[]).forEach(\n        (field) => {\n          field.instance?.options.listeners?.onSubmit?.({\n            value: field.instance.state.value,\n            fieldApi: field.instance,\n          })\n        },\n      )\n    })\n\n    this.options.listeners?.onSubmit?.({ formApi: this, meta: submitMetaArg })\n\n    try {\n      // Run the submit code\n      await this.options.onSubmit?.({\n        value: this.state.values,\n        formApi: this,\n        meta: submitMetaArg,\n      })\n\n      batch(() => {\n        this.baseStore.setState((prev) => ({\n          ...prev,\n          isSubmitted: true,\n          isSubmitSuccessful: true, // Set isSubmitSuccessful to true on successful submission\n        }))\n\n        formEventClient.emit('form-submission', {\n          id: this._formId,\n          submissionAttempt: this.state.submissionAttempts,\n          successful: true,\n        })\n\n        done()\n      })\n    } catch (err) {\n      this.baseStore.setState((prev) => ({\n        ...prev,\n        isSubmitSuccessful: false, // Ensure isSubmitSuccessful is false if an error occurs\n      }))\n\n      formEventClient.emit('form-submission', {\n        id: this._formId,\n        submissionAttempt: this.state.submissionAttempts,\n        successful: false,\n        stage: 'inflight',\n        onError: err,\n      })\n\n      done()\n\n      throw err\n    }\n  }\n\n  /**\n   * Gets the value of the specified field.\n   */\n  getFieldValue = <TField extends DeepKeys<TFormData>>(\n    field: TField,\n  ): DeepValue<TFormData, TField> => getBy(this.state.values, field)\n\n  /**\n   * Gets the metadata of the specified field.\n   */\n  getFieldMeta = <TField extends DeepKeys<TFormData>>(\n    field: TField,\n  ): AnyFieldMeta | undefined => {\n    return this.state.fieldMeta[field]\n  }\n\n  /**\n   * Gets the field info of the specified field.\n   */\n  getFieldInfo = <TField extends DeepKeys<TFormData>>(\n    field: TField,\n  ): FieldInfo<TFormData> => {\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    return (this.fieldInfo[field] ||= {\n      instance: null,\n      validationMetaMap: {\n        onChange: undefined,\n        onBlur: undefined,\n        onSubmit: undefined,\n        onMount: undefined,\n        onServer: undefined,\n        onDynamic: undefined,\n      },\n    })\n  }\n\n  /**\n   * Updates the metadata of the specified field.\n   */\n  setFieldMeta = <TField extends DeepKeys<TFormData>>(\n    field: TField,\n    updater: Updater<AnyFieldMetaBase>,\n  ) => {\n    this.baseStore.setState((prev) => {\n      return {\n        ...prev,\n        fieldMetaBase: {\n          ...prev.fieldMetaBase,\n          [field]: functionalUpdate(\n            updater,\n            prev.fieldMetaBase[field] as never,\n          ),\n        },\n      }\n    })\n  }\n\n  /**\n   * resets every field's meta\n   */\n  resetFieldMeta = <TField extends DeepKeys<TFormData>>(\n    fieldMeta: Partial<Record<TField, AnyFieldMeta>>,\n  ): Partial<Record<TField, AnyFieldMeta>> => {\n    return Object.keys(fieldMeta).reduce(\n      (acc, key) => {\n        const fieldKey = key as TField\n        acc[fieldKey] = defaultFieldMeta\n        return acc\n      },\n      {} as Partial<Record<TField, AnyFieldMeta>>,\n    )\n  }\n\n  /**\n   * Sets the value of the specified field and optionally updates the touched state.\n   */\n  setFieldValue = <TField extends DeepKeys<TFormData>>(\n    field: TField,\n    updater: Updater<DeepValue<TFormData, TField>>,\n    opts?: UpdateMetaOptions,\n  ) => {\n    const dontUpdateMeta = opts?.dontUpdateMeta ?? false\n    const dontRunListeners = opts?.dontRunListeners ?? false\n    const dontValidate = opts?.dontValidate ?? false\n\n    batch(() => {\n      if (!dontUpdateMeta) {\n        this.setFieldMeta(field, (prev) => ({\n          ...prev,\n          isTouched: true,\n          isDirty: true,\n          errorMap: {\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            ...prev?.errorMap,\n            onMount: undefined,\n          },\n        }))\n      }\n\n      this.baseStore.setState((prev) => {\n        return {\n          ...prev,\n          values: setBy(prev.values, field, updater),\n        }\n      })\n    })\n\n    if (!dontRunListeners) {\n      this.getFieldInfo(field).instance?.triggerOnChangeListener()\n    }\n\n    if (!dontValidate) {\n      this.validateField(field, 'change')\n    }\n  }\n\n  deleteField = <TField extends DeepKeys<TFormData>>(field: TField) => {\n    const subFieldsToDelete = Object.keys(this.fieldInfo).filter((f) => {\n      const fieldStr = field.toString()\n      return f !== fieldStr && f.startsWith(fieldStr)\n    })\n\n    const fieldsToDelete = [...subFieldsToDelete, field]\n\n    // Cleanup the last fields\n    this.baseStore.setState((prev) => {\n      const newState = { ...prev }\n      fieldsToDelete.forEach((f) => {\n        newState.values = deleteBy(newState.values, f)\n        delete this.fieldInfo[f as never]\n        delete newState.fieldMetaBase[f as never]\n      })\n\n      return newState\n    })\n  }\n\n  /**\n   * Pushes a value into an array field.\n   */\n  pushFieldValue = <TField extends DeepKeysOfType<TFormData, any[]>>(\n    field: TField,\n    value: DeepValue<TFormData, TField> extends any[]\n      ? DeepValue<TFormData, TField>[number]\n      : never,\n    options?: UpdateMetaOptions,\n  ) => {\n    this.setFieldValue(\n      field,\n      (prev) => [...(Array.isArray(prev) ? prev : []), value] as any,\n      options,\n    )\n  }\n\n  insertFieldValue = async <TField extends DeepKeysOfType<TFormData, any[]>>(\n    field: TField,\n    index: number,\n    value: DeepValue<TFormData, TField> extends any[]\n      ? DeepValue<TFormData, TField>[number]\n      : never,\n    options?: UpdateMetaOptions,\n  ) => {\n    this.setFieldValue(\n      field,\n      (prev) => {\n        return [\n          ...(prev as DeepValue<TFormData, TField>[]).slice(0, index),\n          value,\n          ...(prev as DeepValue<TFormData, TField>[]).slice(index),\n        ] as any\n      },\n      mergeOpts(options, { dontValidate: true }),\n    )\n\n    const dontValidate = options?.dontValidate ?? false\n    if (!dontValidate) {\n      // Validate the whole array + all fields that have shifted\n      await this.validateField(field, 'change')\n    }\n\n    // Shift down all meta after validating to make sure the new field has been mounted\n    metaHelper(this).handleArrayInsert(field, index)\n\n    if (!dontValidate) {\n      await this.validateArrayFieldsStartingFrom(field, index, 'change')\n    }\n  }\n\n  /**\n   * Replaces a value into an array field at the specified index.\n   */\n  replaceFieldValue = async <TField extends DeepKeysOfType<TFormData, any[]>>(\n    field: TField,\n    index: number,\n    value: DeepValue<TFormData, TField> extends any[]\n      ? DeepValue<TFormData, TField>[number]\n      : never,\n    options?: UpdateMetaOptions,\n  ) => {\n    this.setFieldValue(\n      field,\n      (prev) => {\n        return (prev as DeepValue<TFormData, TField>[]).map((d, i) =>\n          i === index ? value : d,\n        ) as any\n      },\n      mergeOpts(options, { dontValidate: true }),\n    )\n\n    const dontValidate = options?.dontValidate ?? false\n    if (!dontValidate) {\n      // Validate the whole array + all fields that have shifted\n      await this.validateField(field, 'change')\n      await this.validateArrayFieldsStartingFrom(field, index, 'change')\n    }\n  }\n\n  /**\n   * Removes a value from an array field at the specified index.\n   */\n  removeFieldValue = async <TField extends DeepKeysOfType<TFormData, any[]>>(\n    field: TField,\n    index: number,\n    options?: UpdateMetaOptions,\n  ) => {\n    const fieldValue = this.getFieldValue(field)\n\n    const lastIndex = Array.isArray(fieldValue)\n      ? Math.max((fieldValue as Array<unknown>).length - 1, 0)\n      : null\n\n    this.setFieldValue(\n      field,\n      (prev) => {\n        return (prev as DeepValue<TFormData, TField>[]).filter(\n          (_d, i) => i !== index,\n        ) as any\n      },\n      mergeOpts(options, { dontValidate: true }),\n    )\n\n    // Shift up all meta\n    metaHelper(this).handleArrayRemove(field, index)\n\n    if (lastIndex !== null) {\n      const start = `${field}[${lastIndex}]`\n      this.deleteField(start as never)\n    }\n\n    const dontValidate = options?.dontValidate ?? false\n    if (!dontValidate) {\n      // Validate the whole array + all fields that have shifted\n      await this.validateField(field, 'change')\n      await this.validateArrayFieldsStartingFrom(field, index, 'change')\n    }\n  }\n\n  /**\n   * Swaps the values at the specified indices within an array field.\n   */\n  swapFieldValues = <TField extends DeepKeysOfType<TFormData, any[]>>(\n    field: TField,\n    index1: number,\n    index2: number,\n    options?: UpdateMetaOptions,\n  ) => {\n    this.setFieldValue(\n      field,\n      (prev: any) => {\n        const prev1 = prev[index1]!\n        const prev2 = prev[index2]!\n        return setBy(setBy(prev, `${index1}`, prev2), `${index2}`, prev1)\n      },\n      mergeOpts(options, { dontValidate: true }),\n    )\n\n    // Swap meta\n    metaHelper(this).handleArraySwap(field, index1, index2)\n\n    const dontValidate = options?.dontValidate ?? false\n    if (!dontValidate) {\n      // Validate the whole array\n      this.validateField(field, 'change')\n      // Validate the swapped fields\n      this.validateField(`${field}[${index1}]` as DeepKeys<TFormData>, 'change')\n      this.validateField(`${field}[${index2}]` as DeepKeys<TFormData>, 'change')\n    }\n  }\n\n  /**\n   * Moves the value at the first specified index to the second specified index within an array field.\n   */\n  moveFieldValues = <TField extends DeepKeysOfType<TFormData, any[]>>(\n    field: TField,\n    index1: number,\n    index2: number,\n    options?: UpdateMetaOptions,\n  ) => {\n    this.setFieldValue(\n      field,\n      (prev: any) => {\n        const next: any = [...prev]\n        next.splice(index2, 0, next.splice(index1, 1)[0])\n        return next\n      },\n      mergeOpts(options, { dontValidate: true }),\n    )\n\n    // Move meta between index1 and index2\n    metaHelper(this).handleArrayMove(field, index1, index2)\n\n    const dontValidate = options?.dontValidate ?? false\n    if (!dontValidate) {\n      // Validate the whole array\n      this.validateField(field, 'change')\n      // Validate the moved fields\n      this.validateField(`${field}[${index1}]` as DeepKeys<TFormData>, 'change')\n      this.validateField(`${field}[${index2}]` as DeepKeys<TFormData>, 'change')\n    }\n  }\n\n  /**\n   * Clear all values within an array field.\n   */\n  clearFieldValues = <TField extends DeepKeysOfType<TFormData, any[]>>(\n    field: TField,\n    options?: UpdateMetaOptions,\n  ) => {\n    const fieldValue = this.getFieldValue(field)\n\n    const lastIndex = Array.isArray(fieldValue)\n      ? Math.max((fieldValue as unknown[]).length - 1, 0)\n      : null\n\n    this.setFieldValue(\n      field,\n      [] as any,\n      mergeOpts(options, { dontValidate: true }),\n    )\n\n    if (lastIndex !== null) {\n      for (let i = 0; i <= lastIndex; i++) {\n        const fieldKey = `${field}[${i}]`\n        this.deleteField(fieldKey as never)\n      }\n    }\n\n    const dontValidate = options?.dontValidate ?? false\n    if (!dontValidate) {\n      // validate array change\n      this.validateField(field, 'change')\n    }\n  }\n\n  /**\n   * Resets the field value and meta to default state\n   */\n  resetField = <TField extends DeepKeys<TFormData>>(field: TField) => {\n    this.baseStore.setState((prev) => {\n      return {\n        ...prev,\n        fieldMetaBase: {\n          ...prev.fieldMetaBase,\n          [field]: defaultFieldMeta,\n        },\n        values: this.options.defaultValues\n          ? setBy(prev.values, field, getBy(this.options.defaultValues, field))\n          : prev.values,\n      }\n    })\n  }\n\n  /**\n   * Updates the form's errorMap\n   */\n  setErrorMap = (\n    errorMap: FormValidationErrorMap<\n      TFormData,\n      UnwrapFormValidateOrFn<TOnMount>,\n      UnwrapFormValidateOrFn<TOnChange>,\n      UnwrapFormAsyncValidateOrFn<TOnChangeAsync>,\n      UnwrapFormValidateOrFn<TOnBlur>,\n      UnwrapFormAsyncValidateOrFn<TOnBlurAsync>,\n      UnwrapFormValidateOrFn<TOnSubmit>,\n      UnwrapFormAsyncValidateOrFn<TOnSubmitAsync>,\n      UnwrapFormValidateOrFn<TOnDynamic>,\n      UnwrapFormAsyncValidateOrFn<TOnDynamicAsync>,\n      UnwrapFormAsyncValidateOrFn<TOnServer>\n    >,\n  ) => {\n    batch(() => {\n      Object.entries(errorMap).forEach(([key, value]) => {\n        const errorMapKey = key as ValidationErrorMapKeys\n\n        if (isGlobalFormValidationError(value)) {\n          const { formError, fieldErrors } = normalizeError<TFormData>(value)\n\n          for (const fieldName of Object.keys(\n            this.fieldInfo,\n          ) as DeepKeys<TFormData>[]) {\n            const fieldMeta = this.getFieldMeta(fieldName)\n            if (!fieldMeta) continue\n\n            this.setFieldMeta(fieldName, (prev) => ({\n              ...prev,\n              errorMap: {\n                ...prev.errorMap,\n                [errorMapKey]: fieldErrors?.[fieldName],\n              },\n              errorSourceMap: {\n                ...prev.errorSourceMap,\n                [errorMapKey]: 'form',\n              },\n            }))\n          }\n\n          this.baseStore.setState((prev) => ({\n            ...prev,\n            errorMap: {\n              ...prev.errorMap,\n              [errorMapKey]: formError,\n            },\n          }))\n        } else {\n          this.baseStore.setState((prev) => ({\n            ...prev,\n            errorMap: {\n              ...prev.errorMap,\n              [errorMapKey]: value,\n            },\n          }))\n        }\n      })\n    })\n  }\n\n  /**\n   * Returns form and field level errors\n   */\n  getAllErrors = (): {\n    form: {\n      errors: Array<\n        | UnwrapFormValidateOrFn<TOnMount>\n        | UnwrapFormValidateOrFn<TOnChange>\n        | UnwrapFormAsyncValidateOrFn<TOnChangeAsync>\n        | UnwrapFormValidateOrFn<TOnBlur>\n        | UnwrapFormAsyncValidateOrFn<TOnBlurAsync>\n        | UnwrapFormValidateOrFn<TOnSubmit>\n        | UnwrapFormAsyncValidateOrFn<TOnSubmitAsync>\n        | UnwrapFormValidateOrFn<TOnDynamic>\n        | UnwrapFormAsyncValidateOrFn<TOnDynamicAsync>\n        | UnwrapFormAsyncValidateOrFn<TOnServer>\n      >\n      errorMap: ValidationErrorMap<\n        UnwrapFormValidateOrFn<TOnMount>,\n        UnwrapFormValidateOrFn<TOnChange>,\n        UnwrapFormAsyncValidateOrFn<TOnChangeAsync>,\n        UnwrapFormValidateOrFn<TOnBlur>,\n        UnwrapFormAsyncValidateOrFn<TOnBlurAsync>,\n        UnwrapFormValidateOrFn<TOnSubmit>,\n        UnwrapFormAsyncValidateOrFn<TOnSubmitAsync>,\n        UnwrapFormValidateOrFn<TOnDynamic>,\n        UnwrapFormAsyncValidateOrFn<TOnDynamicAsync>,\n        UnwrapFormAsyncValidateOrFn<TOnServer>\n      >\n    }\n    fields: Record<\n      DeepKeys<TFormData>,\n      { errors: ValidationError[]; errorMap: ValidationErrorMap }\n    >\n  } => {\n    return {\n      form: {\n        errors: this.state.errors,\n        errorMap: this.state.errorMap,\n      },\n      fields: Object.entries(this.state.fieldMeta).reduce(\n        (acc, [fieldName, fieldMeta]) => {\n          if (\n            Object.keys(fieldMeta as AnyFieldMeta).length &&\n            (fieldMeta as AnyFieldMeta).errors.length\n          ) {\n            acc[fieldName as DeepKeys<TFormData>] = {\n              errors: (fieldMeta as AnyFieldMeta).errors,\n              errorMap: (fieldMeta as AnyFieldMeta).errorMap,\n            }\n          }\n\n          return acc\n        },\n        {} as Record<\n          DeepKeys<TFormData>,\n          { errors: ValidationError[]; errorMap: ValidationErrorMap }\n        >,\n      ),\n    }\n  }\n\n  /**\n   * Parses the form's values with a given standard schema and returns\n   * issues (if any). This method does NOT set any internal errors.\n   * @param schema The standard schema to parse the form values with.\n   */\n  parseValuesWithSchema = (schema: StandardSchemaV1<TFormData, unknown>) => {\n    return standardSchemaValidators.validate(\n      { value: this.state.values, validationSource: 'form' },\n      schema,\n    )\n  }\n\n  /**\n   * Parses the form's values with a given standard schema and returns\n   * issues (if any). This method does NOT set any internal errors.\n   * @param schema The standard schema to parse the form values with.\n   */\n  parseValuesWithSchemaAsync = (\n    schema: StandardSchemaV1<TFormData, unknown>,\n  ) => {\n    return standardSchemaValidators.validateAsync(\n      { value: this.state.values, validationSource: 'form' },\n      schema,\n    )\n  }\n}\n\nfunction normalizeError<TFormData>(rawError?: FormValidationError<unknown>): {\n  formError: ValidationError\n  fieldErrors?: Partial<Record<DeepKeys<TFormData>, ValidationError>>\n} {\n  if (rawError) {\n    if (isGlobalFormValidationError(rawError)) {\n      const formError = normalizeError(rawError.form).formError\n      const fieldErrors = rawError.fields\n      return { formError, fieldErrors } as never\n    }\n\n    return { formError: rawError }\n  }\n\n  return { formError: undefined }\n}\n\nfunction getErrorMapKey(cause: ValidationCause) {\n  switch (cause) {\n    case 'submit':\n      return 'onSubmit'\n    case 'blur':\n      return 'onBlur'\n    case 'mount':\n      return 'onMount'\n    case 'server':\n      return 'onServer'\n    case 'dynamic':\n      return 'onDynamic'\n    case 'change':\n    default:\n      return 'onChange'\n  }\n}\n"],"names":["throttleFormState","formEventClient","evaluate","batch","opts","getSyncValidatorArray","defaultValidationLogic","defaultFieldMeta","determineFormLevelErrorSourceAndValue","getAsyncValidatorArray","getBy","functionalUpdate","setBy","deleteBy","mergeOpts","metaHelper","isGlobalFormValidationError","standardSchemaValidators","uuid","Store","Derived","isNonEmptyArray","isStandardSchemaValidator"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"FormApi.cjs","sources":["../../src/FormApi.ts"],"sourcesContent":["import { Derived, Store, batch } from '@tanstack/store'\nimport {\n  deleteBy,\n  determineFormLevelErrorSourceAndValue,\n  evaluate,\n  functionalUpdate,\n  getAsyncValidatorArray,\n  getBy,\n  getSyncValidatorArray,\n  isGlobalFormValidationError,\n  isNonEmptyArray,\n  mergeOpts,\n  setBy,\n  throttleFormState,\n  uuid,\n} from './utils'\nimport { defaultValidationLogic } from './ValidationLogic'\nimport {\n  isStandardSchemaValidator,\n  standardSchemaValidators,\n} from './standardSchemaValidator'\nimport { defaultFieldMeta, metaHelper } from './metaHelper'\nimport { formEventClient } from './EventClient'\n\n// types\nimport type { ValidationLogicFn } from './ValidationLogic'\nimport type {\n  StandardSchemaV1,\n  StandardSchemaV1Issue,\n  TStandardSchemaValidatorValue,\n} from './standardSchemaValidator'\nimport type {\n  AnyFieldApi,\n  AnyFieldMeta,\n  AnyFieldMetaBase,\n  FieldApi,\n} from './FieldApi'\nimport type {\n  ExtractGlobalFormError,\n  FieldManipulator,\n  FormValidationError,\n  FormValidationErrorMap,\n  ListenerCause,\n  UpdateMetaOptions,\n  ValidationCause,\n  ValidationError,\n  ValidationErrorMap,\n  ValidationErrorMapKeys,\n} from './types'\nimport type { DeepKeys, DeepKeysOfType, DeepValue } from './util-types'\nimport type { Updater } from './utils'\n\n/**\n * @private\n */\n// TODO: Add the `Unwrap` type to the errors\ntype FormErrorMapFromValidator<\n  TFormData,\n  TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnDynamic extends undefined | FormValidateOrFn<TFormData>,\n  TOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n> = Partial<\n  Record<\n    DeepKeys<TFormData>,\n    ValidationErrorMap<\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync\n    >\n  >\n>\n\nexport type FormValidateFn<TFormData> = (props: {\n  value: TFormData\n  formApi: FormApi<\n    TFormData,\n    // This is technically an edge-type; which we try to keep non-`any`, but in this case\n    // It's referring to an inaccessible type from the field validate function inner types, so it's not a big deal\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any\n  >\n}) => unknown\n\n/**\n * @private\n */\nexport type FormValidateOrFn<TFormData> =\n  | FormValidateFn<TFormData>\n  | StandardSchemaV1<TFormData, unknown>\n\nexport type UnwrapFormValidateOrFn<\n  TValidateOrFn extends undefined | FormValidateOrFn<any>,\n> = [TValidateOrFn] extends [FormValidateFn<any>]\n  ? ExtractGlobalFormError<ReturnType<TValidateOrFn>>\n  : [TValidateOrFn] extends [StandardSchemaV1<any, any>]\n    ? Record<string, StandardSchemaV1Issue[]>\n    : undefined\n\n/**\n * @private\n */\nexport type FormValidateAsyncFn<TFormData> = (props: {\n  value: TFormData\n  formApi: FormApi<\n    TFormData,\n    // This is technically an edge-type; which we try to keep non-`any`, but in this case\n    // It's referring to an inaccessible type from the field validate function inner types, so it's not a big deal\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any\n  >\n  signal: AbortSignal\n}) => unknown | Promise<unknown>\n\nexport type FormValidator<TFormData, TType, TFn = unknown> = {\n  validate(options: { value: TType }, fn: TFn): ValidationError\n  validateAsync(\n    options: { value: TType },\n    fn: TFn,\n  ): Promise<FormValidationError<TFormData>>\n}\n\ntype ValidationPromiseResult<TFormData> =\n  | {\n      fieldErrors: Partial<Record<DeepKeys<TFormData>, ValidationError>>\n      errorMapKey: ValidationErrorMapKeys\n    }\n  | undefined\n\n/**\n * @private\n */\nexport type FormAsyncValidateOrFn<TFormData> =\n  | FormValidateAsyncFn<TFormData>\n  | StandardSchemaV1<TFormData, unknown>\n\nexport type UnwrapFormAsyncValidateOrFn<\n  TValidateOrFn extends undefined | FormAsyncValidateOrFn<any>,\n> = [TValidateOrFn] extends [FormValidateAsyncFn<any>]\n  ? ExtractGlobalFormError<Awaited<ReturnType<TValidateOrFn>>>\n  : [TValidateOrFn] extends [StandardSchemaV1<any, any>]\n    ? Record<string, StandardSchemaV1Issue[]>\n    : undefined\n\nexport interface FormValidators<\n  TFormData,\n  TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnDynamic extends undefined | FormValidateOrFn<TFormData>,\n  TOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n> {\n  /**\n   * Optional function that fires as soon as the component mounts.\n   */\n  onMount?: TOnMount\n  /**\n   * Optional function that checks the validity of your data whenever a value changes\n   */\n  onChange?: TOnChange\n  /**\n   * Optional onChange asynchronous counterpart to onChange. Useful for more complex validation logic that might involve server requests.\n   */\n  onChangeAsync?: TOnChangeAsync\n  /**\n   * The default time in milliseconds that if set to a number larger than 0, will debounce the async validation event by this length of time in milliseconds.\n   */\n  onChangeAsyncDebounceMs?: number\n  /**\n   * Optional function that validates the form data when a field loses focus, returns a `FormValidationError`\n   */\n  onBlur?: TOnBlur\n  /**\n   * Optional onBlur asynchronous validation method for when a field loses focus returns a ` FormValidationError` or a promise of `Promise<FormValidationError>`\n   */\n  onBlurAsync?: TOnBlurAsync\n  /**\n   * The default time in milliseconds that if set to a number larger than 0, will debounce the async validation event by this length of time in milliseconds.\n   */\n  onBlurAsyncDebounceMs?: number\n  onSubmit?: TOnSubmit\n  onSubmitAsync?: TOnSubmitAsync\n  onDynamic?: TOnDynamic\n  onDynamicAsync?: TOnDynamicAsync\n  onDynamicAsyncDebounceMs?: number\n}\n\n/**\n * @private\n */\nexport interface FormTransform<\n  TFormData,\n  TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnDynamic extends undefined | FormValidateOrFn<TFormData>,\n  TOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnServer extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TSubmitMeta = never,\n> {\n  fn: (\n    formBase: FormApi<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer,\n      TSubmitMeta\n    >,\n  ) => FormApi<\n    TFormData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TOnDynamic,\n    TOnDynamicAsync,\n    TOnServer,\n    TSubmitMeta\n  >\n  deps: unknown[]\n}\n\nexport interface FormListeners<\n  TFormData,\n  TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnDynamic extends undefined | FormValidateOrFn<TFormData>,\n  TOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnServer extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TSubmitMeta = never,\n> {\n  onChange?: (props: {\n    formApi: FormApi<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer,\n      TSubmitMeta\n    >\n    fieldApi: AnyFieldApi\n  }) => void\n  onChangeDebounceMs?: number\n\n  onBlur?: (props: {\n    formApi: FormApi<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer,\n      TSubmitMeta\n    >\n    fieldApi: AnyFieldApi\n  }) => void\n  onBlurDebounceMs?: number\n\n  onMount?: (props: {\n    formApi: FormApi<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer,\n      TSubmitMeta\n    >\n  }) => void\n\n  onSubmit?: (props: {\n    formApi: FormApi<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer,\n      TSubmitMeta\n    >\n    meta: TSubmitMeta\n  }) => void\n}\n\n/**\n * An object representing the base properties of a form, unrelated to any validators\n */\nexport interface BaseFormOptions<in out TFormData, in out TSubmitMeta = never> {\n  /**\n   * Set initial values for your form.\n   */\n  defaultValues?: TFormData\n  /**\n   * onSubmitMeta, the data passed from the handleSubmit handler, to the onSubmit function props\n   */\n  onSubmitMeta?: TSubmitMeta\n}\n\n/**\n * An object representing the options for a form.\n */\nexport interface FormOptions<\n  in out TFormData,\n  in out TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnDynamic extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnServer extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TSubmitMeta = never,\n> extends BaseFormOptions<TFormData, TSubmitMeta> {\n  /**\n   * The form name, used for devtools and identification\n   */\n  formId?: string\n  /**\n   * The default state for the form.\n   */\n  defaultState?: Partial<\n    FormState<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer\n    >\n  >\n  /**\n   * If true, always run async validation, even when sync validation has produced an error. Defaults to undefined.\n   */\n  asyncAlways?: boolean\n  /**\n   * Optional time in milliseconds if you want to introduce a delay before firing off an async action.\n   */\n  asyncDebounceMs?: number\n  /**\n   * If true, allows the form to be submitted in an invalid state i.e. canSubmit will remain true regardless of validation errors. Defaults to undefined.\n   */\n  canSubmitWhenInvalid?: boolean\n  /**\n   * A list of validators to pass to the form\n   */\n  validators?: FormValidators<\n    TFormData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TOnDynamic,\n    TOnDynamicAsync\n  >\n\n  validationLogic?: ValidationLogicFn\n\n  /**\n   * form level listeners\n   */\n  listeners?: FormListeners<\n    TFormData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TOnDynamic,\n    TOnDynamicAsync,\n    TOnServer,\n    TSubmitMeta\n  >\n\n  /**\n   * A function to be called when the form is submitted, what should happen once the user submits a valid form returns `any` or a promise `Promise<any>`\n   */\n  onSubmit?: (props: {\n    value: TFormData\n    formApi: FormApi<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer,\n      TSubmitMeta\n    >\n    meta: TSubmitMeta\n  }) => any | Promise<any>\n  /**\n   * Specify an action for scenarios where the user tries to submit an invalid form.\n   */\n  onSubmitInvalid?: (props: {\n    value: TFormData\n    formApi: FormApi<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer,\n      TSubmitMeta\n    >\n    meta: TSubmitMeta\n  }) => void\n  transform?: FormTransform<\n    NoInfer<TFormData>,\n    NoInfer<TOnMount>,\n    NoInfer<TOnChange>,\n    NoInfer<TOnChangeAsync>,\n    NoInfer<TOnBlur>,\n    NoInfer<TOnBlurAsync>,\n    NoInfer<TOnSubmit>,\n    NoInfer<TOnSubmitAsync>,\n    NoInfer<TOnDynamic>,\n    NoInfer<TOnDynamicAsync>,\n    NoInfer<TOnServer>,\n    NoInfer<TSubmitMeta>\n  >\n}\n\nexport type AnyFormOptions = FormOptions<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any\n>\n\n/**\n * An object representing the validation metadata for a field. Not intended for public usage.\n */\nexport type ValidationMeta = {\n  /**\n   * An abort controller stored in memory to cancel previous async validation attempts.\n   */\n  lastAbortController: AbortController\n}\n\n/**\n * An object representing the field information for a specific field within the form.\n */\nexport type FieldInfo<TFormData> = {\n  /**\n   * An instance of the FieldAPI.\n   */\n  instance: FieldApi<\n    TFormData,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any\n  > | null\n  /**\n   * A record of field validation internal handling.\n   */\n  validationMetaMap: Record<ValidationErrorMapKeys, ValidationMeta | undefined>\n}\n\n/**\n * An object representing the current state of the form.\n */\nexport type BaseFormState<\n  in out TFormData,\n  in out TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnDynamic extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnServer extends undefined | FormAsyncValidateOrFn<TFormData>,\n> = {\n  /**\n   * The current values of the form fields.\n   */\n  values: TFormData\n  /**\n   * The error map for the form itself.\n   */\n  errorMap: ValidationErrorMap<\n    UnwrapFormValidateOrFn<TOnMount>,\n    UnwrapFormValidateOrFn<TOnChange>,\n    UnwrapFormAsyncValidateOrFn<TOnChangeAsync>,\n    UnwrapFormValidateOrFn<TOnBlur>,\n    UnwrapFormAsyncValidateOrFn<TOnBlurAsync>,\n    UnwrapFormValidateOrFn<TOnSubmit>,\n    UnwrapFormAsyncValidateOrFn<TOnSubmitAsync>,\n    UnwrapFormValidateOrFn<TOnDynamic>,\n    UnwrapFormAsyncValidateOrFn<TOnDynamicAsync>,\n    UnwrapFormAsyncValidateOrFn<TOnServer>\n  >\n  /**\n   * An internal mechanism used for keeping track of validation logic in a form.\n   */\n  validationMetaMap: Record<ValidationErrorMapKeys, ValidationMeta | undefined>\n  /**\n   * A record of field metadata for each field in the form, not including the derived properties, like `errors` and such\n   */\n  fieldMetaBase: Partial<Record<DeepKeys<TFormData>, AnyFieldMetaBase>>\n  /**\n   * A boolean indicating if the form is currently in the process of being submitted after `handleSubmit` is called.\n   *\n   * Goes back to `false` when submission completes for one of the following reasons:\n   * - the validation step returned errors.\n   * - the `onSubmit` function has completed.\n   *\n   * Note: if you're running async operations in your `onSubmit` function make sure to await them to ensure `isSubmitting` is set to `false` only when the async operation completes.\n   *\n   * This is useful for displaying loading indicators or disabling form inputs during submission.\n   *\n   */\n  isSubmitting: boolean\n  /**\n   * A boolean indicating if the `onSubmit` function has completed successfully.\n   *\n   * Goes back to `false` at each new submission attempt.\n   *\n   * Note: you can use isSubmitting to check if the form is currently submitting.\n   */\n  isSubmitted: boolean\n  /**\n   * A boolean indicating if the form or any of its fields are currently validating.\n   */\n  isValidating: boolean\n  /**\n   * A counter for tracking the number of submission attempts.\n   */\n  submissionAttempts: number\n  /**\n   * A boolean indicating if the last submission was successful.\n   */\n  isSubmitSuccessful: boolean\n  /**\n   * @private, used to force a re-evaluation of the form state when options change\n   */\n  _force_re_eval?: boolean\n}\n\nexport type DerivedFormState<\n  in out TFormData,\n  in out TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnDynamic extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnServer extends undefined | FormAsyncValidateOrFn<TFormData>,\n> = {\n  /**\n   * A boolean indicating if the form is currently validating.\n   */\n  isFormValidating: boolean\n  /**\n   * A boolean indicating if the form is valid.\n   */\n  isFormValid: boolean\n  /**\n   * The error array for the form itself.\n   */\n  errors: Array<\n    | UnwrapFormValidateOrFn<TOnMount>\n    | UnwrapFormValidateOrFn<TOnChange>\n    | UnwrapFormAsyncValidateOrFn<TOnChangeAsync>\n    | UnwrapFormValidateOrFn<TOnBlur>\n    | UnwrapFormAsyncValidateOrFn<TOnBlurAsync>\n    | UnwrapFormValidateOrFn<TOnSubmit>\n    | UnwrapFormAsyncValidateOrFn<TOnSubmitAsync>\n    | UnwrapFormValidateOrFn<TOnDynamic>\n    | UnwrapFormAsyncValidateOrFn<TOnDynamicAsync>\n    | UnwrapFormAsyncValidateOrFn<TOnServer>\n  >\n  /**\n   * A boolean indicating if any of the form fields are currently validating.\n   */\n  isFieldsValidating: boolean\n  /**\n   * A boolean indicating if all the form fields are valid. Evaluates `true` if there are no field errors.\n   */\n  isFieldsValid: boolean\n  /**\n   * A boolean indicating if any of the form fields have been touched.\n   */\n  isTouched: boolean\n  /**\n   * A boolean indicating if any of the form fields have been blurred.\n   */\n  isBlurred: boolean\n  /**\n   * A boolean indicating if any of the form's fields' values have been modified by the user. Evaluates `true` if the user have modified at least one of the fields. Opposite of `isPristine`.\n   */\n  isDirty: boolean\n  /**\n   * A boolean indicating if none of the form's fields' values have been modified by the user. Evaluates `true` if the user have not modified any of the fields. Opposite of `isDirty`.\n   */\n  isPristine: boolean\n  /**\n   * A boolean indicating if all of the form's fields are the same as default values.\n   */\n  isDefaultValue: boolean\n  /**\n   * A boolean indicating if the form and all its fields are valid. Evaluates `true` if there are no errors.\n   */\n  isValid: boolean\n  /**\n   * A boolean indicating if the form can be submitted based on its current state.\n   */\n  canSubmit: boolean\n  /**\n   * A record of field metadata for each field in the form.\n   */\n  fieldMeta: Partial<Record<DeepKeys<TFormData>, AnyFieldMeta>>\n}\n\nexport interface FormState<\n  in out TFormData,\n  in out TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnDynamic extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnServer extends undefined | FormAsyncValidateOrFn<TFormData>,\n>\n  extends\n    BaseFormState<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer\n    >,\n    DerivedFormState<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer\n    > {}\n\nexport type AnyFormState = FormState<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any\n>\n\nfunction getDefaultFormState<\n  TFormData,\n  TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnDynamic extends undefined | FormValidateOrFn<TFormData>,\n  TOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnServer extends undefined | FormAsyncValidateOrFn<TFormData>,\n>(\n  defaultState: Partial<\n    FormState<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer\n    >\n  >,\n): BaseFormState<\n  TFormData,\n  TOnMount,\n  TOnChange,\n  TOnChangeAsync,\n  TOnBlur,\n  TOnBlurAsync,\n  TOnSubmit,\n  TOnSubmitAsync,\n  TOnDynamic,\n  TOnDynamicAsync,\n  TOnServer\n> {\n  return {\n    values: defaultState.values ?? ({} as never),\n    errorMap: defaultState.errorMap ?? {},\n    fieldMetaBase: defaultState.fieldMetaBase ?? ({} as never),\n    isSubmitted: defaultState.isSubmitted ?? false,\n    isSubmitting: defaultState.isSubmitting ?? false,\n    isValidating: defaultState.isValidating ?? false,\n    submissionAttempts: defaultState.submissionAttempts ?? 0,\n    isSubmitSuccessful: defaultState.isSubmitSuccessful ?? false,\n    validationMetaMap: defaultState.validationMetaMap ?? {\n      onChange: undefined,\n      onBlur: undefined,\n      onSubmit: undefined,\n      onMount: undefined,\n      onServer: undefined,\n      onDynamic: undefined,\n    },\n  }\n}\n\n/**\n * @public\n *\n * A type representing the Form API with all generics set to `any` for convenience.\n */\nexport type AnyFormApi = FormApi<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any\n>\n\n/**\n * We cannot use methods and must use arrow functions. Otherwise, our React adapters\n * will break due to loss of the method when using spread.\n */\n\n/**\n * A class representing the Form API. It handles the logic and interactions with the form state.\n *\n * Normally, you will not need to create a new `FormApi` instance directly. Instead, you will use a framework\n * hook/function like `useForm` or `createForm` to create a new instance for you that uses your framework's reactivity model.\n * However, if you need to create a new instance manually, you can do so by calling the `new FormApi` constructor.\n */\nexport class FormApi<\n  in out TFormData,\n  in out TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnDynamic extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnServer extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TSubmitMeta = never,\n> implements FieldManipulator<TFormData, TSubmitMeta> {\n  /**\n   * The options for the form.\n   */\n  options: FormOptions<\n    TFormData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TOnDynamic,\n    TOnDynamicAsync,\n    TOnServer,\n    TSubmitMeta\n  > = {}\n  baseStore!: Store<\n    BaseFormState<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer\n    >\n  >\n  fieldMetaDerived: Derived<\n    FormState<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer\n    >['fieldMeta']\n  >\n  store: Derived<\n    FormState<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer\n    >\n  >\n  /**\n   * A record of field information for each field in the form.\n   */\n  fieldInfo: Record<DeepKeys<TFormData>, FieldInfo<TFormData>> = {} as any\n\n  get state() {\n    return this.store.state\n  }\n\n  /**\n   * @private\n   */\n  prevTransformArray: unknown[] = []\n\n  /**\n   * @private\n   */\n  timeoutIds: {\n    validations: Record<ValidationCause, ReturnType<typeof setTimeout> | null>\n    listeners: Record<ListenerCause, ReturnType<typeof setTimeout> | null>\n    formListeners: Record<ListenerCause, ReturnType<typeof setTimeout> | null>\n  }\n  /**\n   * @private\n   */\n  _formId: string\n  /**\n   * @private\n   */\n  private _devtoolsSubmissionOverride: boolean\n\n  /**\n   * Constructs a new `FormApi` instance with the given form options.\n   */\n  constructor(\n    opts?: FormOptions<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer,\n      TSubmitMeta\n    >,\n  ) {\n    this.timeoutIds = {\n      validations: {} as Record<ValidationCause, never>,\n      listeners: {} as Record<ListenerCause, never>,\n      formListeners: {} as Record<ListenerCause, never>,\n    }\n\n    this._formId = opts?.formId ?? uuid()\n\n    this._devtoolsSubmissionOverride = false\n\n    this.baseStore = new Store(\n      getDefaultFormState({\n        ...(opts?.defaultState as any),\n        values: opts?.defaultValues ?? opts?.defaultState?.values,\n        isFormValid: true,\n      }),\n    )\n\n    this.fieldMetaDerived = new Derived({\n      deps: [this.baseStore],\n      fn: ({ prevDepVals, currDepVals, prevVal: _prevVal }) => {\n        const prevVal = _prevVal as\n          | Record<DeepKeys<TFormData>, AnyFieldMeta>\n          | undefined\n        const prevBaseStore = prevDepVals?.[0]\n        const currBaseStore = currDepVals[0]\n\n        let originalMetaCount = 0\n\n        const fieldMeta: FormState<\n          TFormData,\n          TOnMount,\n          TOnChange,\n          TOnChangeAsync,\n          TOnBlur,\n          TOnBlurAsync,\n          TOnSubmit,\n          TOnSubmitAsync,\n          TOnDynamic,\n          TOnDynamicAsync,\n          TOnServer\n        >['fieldMeta'] = {}\n\n        for (const fieldName of Object.keys(\n          currBaseStore.fieldMetaBase,\n        ) as Array<keyof typeof currBaseStore.fieldMetaBase>) {\n          const currBaseMeta = currBaseStore.fieldMetaBase[\n            fieldName as never\n          ] as AnyFieldMetaBase\n\n          const prevBaseMeta = prevBaseStore?.fieldMetaBase[\n            fieldName as never\n          ] as AnyFieldMetaBase | undefined\n\n          const prevFieldInfo =\n            prevVal?.[fieldName as never as keyof typeof prevVal]\n\n          const curFieldVal = getBy(currBaseStore.values, fieldName)\n\n          let fieldErrors = prevFieldInfo?.errors\n          if (\n            !prevBaseMeta ||\n            currBaseMeta.errorMap !== prevBaseMeta.errorMap\n          ) {\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            fieldErrors = Object.values(currBaseMeta.errorMap ?? {}).filter(\n              (val) => val !== undefined,\n            )\n\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            const fieldInstance = this.getFieldInfo(fieldName)?.instance\n\n            if (fieldInstance && !fieldInstance.options.disableErrorFlat) {\n              fieldErrors = fieldErrors.flat(1)\n            }\n          }\n\n          // As primitives, we don't need to aggressively persist the same referential value for performance reasons\n          const isFieldValid = !isNonEmptyArray(fieldErrors)\n          const isFieldPristine = !currBaseMeta.isDirty\n          const isDefaultValue =\n            evaluate(\n              curFieldVal,\n              getBy(this.options.defaultValues, fieldName),\n            ) ||\n            evaluate(\n              curFieldVal,\n              // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n              this.getFieldInfo(fieldName)?.instance?.options.defaultValue,\n            )\n\n          if (\n            prevFieldInfo &&\n            prevFieldInfo.isPristine === isFieldPristine &&\n            prevFieldInfo.isValid === isFieldValid &&\n            prevFieldInfo.isDefaultValue === isDefaultValue &&\n            prevFieldInfo.errors === fieldErrors &&\n            currBaseMeta === prevBaseMeta\n          ) {\n            fieldMeta[fieldName] = prevFieldInfo\n            originalMetaCount++\n            continue\n          }\n\n          fieldMeta[fieldName] = {\n            ...currBaseMeta,\n            errors: fieldErrors ?? [],\n            isPristine: isFieldPristine,\n            isValid: isFieldValid,\n            isDefaultValue: isDefaultValue,\n          } satisfies AnyFieldMeta as AnyFieldMeta\n        }\n\n        if (!Object.keys(currBaseStore.fieldMetaBase).length) return fieldMeta\n\n        if (\n          prevVal &&\n          originalMetaCount === Object.keys(currBaseStore.fieldMetaBase).length\n        ) {\n          return prevVal\n        }\n\n        return fieldMeta\n      },\n    })\n\n    this.store = new Derived({\n      deps: [this.baseStore, this.fieldMetaDerived],\n      fn: ({ prevDepVals, currDepVals, prevVal: _prevVal }) => {\n        const prevVal = _prevVal as\n          | FormState<\n              TFormData,\n              TOnMount,\n              TOnChange,\n              TOnChangeAsync,\n              TOnBlur,\n              TOnBlurAsync,\n              TOnSubmit,\n              TOnSubmitAsync,\n              TOnDynamic,\n              TOnDynamicAsync,\n              TOnServer\n            >\n          | undefined\n        const prevBaseStore = prevDepVals?.[0]\n        const currBaseStore = currDepVals[0]\n        const currFieldMeta = currDepVals[1]\n\n        // Computed state\n        const fieldMetaValues = Object.values(currFieldMeta).filter(\n          Boolean,\n        ) as AnyFieldMeta[]\n\n        const isFieldsValidating = fieldMetaValues.some(\n          (field) => field.isValidating,\n        )\n\n        const isFieldsValid = fieldMetaValues.every((field) => field.isValid)\n\n        const isTouched = fieldMetaValues.some((field) => field.isTouched)\n        const isBlurred = fieldMetaValues.some((field) => field.isBlurred)\n        const isDefaultValue = fieldMetaValues.every(\n          (field) => field.isDefaultValue,\n        )\n\n        const shouldInvalidateOnMount =\n          // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n          isTouched && currBaseStore.errorMap?.onMount\n\n        const isDirty = fieldMetaValues.some((field) => field.isDirty)\n        const isPristine = !isDirty\n\n        const hasOnMountError = Boolean(\n          // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n          currBaseStore.errorMap?.onMount ||\n          // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n          fieldMetaValues.some((f) => f?.errorMap?.onMount),\n        )\n\n        const isValidating = !!isFieldsValidating\n\n        // As `errors` is not a primitive, we need to aggressively persist the same referencial value for performance reasons\n        let errors = prevVal?.errors ?? []\n        if (\n          !prevBaseStore ||\n          currBaseStore.errorMap !== prevBaseStore.errorMap\n        ) {\n          errors = Object.values(currBaseStore.errorMap).reduce<\n            Array<\n              | UnwrapFormValidateOrFn<TOnMount>\n              | UnwrapFormValidateOrFn<TOnChange>\n              | UnwrapFormAsyncValidateOrFn<TOnChangeAsync>\n              | UnwrapFormValidateOrFn<TOnBlur>\n              | UnwrapFormAsyncValidateOrFn<TOnBlurAsync>\n              | UnwrapFormValidateOrFn<TOnSubmit>\n              | UnwrapFormAsyncValidateOrFn<TOnSubmitAsync>\n              | UnwrapFormAsyncValidateOrFn<TOnServer>\n            >\n          >((prev, curr) => {\n            if (curr === undefined) return prev\n\n            if (curr && isGlobalFormValidationError(curr)) {\n              prev.push(curr.form as never)\n              return prev\n            }\n            prev.push(curr as never)\n            return prev\n          }, [])\n        }\n\n        const isFormValid = errors.length === 0\n        const isValid = isFieldsValid && isFormValid\n        const submitInvalid = this.options.canSubmitWhenInvalid ?? false\n        const canSubmit =\n          (currBaseStore.submissionAttempts === 0 &&\n            !isTouched &&\n            !hasOnMountError) ||\n          (!isValidating && !currBaseStore.isSubmitting && isValid) ||\n          submitInvalid\n\n        let errorMap = currBaseStore.errorMap\n        if (shouldInvalidateOnMount) {\n          errors = errors.filter(\n            (err) => err !== currBaseStore.errorMap.onMount,\n          )\n          errorMap = Object.assign(errorMap, { onMount: undefined })\n        }\n\n        if (\n          prevVal &&\n          prevBaseStore &&\n          prevVal.errorMap === errorMap &&\n          prevVal.fieldMeta === this.fieldMetaDerived.state &&\n          prevVal.errors === errors &&\n          prevVal.isFieldsValidating === isFieldsValidating &&\n          prevVal.isFieldsValid === isFieldsValid &&\n          prevVal.isFormValid === isFormValid &&\n          prevVal.isValid === isValid &&\n          prevVal.canSubmit === canSubmit &&\n          prevVal.isTouched === isTouched &&\n          prevVal.isBlurred === isBlurred &&\n          prevVal.isPristine === isPristine &&\n          prevVal.isDefaultValue === isDefaultValue &&\n          prevVal.isDirty === isDirty &&\n          evaluate(prevBaseStore, currBaseStore)\n        ) {\n          return prevVal\n        }\n\n        let state = {\n          ...currBaseStore,\n          errorMap,\n          fieldMeta: this.fieldMetaDerived.state,\n          errors,\n          isFieldsValidating,\n          isFieldsValid,\n          isFormValid,\n          isValid,\n          canSubmit,\n          isTouched,\n          isBlurred,\n          isPristine,\n          isDefaultValue,\n          isDirty,\n        } as FormState<\n          TFormData,\n          TOnMount,\n          TOnChange,\n          TOnChangeAsync,\n          TOnBlur,\n          TOnBlurAsync,\n          TOnSubmit,\n          TOnSubmitAsync,\n          TOnDynamic,\n          TOnDynamicAsync,\n          TOnServer\n        >\n\n        // Only run transform if state has shallowly changed - IE how React.useEffect works\n        const transformArray = this.options.transform?.deps ?? []\n        const shouldTransform =\n          transformArray.length !== this.prevTransformArray.length ||\n          transformArray.some((val, i) => val !== this.prevTransformArray[i])\n\n        if (shouldTransform) {\n          const newObj = Object.assign({}, this, { state })\n          // This mutates the state\n          this.options.transform?.fn(newObj)\n          state = newObj.state\n          this.prevTransformArray = transformArray\n        }\n\n        return state\n      },\n    })\n\n    this.handleSubmit = this.handleSubmit.bind(this)\n\n    this.update(opts || {})\n\n    // devtool broadcasts\n    this.store.subscribe(() => {\n      throttleFormState(this)\n    })\n\n    // devtool requests\n    formEventClient.on('request-form-state', (e) => {\n      if (e.payload.id === this._formId) {\n        formEventClient.emit('form-api', {\n          id: this._formId,\n          state: this.store.state,\n          options: this.options,\n        })\n      }\n    })\n\n    formEventClient.on('request-form-reset', (e) => {\n      if (e.payload.id === this._formId) {\n        this.reset()\n      }\n    })\n\n    formEventClient.on('request-form-force-submit', (e) => {\n      if (e.payload.id === this._formId) {\n        this._devtoolsSubmissionOverride = true\n        this.handleSubmit()\n        this._devtoolsSubmissionOverride = false\n      }\n    })\n  }\n\n  get formId(): string {\n    return this._formId\n  }\n\n  /**\n   * @private\n   */\n  runValidator<\n    TValue extends TStandardSchemaValidatorValue<TFormData> & {\n      formApi: AnyFormApi\n    },\n    TType extends 'validate' | 'validateAsync',\n  >(props: {\n    validate: TType extends 'validate'\n      ? FormValidateOrFn<TFormData>\n      : FormAsyncValidateOrFn<TFormData>\n    value: TValue\n    type: TType\n  }): unknown {\n    if (isStandardSchemaValidator(props.validate)) {\n      return standardSchemaValidators[props.type](\n        props.value,\n        props.validate,\n      ) as never\n    }\n\n    return (props.validate as FormValidateFn<any>)(props.value) as never\n  }\n\n  mount = () => {\n    const cleanupFieldMetaDerived = this.fieldMetaDerived.mount()\n    const cleanupStoreDerived = this.store.mount()\n    const cleanup = () => {\n      cleanupFieldMetaDerived()\n      cleanupStoreDerived()\n\n      // broadcast form unmount for devtools\n      formEventClient.emit('form-unmounted', {\n        id: this._formId,\n      })\n    }\n\n    this.options.listeners?.onMount?.({ formApi: this })\n\n    const { onMount } = this.options.validators || {}\n\n    // broadcast form state for devtools on mounting\n    formEventClient.emit('form-api', {\n      id: this._formId,\n      state: this.store.state,\n      options: this.options,\n    })\n\n    // if no validation skip\n    if (!onMount) return cleanup\n\n    // validate\n    this.validateSync('mount')\n    return cleanup\n  }\n\n  /**\n   * Updates the form options and form state.\n   */\n  update = (\n    options?: FormOptions<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer,\n      TSubmitMeta\n    >,\n  ) => {\n    if (!options) return\n\n    const oldOptions = this.options\n\n    // Options need to be updated first so that when the store is updated, the state is correct for the derived state\n    this.options = options\n\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    const shouldUpdateReeval = !!options.transform?.deps?.some(\n      (val, i) => val !== this.prevTransformArray[i],\n    )\n\n    const shouldUpdateValues =\n      options.defaultValues &&\n      !evaluate(options.defaultValues, oldOptions.defaultValues) &&\n      !this.state.isTouched\n\n    const shouldUpdateState =\n      !evaluate(options.defaultState, oldOptions.defaultState) &&\n      !this.state.isTouched\n\n    if (!shouldUpdateValues && !shouldUpdateState && !shouldUpdateReeval) return\n\n    batch(() => {\n      this.baseStore.setState(() =>\n        getDefaultFormState(\n          Object.assign(\n            {},\n            this.state as any,\n\n            shouldUpdateState ? options.defaultState : {},\n\n            shouldUpdateValues\n              ? {\n                  values: options.defaultValues,\n                }\n              : {},\n\n            shouldUpdateReeval\n              ? { _force_re_eval: !this.state._force_re_eval }\n              : {},\n          ),\n        ),\n      )\n    })\n\n    formEventClient.emit('form-api', {\n      id: this._formId,\n      state: this.store.state,\n      options: this.options,\n    })\n  }\n\n  /**\n   * Resets the form state to the default values.\n   * If values are provided, the form will be reset to those values instead and the default values will be updated.\n   *\n   * @param values - Optional values to reset the form to.\n   * @param opts - Optional options to control the reset behavior.\n   */\n  reset = (values?: TFormData, opts?: { keepDefaultValues?: boolean }) => {\n    const { fieldMeta: currentFieldMeta } = this.state\n    const fieldMetaBase = this.resetFieldMeta(currentFieldMeta)\n\n    if (values && !opts?.keepDefaultValues) {\n      this.options = {\n        ...this.options,\n        defaultValues: values,\n      }\n    }\n\n    this.baseStore.setState(() =>\n      getDefaultFormState({\n        ...(this.options.defaultState as any),\n        values:\n          values ??\n          this.options.defaultValues ??\n          this.options.defaultState?.values,\n        fieldMetaBase,\n      }),\n    )\n  }\n\n  /**\n   * Validates all fields using the correct handlers for a given validation cause.\n   */\n  validateAllFields = async (cause: ValidationCause) => {\n    const fieldValidationPromises: Promise<ValidationError[]>[] = [] as any\n    batch(() => {\n      void (Object.values(this.fieldInfo) as FieldInfo<any>[]).forEach(\n        (field) => {\n          if (!field.instance) return\n          const fieldInstance = field.instance\n          // Validate the field\n          fieldValidationPromises.push(\n            // Remember, `validate` is either a sync operation or a promise\n            Promise.resolve().then(() =>\n              fieldInstance.validate(cause, { skipFormValidation: true }),\n            ),\n          )\n          // If any fields are not touched\n          if (!field.instance.state.meta.isTouched) {\n            // Mark them as touched\n            field.instance.setMeta((prev) => ({ ...prev, isTouched: true }))\n          }\n        },\n      )\n    })\n\n    const fieldErrorMapMap = await Promise.all(fieldValidationPromises)\n    return fieldErrorMapMap.flat()\n  }\n\n  /**\n   * Validates the children of a specified array in the form starting from a given index until the end using the correct handlers for a given validation type.\n   */\n  validateArrayFieldsStartingFrom = async <\n    TField extends DeepKeysOfType<TFormData, any[]>,\n  >(\n    field: TField,\n    index: number,\n    cause: ValidationCause,\n  ) => {\n    const currentValue = this.getFieldValue(field)\n\n    const lastIndex = Array.isArray(currentValue)\n      ? Math.max((currentValue as Array<unknown>).length - 1, 0)\n      : null\n\n    // We have to validate all fields that have shifted (at least the current field)\n    const fieldKeysToValidate = [`${field}[${index}]`]\n    for (let i = index + 1; i <= (lastIndex ?? 0); i++) {\n      fieldKeysToValidate.push(`${field}[${i}]`)\n    }\n\n    // We also have to include all fields that are nested in the shifted fields\n    const fieldsToValidate = Object.keys(this.fieldInfo).filter((fieldKey) =>\n      fieldKeysToValidate.some((key) => fieldKey.startsWith(key)),\n    ) as DeepKeys<TFormData>[]\n\n    // Validate the fields\n    const fieldValidationPromises: Promise<ValidationError[]>[] = [] as any\n    batch(() => {\n      fieldsToValidate.forEach((nestedField) => {\n        fieldValidationPromises.push(\n          Promise.resolve().then(() => this.validateField(nestedField, cause)),\n        )\n      })\n    })\n\n    const fieldErrorMapMap = await Promise.all(fieldValidationPromises)\n    return fieldErrorMapMap.flat()\n  }\n\n  /**\n   * Validates a specified field in the form using the correct handlers for a given validation type.\n   */\n  validateField = <TField extends DeepKeys<TFormData>>(\n    field: TField,\n    cause: ValidationCause,\n  ) => {\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    const fieldInstance = this.fieldInfo[field]?.instance\n    if (!fieldInstance) return []\n\n    // If the field is not touched (same logic as in validateAllFields)\n    if (!fieldInstance.state.meta.isTouched) {\n      // Mark it as touched\n      fieldInstance.setMeta((prev) => ({ ...prev, isTouched: true }))\n    }\n\n    return fieldInstance.validate(cause)\n  }\n\n  /**\n   * TODO: This code is copied from FieldApi, we should refactor to share\n   * @private\n   */\n  validateSync = (\n    cause: ValidationCause,\n  ): {\n    hasErrored: boolean\n    fieldsErrorMap: FormErrorMapFromValidator<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync\n    >\n  } => {\n    const validates = getSyncValidatorArray(cause, {\n      ...this.options,\n      form: this,\n      validationLogic: this.options.validationLogic || defaultValidationLogic,\n    })\n\n    let hasErrored = false as boolean\n\n    // This map will only include fields that have errors in the current validation cycle\n    const currentValidationErrorMap: FormErrorMapFromValidator<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync\n    > = {}\n\n    batch(() => {\n      for (const validateObj of validates) {\n        if (!validateObj.validate) continue\n\n        const rawError = this.runValidator({\n          validate: validateObj.validate,\n          value: {\n            value: this.state.values,\n            formApi: this,\n            validationSource: 'form',\n          },\n          type: 'validate',\n        })\n\n        const { formError, fieldErrors } = normalizeError<TFormData>(rawError)\n\n        const errorMapKey = getErrorMapKey(validateObj.cause)\n\n        for (const field of Object.keys(\n          this.state.fieldMeta,\n        ) as DeepKeys<TFormData>[]) {\n          if (this.baseStore.state.fieldMetaBase[field] === undefined) {\n            continue\n          }\n\n          const fieldMeta = this.getFieldMeta(field)\n          if (!fieldMeta) continue\n\n          const {\n            errorMap: currentErrorMap,\n            errorSourceMap: currentErrorMapSource,\n          } = fieldMeta\n\n          const newFormValidatorError = fieldErrors?.[field]\n\n          const { newErrorValue, newSource } =\n            determineFormLevelErrorSourceAndValue({\n              newFormValidatorError,\n              isPreviousErrorFromFormValidator:\n                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n                currentErrorMapSource?.[errorMapKey] === 'form',\n              // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n              previousErrorValue: currentErrorMap?.[errorMapKey],\n            })\n\n          if (newSource === 'form') {\n            currentValidationErrorMap[field] = {\n              ...currentValidationErrorMap[field],\n              [errorMapKey]: newFormValidatorError,\n            }\n          }\n\n          if (\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            currentErrorMap?.[errorMapKey] !== newErrorValue\n          ) {\n            this.setFieldMeta(field, (prev) => ({\n              ...prev,\n              errorMap: {\n                ...prev.errorMap,\n                [errorMapKey]: newErrorValue,\n              },\n              errorSourceMap: {\n                ...prev.errorSourceMap,\n                [errorMapKey]: newSource,\n              },\n            }))\n          }\n        }\n\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (this.state.errorMap?.[errorMapKey] !== formError) {\n          this.baseStore.setState((prev) => ({\n            ...prev,\n            errorMap: {\n              ...prev.errorMap,\n              [errorMapKey]: formError,\n            },\n          }))\n        }\n\n        if (formError || fieldErrors) {\n          hasErrored = true\n        }\n      }\n\n      /**\n       *  when we have an error for onSubmit in the state, we want\n       *  to clear the error as soon as the user enters a valid value in the field\n       */\n      const submitErrKey = getErrorMapKey('submit')\n      if (\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        this.state.errorMap?.[submitErrKey] &&\n        cause !== 'submit' &&\n        !hasErrored\n      ) {\n        this.baseStore.setState((prev) => ({\n          ...prev,\n          errorMap: {\n            ...prev.errorMap,\n            [submitErrKey]: undefined,\n          },\n        }))\n      }\n\n      /**\n       * Clear field-level onSubmit errors when validation passes on non-submit events\n       * This fixes bug #1874 where old submit errors prevented re-validation\n       */\n      if (cause !== 'submit' && !hasErrored) {\n        for (const field of Object.keys(\n          this.state.fieldMeta,\n        ) as DeepKeys<TFormData>[]) {\n          const fieldMeta = this.getFieldMeta(field)\n          if (\n            fieldMeta &&\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            fieldMeta.errorMap?.[submitErrKey] !== undefined &&\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            fieldMeta.errorSourceMap?.[submitErrKey] === 'form'\n          ) {\n            this.setFieldMeta(field, (prev) => ({\n              ...prev,\n              errorMap: {\n                ...prev.errorMap,\n                [submitErrKey]: undefined,\n              },\n              errorSourceMap: {\n                ...prev.errorSourceMap,\n                [submitErrKey]: undefined,\n              },\n            }))\n          }\n        }\n      }\n\n      /**\n       *  when we have an error for onServer in the state, we want\n       *  to clear the error as soon as the user enters a valid value in the field\n       */\n      const serverErrKey = getErrorMapKey('server')\n      if (\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        this.state.errorMap?.[serverErrKey] &&\n        cause !== 'server' &&\n        !hasErrored\n      ) {\n        this.baseStore.setState((prev) => ({\n          ...prev,\n          errorMap: {\n            ...prev.errorMap,\n            [serverErrKey]: undefined,\n          },\n        }))\n      }\n\n      /**\n      * Clear field-level onServer errors when validation passes on non-server events\n      * This fixes bug #1874 where old server errors prevented re-validation\n      */\n      if (cause !== 'server' && !hasErrored) {\n        for (const field of Object.keys(\n          this.state.fieldMeta,\n        ) as DeepKeys<TFormData>[]) {\n          const fieldMeta = this.getFieldMeta(field)\n          if (\n            fieldMeta &&\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            fieldMeta.errorMap?.[serverErrKey] !== undefined &&\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            fieldMeta.errorSourceMap?.[serverErrKey] === 'form'\n          ) {\n            this.setFieldMeta(field, (prev) => ({\n              ...prev,\n              errorMap: {\n                ...prev.errorMap,\n                [serverErrKey]: undefined,\n              },\n              errorSourceMap: {\n                ...prev.errorSourceMap,\n                [serverErrKey]: undefined,\n              },\n            }))\n          }\n        }\n      }\n    })\n\n    return { hasErrored, fieldsErrorMap: currentValidationErrorMap }\n  }\n\n  /**\n   * @private\n   */\n  validateAsync = async (\n    cause: ValidationCause,\n  ): Promise<\n    FormErrorMapFromValidator<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync\n    >\n  > => {\n    const validates = getAsyncValidatorArray(cause, {\n      ...this.options,\n      form: this,\n      validationLogic: this.options.validationLogic || defaultValidationLogic,\n    })\n\n    if (!this.state.isFormValidating) {\n      this.baseStore.setState((prev) => ({ ...prev, isFormValidating: true }))\n    }\n\n    /**\n     * We have to use a for loop and generate our promises this way, otherwise it won't be sync\n     * when there are no validators needed to be run\n     */\n    const promises: Promise<ValidationPromiseResult<TFormData>>[] = []\n\n    let fieldErrorsFromFormValidators:\n      | Partial<Record<DeepKeys<TFormData>, ValidationError>>\n      | undefined\n\n    for (const validateObj of validates) {\n      if (!validateObj.validate) continue\n      const key = getErrorMapKey(validateObj.cause)\n      const fieldValidatorMeta = this.state.validationMetaMap[key]\n\n      fieldValidatorMeta?.lastAbortController.abort()\n      const controller = new AbortController()\n\n      this.state.validationMetaMap[key] = {\n        lastAbortController: controller,\n      }\n\n      promises.push(\n        new Promise<ValidationPromiseResult<TFormData>>(async (resolve) => {\n          let rawError!:\n            | ValidationError\n            | FormValidationError<unknown>\n            | undefined\n          try {\n            rawError = await new Promise((rawResolve, rawReject) => {\n              setTimeout(async () => {\n                if (controller.signal.aborted) return rawResolve(undefined)\n                try {\n                  rawResolve(\n                    await this.runValidator({\n                      validate: validateObj.validate!,\n                      value: {\n                        value: this.state.values,\n                        formApi: this,\n                        validationSource: 'form',\n                        signal: controller.signal,\n                      },\n                      type: 'validateAsync',\n                    }),\n                  )\n                } catch (e) {\n                  rawReject(e)\n                }\n              }, validateObj.debounceMs)\n            })\n          } catch (e: unknown) {\n            rawError = e as ValidationError\n          }\n          const { formError, fieldErrors: fieldErrorsFromNormalizeError } =\n            normalizeError<TFormData>(rawError)\n\n          if (fieldErrorsFromNormalizeError) {\n            fieldErrorsFromFormValidators = fieldErrorsFromFormValidators\n              ? {\n                  ...fieldErrorsFromFormValidators,\n                  ...fieldErrorsFromNormalizeError,\n                }\n              : fieldErrorsFromNormalizeError\n          }\n          const errorMapKey = getErrorMapKey(validateObj.cause)\n\n          for (const field of Object.keys(\n            this.state.fieldMeta,\n          ) as DeepKeys<TFormData>[]) {\n            if (this.baseStore.state.fieldMetaBase[field] === undefined) {\n              continue\n            }\n\n            const fieldMeta = this.getFieldMeta(field)\n            if (!fieldMeta) continue\n\n            const {\n              errorMap: currentErrorMap,\n              errorSourceMap: currentErrorMapSource,\n            } = fieldMeta\n\n            const newFormValidatorError = fieldErrorsFromFormValidators?.[field]\n\n            const { newErrorValue, newSource } =\n              determineFormLevelErrorSourceAndValue({\n                newFormValidatorError,\n                isPreviousErrorFromFormValidator:\n                  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n                  currentErrorMapSource?.[errorMapKey] === 'form',\n                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n                previousErrorValue: currentErrorMap?.[errorMapKey],\n              })\n\n            if (\n              // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n              currentErrorMap?.[errorMapKey] !== newErrorValue\n            ) {\n              this.setFieldMeta(field, (prev) => ({\n                ...prev,\n                errorMap: {\n                  ...prev.errorMap,\n                  [errorMapKey]: newErrorValue,\n                },\n                errorSourceMap: {\n                  ...prev.errorSourceMap,\n                  [errorMapKey]: newSource,\n                },\n              }))\n            }\n          }\n\n          this.baseStore.setState((prev) => ({\n            ...prev,\n            errorMap: {\n              ...prev.errorMap,\n              [errorMapKey]: formError,\n            },\n          }))\n\n          resolve(\n            fieldErrorsFromFormValidators\n              ? { fieldErrors: fieldErrorsFromFormValidators, errorMapKey }\n              : undefined,\n          )\n        }),\n      )\n    }\n\n    let results: ValidationPromiseResult<TFormData>[] = []\n\n    const fieldsErrorMap: FormErrorMapFromValidator<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync\n    > = {}\n    if (promises.length) {\n      results = await Promise.all(promises)\n      for (const fieldValidationResult of results) {\n        if (fieldValidationResult?.fieldErrors) {\n          const { errorMapKey } = fieldValidationResult\n\n          for (const [field, fieldError] of Object.entries(\n            fieldValidationResult.fieldErrors,\n          )) {\n            const oldErrorMap =\n              fieldsErrorMap[field as DeepKeys<TFormData>] || {}\n            const newErrorMap = {\n              ...oldErrorMap,\n              [errorMapKey]: fieldError,\n            }\n            fieldsErrorMap[field as DeepKeys<TFormData>] = newErrorMap\n          }\n        }\n      }\n    }\n\n    this.baseStore.setState((prev) => ({\n      ...prev,\n      isFormValidating: false,\n    }))\n\n    return fieldsErrorMap\n  }\n\n  /**\n   * @private\n   */\n  validate = (\n    cause: ValidationCause,\n  ):\n    | FormErrorMapFromValidator<\n        TFormData,\n        TOnMount,\n        TOnChange,\n        TOnChangeAsync,\n        TOnBlur,\n        TOnBlurAsync,\n        TOnSubmit,\n        TOnSubmitAsync,\n        TOnDynamic,\n        TOnDynamicAsync\n      >\n    | Promise<\n        FormErrorMapFromValidator<\n          TFormData,\n          TOnMount,\n          TOnChange,\n          TOnChangeAsync,\n          TOnBlur,\n          TOnBlurAsync,\n          TOnSubmit,\n          TOnSubmitAsync,\n          TOnDynamic,\n          TOnDynamicAsync\n        >\n      > => {\n    // Attempt to sync validate first\n    const { hasErrored, fieldsErrorMap } = this.validateSync(cause)\n\n    if (hasErrored && !this.options.asyncAlways) {\n      return fieldsErrorMap\n    }\n\n    // No error? Attempt async validation\n    return this.validateAsync(cause)\n  }\n\n  // Needs to edgecase in the React adapter specifically to avoid type errors\n  handleSubmit(): Promise<void>\n  handleSubmit(submitMeta: TSubmitMeta): Promise<void>\n  handleSubmit(submitMeta?: TSubmitMeta): Promise<void> {\n    return this._handleSubmit(submitMeta)\n  }\n\n  /**\n   * Handles the form submission, performs validation, and calls the appropriate onSubmit or onSubmitInvalid callbacks.\n   */\n  _handleSubmit = async (submitMeta?: TSubmitMeta): Promise<void> => {\n    this.baseStore.setState((old) => ({\n      ...old,\n      // Submission attempts mark the form as not submitted\n      isSubmitted: false,\n      // Count submission attempts\n      submissionAttempts: old.submissionAttempts + 1,\n      isSubmitSuccessful: false, // Reset isSubmitSuccessful at the start of submission\n    }))\n\n    batch(() => {\n      void (Object.values(this.fieldInfo) as FieldInfo<any>[]).forEach(\n        (field) => {\n          if (!field.instance) return\n          // If any fields are not touched\n          if (!field.instance.state.meta.isTouched) {\n            // Mark them as touched\n            field.instance.setMeta((prev) => ({ ...prev, isTouched: true }))\n          }\n        },\n      )\n    })\n\n    const submitMetaArg =\n      submitMeta ?? (this.options.onSubmitMeta as TSubmitMeta)\n\n    if (!this.state.canSubmit && !this._devtoolsSubmissionOverride) {\n      this.options.onSubmitInvalid?.({\n        value: this.state.values,\n        formApi: this,\n        meta: submitMetaArg,\n      })\n      return\n    }\n\n    this.baseStore.setState((d) => ({ ...d, isSubmitting: true }))\n\n    const done = () => {\n      this.baseStore.setState((prev) => ({ ...prev, isSubmitting: false }))\n    }\n\n    await this.validateAllFields('submit')\n\n    if (!this.state.isFieldsValid) {\n      done()\n\n      this.options.onSubmitInvalid?.({\n        value: this.state.values,\n        formApi: this,\n        meta: submitMetaArg,\n      })\n\n      formEventClient.emit('form-submission', {\n        id: this._formId,\n        submissionAttempt: this.state.submissionAttempts,\n        successful: false,\n        stage: 'validateAllFields',\n        errors: (Object.values(this.state.fieldMeta) as AnyFieldMeta[])\n          .map((meta: AnyFieldMeta) => meta.errors)\n          .flat(),\n      })\n      return\n    }\n\n    await this.validate('submit')\n\n    // Fields are invalid, do not submit\n    if (!this.state.isValid) {\n      done()\n\n      this.options.onSubmitInvalid?.({\n        value: this.state.values,\n        formApi: this,\n        meta: submitMetaArg,\n      })\n\n      formEventClient.emit('form-submission', {\n        id: this._formId,\n        submissionAttempt: this.state.submissionAttempts,\n        successful: false,\n        stage: 'validate',\n        errors: this.state.errors,\n      })\n\n      return\n    }\n\n    batch(() => {\n      void (Object.values(this.fieldInfo) as FieldInfo<TFormData>[]).forEach(\n        (field) => {\n          field.instance?.options.listeners?.onSubmit?.({\n            value: field.instance.state.value,\n            fieldApi: field.instance,\n          })\n        },\n      )\n    })\n\n    this.options.listeners?.onSubmit?.({ formApi: this, meta: submitMetaArg })\n\n    try {\n      // Run the submit code\n      await this.options.onSubmit?.({\n        value: this.state.values,\n        formApi: this,\n        meta: submitMetaArg,\n      })\n\n      batch(() => {\n        this.baseStore.setState((prev) => ({\n          ...prev,\n          isSubmitted: true,\n          isSubmitSuccessful: true, // Set isSubmitSuccessful to true on successful submission\n        }))\n\n        formEventClient.emit('form-submission', {\n          id: this._formId,\n          submissionAttempt: this.state.submissionAttempts,\n          successful: true,\n        })\n\n        done()\n      })\n    } catch (err) {\n      this.baseStore.setState((prev) => ({\n        ...prev,\n        isSubmitSuccessful: false, // Ensure isSubmitSuccessful is false if an error occurs\n      }))\n\n      formEventClient.emit('form-submission', {\n        id: this._formId,\n        submissionAttempt: this.state.submissionAttempts,\n        successful: false,\n        stage: 'inflight',\n        onError: err,\n      })\n\n      done()\n\n      throw err\n    }\n  }\n\n  /**\n   * Gets the value of the specified field.\n   */\n  getFieldValue = <TField extends DeepKeys<TFormData>>(\n    field: TField,\n  ): DeepValue<TFormData, TField> => getBy(this.state.values, field)\n\n  /**\n   * Gets the metadata of the specified field.\n   */\n  getFieldMeta = <TField extends DeepKeys<TFormData>>(\n    field: TField,\n  ): AnyFieldMeta | undefined => {\n    return this.state.fieldMeta[field]\n  }\n\n  /**\n   * Gets the field info of the specified field.\n   */\n  getFieldInfo = <TField extends DeepKeys<TFormData>>(\n    field: TField,\n  ): FieldInfo<TFormData> => {\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    return (this.fieldInfo[field] ||= {\n      instance: null,\n      validationMetaMap: {\n        onChange: undefined,\n        onBlur: undefined,\n        onSubmit: undefined,\n        onMount: undefined,\n        onServer: undefined,\n        onDynamic: undefined,\n      },\n    })\n  }\n\n  /**\n   * Updates the metadata of the specified field.\n   */\n  setFieldMeta = <TField extends DeepKeys<TFormData>>(\n    field: TField,\n    updater: Updater<AnyFieldMetaBase>,\n  ) => {\n    this.baseStore.setState((prev) => {\n      return {\n        ...prev,\n        fieldMetaBase: {\n          ...prev.fieldMetaBase,\n          [field]: functionalUpdate(\n            updater,\n            prev.fieldMetaBase[field] as never,\n          ),\n        },\n      }\n    })\n  }\n\n  /**\n   * resets every field's meta\n   */\n  resetFieldMeta = <TField extends DeepKeys<TFormData>>(\n    fieldMeta: Partial<Record<TField, AnyFieldMeta>>,\n  ): Partial<Record<TField, AnyFieldMeta>> => {\n    return Object.keys(fieldMeta).reduce(\n      (acc, key) => {\n        const fieldKey = key as TField\n        acc[fieldKey] = defaultFieldMeta\n        return acc\n      },\n      {} as Partial<Record<TField, AnyFieldMeta>>,\n    )\n  }\n\n  /**\n   * Sets the value of the specified field and optionally updates the touched state.\n   */\n  setFieldValue = <TField extends DeepKeys<TFormData>>(\n    field: TField,\n    updater: Updater<DeepValue<TFormData, TField>>,\n    opts?: UpdateMetaOptions,\n  ) => {\n    const dontUpdateMeta = opts?.dontUpdateMeta ?? false\n    const dontRunListeners = opts?.dontRunListeners ?? false\n    const dontValidate = opts?.dontValidate ?? false\n\n    batch(() => {\n      if (!dontUpdateMeta) {\n        this.setFieldMeta(field, (prev) => ({\n          ...prev,\n          isTouched: true,\n          isDirty: true,\n          errorMap: {\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            ...prev?.errorMap,\n            onMount: undefined,\n          },\n        }))\n      }\n\n      this.baseStore.setState((prev) => {\n        return {\n          ...prev,\n          values: setBy(prev.values, field, updater),\n        }\n      })\n    })\n\n    if (!dontRunListeners) {\n      this.getFieldInfo(field).instance?.triggerOnChangeListener()\n    }\n\n    if (!dontValidate) {\n      this.validateField(field, 'change')\n    }\n  }\n\n  deleteField = <TField extends DeepKeys<TFormData>>(field: TField) => {\n    const subFieldsToDelete = Object.keys(this.fieldInfo).filter((f) => {\n      const fieldStr = field.toString()\n      return f !== fieldStr && f.startsWith(fieldStr)\n    })\n\n    const fieldsToDelete = [...subFieldsToDelete, field]\n\n    // Cleanup the last fields\n    this.baseStore.setState((prev) => {\n      const newState = { ...prev }\n      fieldsToDelete.forEach((f) => {\n        newState.values = deleteBy(newState.values, f)\n        delete this.fieldInfo[f as never]\n        delete newState.fieldMetaBase[f as never]\n      })\n\n      return newState\n    })\n  }\n\n  /**\n   * Pushes a value into an array field.\n   */\n  pushFieldValue = <TField extends DeepKeysOfType<TFormData, any[]>>(\n    field: TField,\n    value: DeepValue<TFormData, TField> extends any[]\n      ? DeepValue<TFormData, TField>[number]\n      : never,\n    options?: UpdateMetaOptions,\n  ) => {\n    this.setFieldValue(\n      field,\n      (prev) => [...(Array.isArray(prev) ? prev : []), value] as any,\n      options,\n    )\n  }\n\n  insertFieldValue = async <TField extends DeepKeysOfType<TFormData, any[]>>(\n    field: TField,\n    index: number,\n    value: DeepValue<TFormData, TField> extends any[]\n      ? DeepValue<TFormData, TField>[number]\n      : never,\n    options?: UpdateMetaOptions,\n  ) => {\n    this.setFieldValue(\n      field,\n      (prev) => {\n        return [\n          ...(prev as DeepValue<TFormData, TField>[]).slice(0, index),\n          value,\n          ...(prev as DeepValue<TFormData, TField>[]).slice(index),\n        ] as any\n      },\n      mergeOpts(options, { dontValidate: true }),\n    )\n\n    const dontValidate = options?.dontValidate ?? false\n    if (!dontValidate) {\n      // Validate the whole array + all fields that have shifted\n      await this.validateField(field, 'change')\n    }\n\n    // Shift down all meta after validating to make sure the new field has been mounted\n    metaHelper(this).handleArrayInsert(field, index)\n\n    if (!dontValidate) {\n      await this.validateArrayFieldsStartingFrom(field, index, 'change')\n    }\n  }\n\n  /**\n   * Replaces a value into an array field at the specified index.\n   */\n  replaceFieldValue = async <TField extends DeepKeysOfType<TFormData, any[]>>(\n    field: TField,\n    index: number,\n    value: DeepValue<TFormData, TField> extends any[]\n      ? DeepValue<TFormData, TField>[number]\n      : never,\n    options?: UpdateMetaOptions,\n  ) => {\n    this.setFieldValue(\n      field,\n      (prev) => {\n        return (prev as DeepValue<TFormData, TField>[]).map((d, i) =>\n          i === index ? value : d,\n        ) as any\n      },\n      mergeOpts(options, { dontValidate: true }),\n    )\n\n    const dontValidate = options?.dontValidate ?? false\n    if (!dontValidate) {\n      // Validate the whole array + all fields that have shifted\n      await this.validateField(field, 'change')\n      await this.validateArrayFieldsStartingFrom(field, index, 'change')\n    }\n  }\n\n  /**\n   * Removes a value from an array field at the specified index.\n   */\n  removeFieldValue = async <TField extends DeepKeysOfType<TFormData, any[]>>(\n    field: TField,\n    index: number,\n    options?: UpdateMetaOptions,\n  ) => {\n    const fieldValue = this.getFieldValue(field)\n\n    const lastIndex = Array.isArray(fieldValue)\n      ? Math.max((fieldValue as Array<unknown>).length - 1, 0)\n      : null\n\n    this.setFieldValue(\n      field,\n      (prev) => {\n        return (prev as DeepValue<TFormData, TField>[]).filter(\n          (_d, i) => i !== index,\n        ) as any\n      },\n      mergeOpts(options, { dontValidate: true }),\n    )\n\n    // Shift up all meta\n    metaHelper(this).handleArrayRemove(field, index)\n\n    if (lastIndex !== null) {\n      const start = `${field}[${lastIndex}]`\n      this.deleteField(start as never)\n    }\n\n    const dontValidate = options?.dontValidate ?? false\n    if (!dontValidate) {\n      // Validate the whole array + all fields that have shifted\n      await this.validateField(field, 'change')\n      await this.validateArrayFieldsStartingFrom(field, index, 'change')\n    }\n  }\n\n  /**\n   * Swaps the values at the specified indices within an array field.\n   */\n  swapFieldValues = <TField extends DeepKeysOfType<TFormData, any[]>>(\n    field: TField,\n    index1: number,\n    index2: number,\n    options?: UpdateMetaOptions,\n  ) => {\n    this.setFieldValue(\n      field,\n      (prev: any) => {\n        const prev1 = prev[index1]!\n        const prev2 = prev[index2]!\n        return setBy(setBy(prev, `${index1}`, prev2), `${index2}`, prev1)\n      },\n      mergeOpts(options, { dontValidate: true }),\n    )\n\n    // Swap meta\n    metaHelper(this).handleArraySwap(field, index1, index2)\n\n    const dontValidate = options?.dontValidate ?? false\n    if (!dontValidate) {\n      // Validate the whole array\n      this.validateField(field, 'change')\n      // Validate the swapped fields\n      this.validateField(`${field}[${index1}]` as DeepKeys<TFormData>, 'change')\n      this.validateField(`${field}[${index2}]` as DeepKeys<TFormData>, 'change')\n    }\n  }\n\n  /**\n   * Moves the value at the first specified index to the second specified index within an array field.\n   */\n  moveFieldValues = <TField extends DeepKeysOfType<TFormData, any[]>>(\n    field: TField,\n    index1: number,\n    index2: number,\n    options?: UpdateMetaOptions,\n  ) => {\n    this.setFieldValue(\n      field,\n      (prev: any) => {\n        const next: any = [...prev]\n        next.splice(index2, 0, next.splice(index1, 1)[0])\n        return next\n      },\n      mergeOpts(options, { dontValidate: true }),\n    )\n\n    // Move meta between index1 and index2\n    metaHelper(this).handleArrayMove(field, index1, index2)\n\n    const dontValidate = options?.dontValidate ?? false\n    if (!dontValidate) {\n      // Validate the whole array\n      this.validateField(field, 'change')\n      // Validate the moved fields\n      this.validateField(`${field}[${index1}]` as DeepKeys<TFormData>, 'change')\n      this.validateField(`${field}[${index2}]` as DeepKeys<TFormData>, 'change')\n    }\n  }\n\n  /**\n   * Clear all values within an array field.\n   */\n  clearFieldValues = <TField extends DeepKeysOfType<TFormData, any[]>>(\n    field: TField,\n    options?: UpdateMetaOptions,\n  ) => {\n    const fieldValue = this.getFieldValue(field)\n\n    const lastIndex = Array.isArray(fieldValue)\n      ? Math.max((fieldValue as unknown[]).length - 1, 0)\n      : null\n\n    this.setFieldValue(\n      field,\n      [] as any,\n      mergeOpts(options, { dontValidate: true }),\n    )\n\n    if (lastIndex !== null) {\n      for (let i = 0; i <= lastIndex; i++) {\n        const fieldKey = `${field}[${i}]`\n        this.deleteField(fieldKey as never)\n      }\n    }\n\n    const dontValidate = options?.dontValidate ?? false\n    if (!dontValidate) {\n      // validate array change\n      this.validateField(field, 'change')\n    }\n  }\n\n  /**\n   * Resets the field value and meta to default state\n   */\n  resetField = <TField extends DeepKeys<TFormData>>(field: TField) => {\n    this.baseStore.setState((prev) => {\n      return {\n        ...prev,\n        fieldMetaBase: {\n          ...prev.fieldMetaBase,\n          [field]: defaultFieldMeta,\n        },\n        values: this.options.defaultValues\n          ? setBy(prev.values, field, getBy(this.options.defaultValues, field))\n          : prev.values,\n      }\n    })\n  }\n\n  /**\n   * Updates the form's errorMap\n   */\n  setErrorMap = (\n    errorMap: FormValidationErrorMap<\n      TFormData,\n      UnwrapFormValidateOrFn<TOnMount>,\n      UnwrapFormValidateOrFn<TOnChange>,\n      UnwrapFormAsyncValidateOrFn<TOnChangeAsync>,\n      UnwrapFormValidateOrFn<TOnBlur>,\n      UnwrapFormAsyncValidateOrFn<TOnBlurAsync>,\n      UnwrapFormValidateOrFn<TOnSubmit>,\n      UnwrapFormAsyncValidateOrFn<TOnSubmitAsync>,\n      UnwrapFormValidateOrFn<TOnDynamic>,\n      UnwrapFormAsyncValidateOrFn<TOnDynamicAsync>,\n      UnwrapFormAsyncValidateOrFn<TOnServer>\n    >,\n  ) => {\n    batch(() => {\n      Object.entries(errorMap).forEach(([key, value]) => {\n        const errorMapKey = key as ValidationErrorMapKeys\n\n        if (isGlobalFormValidationError(value)) {\n          const { formError, fieldErrors } = normalizeError<TFormData>(value)\n\n          for (const fieldName of Object.keys(\n            this.fieldInfo,\n          ) as DeepKeys<TFormData>[]) {\n            const fieldMeta = this.getFieldMeta(fieldName)\n            if (!fieldMeta) continue\n\n            this.setFieldMeta(fieldName, (prev) => ({\n              ...prev,\n              errorMap: {\n                ...prev.errorMap,\n                [errorMapKey]: fieldErrors?.[fieldName],\n              },\n              errorSourceMap: {\n                ...prev.errorSourceMap,\n                [errorMapKey]: 'form',\n              },\n            }))\n          }\n\n          this.baseStore.setState((prev) => ({\n            ...prev,\n            errorMap: {\n              ...prev.errorMap,\n              [errorMapKey]: formError,\n            },\n          }))\n        } else {\n          this.baseStore.setState((prev) => ({\n            ...prev,\n            errorMap: {\n              ...prev.errorMap,\n              [errorMapKey]: value,\n            },\n          }))\n        }\n      })\n    })\n  }\n\n  /**\n   * Returns form and field level errors\n   */\n  getAllErrors = (): {\n    form: {\n      errors: Array<\n        | UnwrapFormValidateOrFn<TOnMount>\n        | UnwrapFormValidateOrFn<TOnChange>\n        | UnwrapFormAsyncValidateOrFn<TOnChangeAsync>\n        | UnwrapFormValidateOrFn<TOnBlur>\n        | UnwrapFormAsyncValidateOrFn<TOnBlurAsync>\n        | UnwrapFormValidateOrFn<TOnSubmit>\n        | UnwrapFormAsyncValidateOrFn<TOnSubmitAsync>\n        | UnwrapFormValidateOrFn<TOnDynamic>\n        | UnwrapFormAsyncValidateOrFn<TOnDynamicAsync>\n        | UnwrapFormAsyncValidateOrFn<TOnServer>\n      >\n      errorMap: ValidationErrorMap<\n        UnwrapFormValidateOrFn<TOnMount>,\n        UnwrapFormValidateOrFn<TOnChange>,\n        UnwrapFormAsyncValidateOrFn<TOnChangeAsync>,\n        UnwrapFormValidateOrFn<TOnBlur>,\n        UnwrapFormAsyncValidateOrFn<TOnBlurAsync>,\n        UnwrapFormValidateOrFn<TOnSubmit>,\n        UnwrapFormAsyncValidateOrFn<TOnSubmitAsync>,\n        UnwrapFormValidateOrFn<TOnDynamic>,\n        UnwrapFormAsyncValidateOrFn<TOnDynamicAsync>,\n        UnwrapFormAsyncValidateOrFn<TOnServer>\n      >\n    }\n    fields: Record<\n      DeepKeys<TFormData>,\n      { errors: ValidationError[]; errorMap: ValidationErrorMap }\n    >\n  } => {\n    return {\n      form: {\n        errors: this.state.errors,\n        errorMap: this.state.errorMap,\n      },\n      fields: Object.entries(this.state.fieldMeta).reduce(\n        (acc, [fieldName, fieldMeta]) => {\n          if (\n            Object.keys(fieldMeta as AnyFieldMeta).length &&\n            (fieldMeta as AnyFieldMeta).errors.length\n          ) {\n            acc[fieldName as DeepKeys<TFormData>] = {\n              errors: (fieldMeta as AnyFieldMeta).errors,\n              errorMap: (fieldMeta as AnyFieldMeta).errorMap,\n            }\n          }\n\n          return acc\n        },\n        {} as Record<\n          DeepKeys<TFormData>,\n          { errors: ValidationError[]; errorMap: ValidationErrorMap }\n        >,\n      ),\n    }\n  }\n\n  /**\n   * Parses the form's values with a given standard schema and returns\n   * issues (if any). This method does NOT set any internal errors.\n   * @param schema The standard schema to parse the form values with.\n   */\n  parseValuesWithSchema = (schema: StandardSchemaV1<TFormData, unknown>) => {\n    return standardSchemaValidators.validate(\n      { value: this.state.values, validationSource: 'form' },\n      schema,\n    )\n  }\n\n  /**\n   * Parses the form's values with a given standard schema and returns\n   * issues (if any). This method does NOT set any internal errors.\n   * @param schema The standard schema to parse the form values with.\n   */\n  parseValuesWithSchemaAsync = (\n    schema: StandardSchemaV1<TFormData, unknown>,\n  ) => {\n    return standardSchemaValidators.validateAsync(\n      { value: this.state.values, validationSource: 'form' },\n      schema,\n    )\n  }\n}\n\nfunction normalizeError<TFormData>(rawError?: FormValidationError<unknown>): {\n  formError: ValidationError\n  fieldErrors?: Partial<Record<DeepKeys<TFormData>, ValidationError>>\n} {\n  if (rawError) {\n    if (isGlobalFormValidationError(rawError)) {\n      const formError = normalizeError(rawError.form).formError\n      const fieldErrors = rawError.fields\n      return { formError, fieldErrors } as never\n    }\n\n    return { formError: rawError }\n  }\n\n  return { formError: undefined }\n}\n\nfunction getErrorMapKey(cause: ValidationCause) {\n  switch (cause) {\n    case 'submit':\n      return 'onSubmit'\n    case 'blur':\n      return 'onBlur'\n    case 'mount':\n      return 'onMount'\n    case 'server':\n      return 'onServer'\n    case 'dynamic':\n      return 'onDynamic'\n    case 'change':\n    default:\n      return 'onChange'\n  }\n}\n"],"names":["formEventClient","evaluate","batch","opts","getSyncValidatorArray","defaultValidationLogic","determineFormLevelErrorSourceAndValue","getAsyncValidatorArray","getBy","functionalUpdate","defaultFieldMeta","setBy","deleteBy","mergeOpts","metaHelper","isGlobalFormValidationError","standardSchemaValidators","uuid","Store","Derived","isNonEmptyArray","throttleFormState","isStandardSchemaValidator"],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/esm/FieldApi.js.map b/dist/esm/FieldApi.js.map
index 87b57130e701c7d34c98cfbdaa7e6f886364d0c3..4d81ec618886db462eb2a3bef42c5c49f2ea565b 100644
--- a/dist/esm/FieldApi.js.map
+++ b/dist/esm/FieldApi.js.map
@@ -1 +1 @@
-{"version":3,"file":"FieldApi.js","sources":["../../src/FieldApi.ts"],"sourcesContent":["import { Derived, batch } from '@tanstack/store'\nimport {\n  isStandardSchemaValidator,\n  standardSchemaValidators,\n} from './standardSchemaValidator'\nimport { defaultFieldMeta } from './metaHelper'\nimport {\n  determineFieldLevelErrorSourceAndValue,\n  evaluate,\n  getAsyncValidatorArray,\n  getBy,\n  getSyncValidatorArray,\n  mergeOpts,\n} from './utils'\nimport { defaultValidationLogic } from './ValidationLogic'\nimport type { DeepKeys, DeepValue, UnwrapOneLevelOfArray } from './util-types'\nimport type {\n  StandardSchemaV1,\n  StandardSchemaV1Issue,\n  TStandardSchemaValidatorValue,\n} from './standardSchemaValidator'\nimport type {\n  FieldInfo,\n  FormApi,\n  FormAsyncValidateOrFn,\n  FormValidateAsyncFn,\n  FormValidateFn,\n  FormValidateOrFn,\n} from './FormApi'\nimport type {\n  ListenerCause,\n  UpdateMetaOptions,\n  ValidationCause,\n  ValidationError,\n  ValidationErrorMap,\n  ValidationErrorMapSource,\n} from './types'\nimport type { AsyncValidator, SyncValidator, Updater } from './utils'\n\n/**\n * @private\n */\n// TODO: Add the `Unwrap` type to the errors\ntype FieldErrorMapFromValidator<\n  TFormData,\n  TName extends DeepKeys<TFormData>,\n  TData extends DeepValue<TFormData, TName>,\n  TOnMount extends undefined | FieldValidateOrFn<TFormData, TName, TData>,\n  TOnChange extends undefined | FieldValidateOrFn<TFormData, TName, TData>,\n  TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TFormData, TName, TData>,\n  TOnBlur extends undefined | FieldValidateOrFn<TFormData, TName, TData>,\n  TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TFormData, TName, TData>,\n  TOnSubmit extends undefined | FieldValidateOrFn<TFormData, TName, TData>,\n  TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TFormData, TName, TData>,\n> = Partial<\n  Record<\n    DeepKeys<TFormData>,\n    ValidationErrorMap<\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync\n    >\n  >\n>\n\n/**\n * @private\n */\nexport type FieldValidateFn<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n> = (props: {\n  value: TData\n  fieldApi: FieldApi<\n    TParentData,\n    TName,\n    TData,\n    // This is technically an edge-type; which we try to keep non-`any`, but in this case\n    // It's referring to an inaccessible type from the field validate function inner types, so it's not a big deal\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any\n  >\n}) => unknown\n\n/**\n * @private\n */\nexport type FieldValidateOrFn<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n> =\n  | FieldValidateFn<TParentData, TName, TData>\n  | StandardSchemaV1<TData, unknown>\n\ntype StandardBrandedSchemaV1<T> = T & { __standardSchemaV1: true }\n\ntype UnwrapFormValidateOrFnForInner<\n  TValidateOrFn extends undefined | FormValidateOrFn<any>,\n> = [TValidateOrFn] extends [FormValidateFn<any>]\n  ? ReturnType<TValidateOrFn>\n  : [TValidateOrFn] extends [StandardSchemaV1<infer TOut, any>]\n    ? StandardBrandedSchemaV1<TOut>\n    : undefined\n\nexport type UnwrapFieldValidateOrFn<\n  TName extends string,\n  TValidateOrFn extends undefined | FieldValidateOrFn<any, any, any>,\n  TFormValidateOrFn extends undefined | FormValidateOrFn<any>,\n> =\n  | ([TFormValidateOrFn] extends [StandardSchemaV1<any, infer TStandardOut>]\n      ? TName extends keyof TStandardOut\n        ? StandardSchemaV1Issue[]\n        : undefined\n      : undefined)\n  | (UnwrapFormValidateOrFnForInner<TFormValidateOrFn> extends infer TFormValidateVal\n      ? TFormValidateVal extends { __standardSchemaV1: true }\n        ? [DeepValue<TFormValidateVal, TName>] extends [never]\n          ? undefined\n          : StandardSchemaV1Issue[]\n        : TFormValidateVal extends { fields: any }\n          ? TName extends keyof TFormValidateVal['fields']\n            ? TFormValidateVal['fields'][TName]\n            : undefined\n          : undefined\n      : never)\n  | ([TValidateOrFn] extends [FieldValidateFn<any, any, any>]\n      ? ReturnType<TValidateOrFn>\n      : [TValidateOrFn] extends [StandardSchemaV1<any, any>]\n        ? // TODO: Check if `disableErrorFlat` is enabled, if so, return StandardSchemaV1Issue[][]\n          StandardSchemaV1Issue[]\n        : undefined)\n\n/**\n * @private\n */\nexport type FieldValidateAsyncFn<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n> = (options: {\n  value: TData\n  fieldApi: FieldApi<\n    TParentData,\n    TName,\n    TData,\n    // This is technically an edge-type; which we try to keep non-`any`, but in this case\n    // It's referring to an inaccessible type from the field validate function inner types, so it's not a big deal\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any\n  >\n  signal: AbortSignal\n}) => unknown | Promise<unknown>\n\n/**\n * @private\n */\nexport type FieldAsyncValidateOrFn<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n> =\n  | FieldValidateAsyncFn<TParentData, TName, TData>\n  | StandardSchemaV1<TData, unknown>\n\ntype UnwrapFormAsyncValidateOrFnForInner<\n  TValidateOrFn extends undefined | FormAsyncValidateOrFn<any>,\n> = [TValidateOrFn] extends [FormValidateAsyncFn<any>]\n  ? Awaited<ReturnType<TValidateOrFn>>\n  : [TValidateOrFn] extends [StandardSchemaV1<infer TOut, any>]\n    ? StandardBrandedSchemaV1<TOut>\n    : undefined\n\nexport type UnwrapFieldAsyncValidateOrFn<\n  TName extends string,\n  TValidateOrFn extends undefined | FieldAsyncValidateOrFn<any, any, any>,\n  TFormValidateOrFn extends undefined | FormAsyncValidateOrFn<any>,\n> =\n  | ([TFormValidateOrFn] extends [StandardSchemaV1<any, infer TStandardOut>]\n      ? TName extends keyof TStandardOut\n        ? StandardSchemaV1Issue[]\n        : undefined\n      : undefined)\n  | (UnwrapFormAsyncValidateOrFnForInner<TFormValidateOrFn> extends infer TFormValidateVal\n      ? TFormValidateVal extends { __standardSchemaV1: true }\n        ? [DeepValue<TFormValidateVal, TName>] extends [never]\n          ? undefined\n          : StandardSchemaV1Issue[]\n        : TFormValidateVal extends { fields: any }\n          ? TName extends keyof TFormValidateVal['fields']\n            ? TFormValidateVal['fields'][TName]\n            : undefined\n          : undefined\n      : never)\n  | ([TValidateOrFn] extends [FieldValidateAsyncFn<any, any, any>]\n      ? Awaited<ReturnType<TValidateOrFn>>\n      : [TValidateOrFn] extends [StandardSchemaV1<any, any>]\n        ? // TODO: Check if `disableErrorFlat` is enabled, if so, return StandardSchemaV1Issue[][]\n          StandardSchemaV1Issue[]\n        : undefined)\n\n/**\n * @private\n */\nexport type FieldListenerFn<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n> = (props: {\n  value: TData\n  fieldApi: FieldApi<\n    TParentData,\n    TName,\n    TData,\n    // This is technically an edge-type; which we try to keep non-`any`, but in this case\n    // It's referring to an inaccessible type from the field listener function inner types, so it's not a big deal\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any\n  >\n}) => void\n\nexport interface FieldValidators<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName>,\n  TOnMount extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChange extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnBlur extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnSubmit extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnDynamic extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnDynamicAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n> {\n  /**\n   * An optional function, that runs on the mount event of input.\n   */\n  onMount?: TOnMount\n  /**\n   * An optional function, that runs on the change event of input.\n   *\n   * @example z.string().min(1)\n   */\n  onChange?: TOnChange\n  /**\n   * An optional property similar to `onChange` but async validation\n   *\n   * @example z.string().refine(async (val) => val.length > 3, { message: 'Testing 123' })\n   */\n  onChangeAsync?: TOnChangeAsync\n  /**\n   * An optional number to represent how long the `onChangeAsync` should wait before running\n   *\n   * If set to a number larger than 0, will debounce the async validation event by this length of time in milliseconds\n   */\n  onChangeAsyncDebounceMs?: number\n  /**\n   * An optional list of field names that should trigger this field's `onChange` and `onChangeAsync` events when its value changes\n   */\n  onChangeListenTo?: DeepKeys<TParentData>[]\n  /**\n   * An optional function, that runs on the blur event of input.\n   *\n   * @example z.string().min(1)\n   */\n  onBlur?: TOnBlur\n  /**\n   * An optional property similar to `onBlur` but async validation.\n   *\n   * @example z.string().refine(async (val) => val.length > 3, { message: 'Testing 123' })\n   */\n  onBlurAsync?: TOnBlurAsync\n\n  /**\n   * An optional number to represent how long the `onBlurAsync` should wait before running\n   *\n   * If set to a number larger than 0, will debounce the async validation event by this length of time in milliseconds\n   */\n  onBlurAsyncDebounceMs?: number\n  /**\n   * An optional list of field names that should trigger this field's `onBlur` and `onBlurAsync` events when its value changes\n   */\n  onBlurListenTo?: DeepKeys<TParentData>[]\n  /**\n   * An optional function, that runs on the submit event of form.\n   *\n   * @example z.string().min(1)\n   */\n  onSubmit?: TOnSubmit\n  /**\n   * An optional property similar to `onSubmit` but async validation.\n   *\n   * @example z.string().refine(async (val) => val.length > 3, { message: 'Testing 123' })\n   */\n  onSubmitAsync?: TOnSubmitAsync\n  onDynamic?: TOnDynamic\n  onDynamicAsync?: TOnDynamicAsync\n  onDynamicAsyncDebounceMs?: number\n}\n\nexport interface FieldListeners<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n> {\n  onChange?: FieldListenerFn<TParentData, TName, TData>\n  onChangeDebounceMs?: number\n  onBlur?: FieldListenerFn<TParentData, TName, TData>\n  onBlurDebounceMs?: number\n  onMount?: FieldListenerFn<TParentData, TName, TData>\n  onSubmit?: FieldListenerFn<TParentData, TName, TData>\n}\n\n/**\n * An object type representing the options for a field in a form.\n */\nexport interface FieldOptions<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName>,\n  TOnMount extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChange extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnBlur extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnSubmit extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnDynamic extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnDynamicAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n> {\n  /**\n   * The field name. The type will be `DeepKeys<TParentData>` to ensure your name is a deep key of the parent dataset.\n   */\n  name: TName\n  /**\n   * An optional default value for the field.\n   */\n  defaultValue?: NoInfer<TData>\n  /**\n   * The default time to debounce async validation if there is not a more specific debounce time passed.\n   */\n  asyncDebounceMs?: number\n  /**\n   * If `true`, always run async validation, even if there are errors emitted during synchronous validation.\n   */\n  asyncAlways?: boolean\n  /**\n   * A list of validators to pass to the field\n   */\n  validators?: FieldValidators<\n    TParentData,\n    TName,\n    TData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TOnDynamic,\n    TOnDynamicAsync\n  >\n  /**\n   * An optional object with default metadata for the field.\n   */\n  defaultMeta?: Partial<\n    FieldMeta<\n      TParentData,\n      TName,\n      TData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      any,\n      any,\n      any,\n      any,\n      any,\n      any,\n      any,\n      any,\n      any\n    >\n  >\n  /**\n   * A list of listeners which attach to the corresponding events\n   */\n  listeners?: FieldListeners<TParentData, TName, TData>\n  /**\n   * Disable the `flat(1)` operation on `field.errors`. This is useful if you want to keep the error structure as is. Not suggested for most use-cases.\n   */\n  disableErrorFlat?: boolean\n}\n\n/**\n * An object type representing the required options for the FieldApi class.\n */\nexport interface FieldApiOptions<\n  in out TParentData,\n  in out TName extends DeepKeys<TParentData>,\n  in out TData extends DeepValue<TParentData, TName>,\n  in out TOnMount extends\n    | undefined\n    | FieldValidateOrFn<TParentData, TName, TData>,\n  in out TOnChange extends\n    | undefined\n    | FieldValidateOrFn<TParentData, TName, TData>,\n  in out TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  in out TOnBlur extends\n    | undefined\n    | FieldValidateOrFn<TParentData, TName, TData>,\n  in out TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  in out TOnSubmit extends\n    | undefined\n    | FieldValidateOrFn<TParentData, TName, TData>,\n  in out TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  in out TOnDynamic extends\n    | undefined\n    | FieldValidateOrFn<TParentData, TName, TData>,\n  in out TOnDynamicAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  in out TFormOnMount extends undefined | FormValidateOrFn<TParentData>,\n  in out TFormOnChange extends undefined | FormValidateOrFn<TParentData>,\n  in out TFormOnChangeAsync extends\n    | undefined\n    | FormAsyncValidateOrFn<TParentData>,\n  in out TFormOnBlur extends undefined | FormValidateOrFn<TParentData>,\n  in out TFormOnBlurAsync extends\n    | undefined\n    | FormAsyncValidateOrFn<TParentData>,\n  in out TFormOnSubmit extends undefined | FormValidateOrFn<TParentData>,\n  in out TFormOnSubmitAsync extends\n    | undefined\n    | FormAsyncValidateOrFn<TParentData>,\n  in out TFormOnDynamic extends undefined | FormValidateOrFn<TParentData>,\n  in out TFormOnDynamicAsync extends\n    | undefined\n    | FormAsyncValidateOrFn<TParentData>,\n  in out TFormOnServer extends undefined | FormAsyncValidateOrFn<TParentData>,\n  in out TParentSubmitMeta,\n> extends FieldOptions<\n  TParentData,\n  TName,\n  TData,\n  TOnMount,\n  TOnChange,\n  TOnChangeAsync,\n  TOnBlur,\n  TOnBlurAsync,\n  TOnSubmit,\n  TOnSubmitAsync,\n  TOnDynamic,\n  TOnDynamicAsync\n> {\n  form: FormApi<\n    TParentData,\n    TFormOnMount,\n    TFormOnChange,\n    TFormOnChangeAsync,\n    TFormOnBlur,\n    TFormOnBlurAsync,\n    TFormOnSubmit,\n    TFormOnSubmitAsync,\n    TFormOnDynamic,\n    TFormOnDynamicAsync,\n    TFormOnServer,\n    TParentSubmitMeta\n  >\n}\n\nexport type FieldMetaBase<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName>,\n  TOnMount extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChange extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnBlur extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnSubmit extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnDynamic extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnDynamicAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TFormOnMount extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChange extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChangeAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnBlur extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnBlurAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnSubmit extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnDynamic extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n> = {\n  /**\n   * A flag indicating whether the field has been touched.\n   */\n  isTouched: boolean\n  /**\n   * A flag indicating whether the field has been blurred.\n   */\n  isBlurred: boolean\n  /**\n   * A flag that is `true` if the field's value has been modified by the user. Opposite of `isPristine`.\n   */\n  isDirty: boolean\n  /**\n   * A map of errors related to the field value.\n   */\n  errorMap: ValidationErrorMap<\n    UnwrapFieldValidateOrFn<TName, TOnMount, TFormOnMount>,\n    UnwrapFieldValidateOrFn<TName, TOnChange, TFormOnChange>,\n    UnwrapFieldAsyncValidateOrFn<TName, TOnChangeAsync, TFormOnChangeAsync>,\n    UnwrapFieldValidateOrFn<TName, TOnBlur, TFormOnBlur>,\n    UnwrapFieldAsyncValidateOrFn<TName, TOnBlurAsync, TFormOnBlurAsync>,\n    UnwrapFieldValidateOrFn<TName, TOnSubmit, TFormOnSubmit>,\n    UnwrapFieldAsyncValidateOrFn<TName, TOnSubmitAsync, TFormOnSubmitAsync>,\n    UnwrapFieldValidateOrFn<TName, TOnDynamic, TFormOnDynamic>,\n    UnwrapFieldAsyncValidateOrFn<TName, TOnDynamicAsync, TFormOnDynamicAsync>\n  >\n\n  /**\n   * @private allows tracking the source of the errors in the error map\n   */\n  errorSourceMap: ValidationErrorMapSource\n  /**\n   * A flag indicating whether the field is currently being validated.\n   */\n  isValidating: boolean\n}\n\nexport type AnyFieldMetaBase = FieldMetaBase<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any\n>\n\nexport type FieldMetaDerived<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName>,\n  TOnMount extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChange extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnBlur extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnSubmit extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnDynamic extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnDynamicAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TFormOnMount extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChange extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChangeAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnBlur extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnBlurAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnSubmit extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnDynamic extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n> = {\n  /**\n   * An array of errors related to the field value.\n   */\n  errors: Array<\n    | UnwrapOneLevelOfArray<\n        UnwrapFieldValidateOrFn<TName, TOnMount, TFormOnMount>\n      >\n    | UnwrapOneLevelOfArray<\n        UnwrapFieldValidateOrFn<TName, TOnChange, TFormOnChange>\n      >\n    | UnwrapOneLevelOfArray<\n        UnwrapFieldAsyncValidateOrFn<TName, TOnChangeAsync, TFormOnChangeAsync>\n      >\n    | UnwrapOneLevelOfArray<\n        UnwrapFieldValidateOrFn<TName, TOnBlur, TFormOnBlur>\n      >\n    | UnwrapOneLevelOfArray<\n        UnwrapFieldAsyncValidateOrFn<TName, TOnBlurAsync, TFormOnBlurAsync>\n      >\n    | UnwrapOneLevelOfArray<\n        UnwrapFieldValidateOrFn<TName, TOnSubmit, TFormOnSubmit>\n      >\n    | UnwrapOneLevelOfArray<\n        UnwrapFieldAsyncValidateOrFn<TName, TOnSubmitAsync, TFormOnSubmitAsync>\n      >\n    | UnwrapOneLevelOfArray<\n        UnwrapFieldValidateOrFn<TName, TOnDynamic, TFormOnDynamic>\n      >\n    | UnwrapOneLevelOfArray<\n        UnwrapFieldAsyncValidateOrFn<\n          TName,\n          TOnDynamicAsync,\n          TFormOnDynamicAsync\n        >\n      >\n  >\n  /**\n   * A flag that is `true` if the field's value has not been modified by the user. Opposite of `isDirty`.\n   */\n  isPristine: boolean\n  /**\n   * A boolean indicating if the field is valid. Evaluates `true` if there are no field errors.\n   */\n  isValid: boolean\n  /**\n   * A flag indicating whether the field's current value is the default value\n   */\n  isDefaultValue: boolean\n}\n\nexport type AnyFieldMetaDerived = FieldMetaDerived<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any\n>\n\n/**\n * An object type representing the metadata of a field in a form.\n */\nexport type FieldMeta<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName>,\n  TOnMount extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChange extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnBlur extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnSubmit extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnDynamic extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnDynamicAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TFormOnMount extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChange extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChangeAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnBlur extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnBlurAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnSubmit extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnDynamic extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n> = FieldMetaBase<\n  TParentData,\n  TName,\n  TData,\n  TOnMount,\n  TOnChange,\n  TOnChangeAsync,\n  TOnBlur,\n  TOnBlurAsync,\n  TOnSubmit,\n  TOnSubmitAsync,\n  TOnDynamic,\n  TOnDynamicAsync,\n  TFormOnMount,\n  TFormOnChange,\n  TFormOnChangeAsync,\n  TFormOnBlur,\n  TFormOnBlurAsync,\n  TFormOnSubmit,\n  TFormOnSubmitAsync,\n  TFormOnDynamic,\n  TFormOnDynamicAsync\n> &\n  FieldMetaDerived<\n    TParentData,\n    TName,\n    TData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TOnDynamic,\n    TOnDynamicAsync,\n    TFormOnMount,\n    TFormOnChange,\n    TFormOnChangeAsync,\n    TFormOnBlur,\n    TFormOnBlurAsync,\n    TFormOnSubmit,\n    TFormOnSubmitAsync,\n    TFormOnDynamic,\n    TFormOnDynamicAsync\n  >\n\nexport type AnyFieldMeta = FieldMeta<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any\n>\n\n/**\n * An object type representing the state of a field.\n */\nexport type FieldState<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName>,\n  TOnMount extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChange extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnBlur extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnSubmit extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnDynamic extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnDynamicAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TFormOnMount extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChange extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChangeAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnBlur extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnBlurAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnSubmit extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnDynamic extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n> = {\n  /**\n   * The current value of the field.\n   */\n  value: TData\n  /**\n   * The current metadata of the field.\n   */\n  meta: FieldMeta<\n    TParentData,\n    TName,\n    TData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TOnDynamic,\n    TOnDynamicAsync,\n    TFormOnMount,\n    TFormOnChange,\n    TFormOnChangeAsync,\n    TFormOnBlur,\n    TFormOnBlurAsync,\n    TFormOnSubmit,\n    TFormOnSubmitAsync,\n    TFormOnDynamic,\n    TFormOnDynamicAsync\n  >\n}\n\n/**\n * @public\n *\n * A type representing the Field API with all generics set to `any` for convenience.\n */\nexport type AnyFieldApi = FieldApi<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any\n>\n\n/**\n * We cannot use methods and must use arrow functions. Otherwise, our React adapters\n * will break due to loss of the method when using spread.\n */\n\n/**\n * A class representing the API for managing a form field.\n *\n * Normally, you will not need to create a new `FieldApi` instance directly.\n * Instead, you will use a framework hook/function like `useField` or `createField`\n * to create a new instance for you that uses your framework's reactivity model.\n * However, if you need to create a new instance manually, you can do so by calling\n * the `new FieldApi` constructor.\n */\nexport class FieldApi<\n  in out TParentData,\n  in out TName extends DeepKeys<TParentData>,\n  in out TData extends DeepValue<TParentData, TName>,\n  in out TOnMount extends\n    | undefined\n    | FieldValidateOrFn<TParentData, TName, TData>,\n  in out TOnChange extends\n    | undefined\n    | FieldValidateOrFn<TParentData, TName, TData>,\n  in out TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  in out TOnBlur extends\n    | undefined\n    | FieldValidateOrFn<TParentData, TName, TData>,\n  in out TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  in out TOnSubmit extends\n    | undefined\n    | FieldValidateOrFn<TParentData, TName, TData>,\n  in out TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  in out TOnDynamic extends\n    | undefined\n    | FieldValidateOrFn<TParentData, TName, TData>,\n  in out TOnDynamicAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  in out TFormOnMount extends undefined | FormValidateOrFn<TParentData>,\n  in out TFormOnChange extends undefined | FormValidateOrFn<TParentData>,\n  in out TFormOnChangeAsync extends\n    | undefined\n    | FormAsyncValidateOrFn<TParentData>,\n  in out TFormOnBlur extends undefined | FormValidateOrFn<TParentData>,\n  in out TFormOnBlurAsync extends\n    | undefined\n    | FormAsyncValidateOrFn<TParentData>,\n  in out TFormOnSubmit extends undefined | FormValidateOrFn<TParentData>,\n  in out TFormOnSubmitAsync extends\n    | undefined\n    | FormAsyncValidateOrFn<TParentData>,\n  in out TFormOnDynamic extends undefined | FormValidateOrFn<TParentData>,\n  in out TFormOnDynamicAsync extends\n    | undefined\n    | FormAsyncValidateOrFn<TParentData>,\n  in out TFormOnServer extends undefined | FormAsyncValidateOrFn<TParentData>,\n  in out TParentSubmitMeta,\n> {\n  /**\n   * A reference to the form API instance.\n   */\n  form: FieldApiOptions<\n    TParentData,\n    TName,\n    TData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TOnDynamic,\n    TOnDynamicAsync,\n    TFormOnMount,\n    TFormOnChange,\n    TFormOnChangeAsync,\n    TFormOnBlur,\n    TFormOnBlurAsync,\n    TFormOnSubmit,\n    TFormOnSubmitAsync,\n    TFormOnDynamic,\n    TFormOnDynamicAsync,\n    TFormOnServer,\n    TParentSubmitMeta\n  >['form']\n  /**\n   * The field name.\n   */\n  name: TName\n  /**\n   * The field options.\n   */\n  options: FieldApiOptions<\n    TParentData,\n    TName,\n    TData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TOnDynamic,\n    TOnDynamicAsync,\n    TFormOnMount,\n    TFormOnChange,\n    TFormOnChangeAsync,\n    TFormOnBlur,\n    TFormOnBlurAsync,\n    TFormOnSubmit,\n    TFormOnSubmitAsync,\n    TFormOnDynamic,\n    TFormOnDynamicAsync,\n    TFormOnServer,\n    TParentSubmitMeta\n  > = {} as any\n  /**\n   * The field state store.\n   */\n  store!: Derived<\n    FieldState<\n      TParentData,\n      TName,\n      TData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TFormOnMount,\n      TFormOnChange,\n      TFormOnChangeAsync,\n      TFormOnBlur,\n      TFormOnBlurAsync,\n      TFormOnSubmit,\n      TFormOnSubmitAsync,\n      TFormOnDynamic,\n      TFormOnDynamicAsync\n    >\n  >\n  /**\n   * The current field state.\n   */\n  get state() {\n    return this.store.state\n  }\n  timeoutIds: {\n    validations: Record<ValidationCause, ReturnType<typeof setTimeout> | null>\n    listeners: Record<ListenerCause, ReturnType<typeof setTimeout> | null>\n    formListeners: Record<ListenerCause, ReturnType<typeof setTimeout> | null>\n  }\n\n  /**\n   * Initializes a new `FieldApi` instance.\n   */\n  constructor(\n    opts: FieldApiOptions<\n      TParentData,\n      TName,\n      TData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TFormOnMount,\n      TFormOnChange,\n      TFormOnChangeAsync,\n      TFormOnBlur,\n      TFormOnBlurAsync,\n      TFormOnSubmit,\n      TFormOnSubmitAsync,\n      TFormOnDynamic,\n      TFormOnDynamicAsync,\n      TFormOnServer,\n      TParentSubmitMeta\n    >,\n  ) {\n    this.form = opts.form\n    this.name = opts.name\n    this.options = opts\n\n    this.timeoutIds = {\n      validations: {} as Record<ValidationCause, never>,\n      listeners: {} as Record<ListenerCause, never>,\n      formListeners: {} as Record<ListenerCause, never>,\n    }\n\n    this.store = new Derived({\n      deps: [this.form.store],\n      fn: () => {\n        const meta = this.form.getFieldMeta(this.name) ?? {\n          ...defaultFieldMeta,\n          ...opts.defaultMeta,\n        }\n\n        let value = this.form.getFieldValue(this.name)\n        if (\n          !meta.isTouched &&\n          (value as unknown) === undefined &&\n          this.options.defaultValue !== undefined &&\n          !evaluate(value, this.options.defaultValue)\n        ) {\n          value = this.options.defaultValue\n        }\n\n        return {\n          value,\n          meta,\n        } as FieldState<\n          TParentData,\n          TName,\n          TData,\n          TOnMount,\n          TOnChange,\n          TOnChangeAsync,\n          TOnBlur,\n          TOnBlurAsync,\n          TOnSubmit,\n          TOnSubmitAsync,\n          TOnDynamic,\n          TOnDynamicAsync,\n          TFormOnMount,\n          TFormOnChange,\n          TFormOnChangeAsync,\n          TFormOnBlur,\n          TFormOnBlurAsync,\n          TFormOnSubmit,\n          TFormOnSubmitAsync,\n          TFormOnDynamic,\n          TFormOnDynamicAsync\n        >\n      },\n    })\n  }\n\n  /**\n   * @private\n   */\n  runValidator<\n    TValue extends TStandardSchemaValidatorValue<TData> & {\n      fieldApi: AnyFieldApi\n    },\n    TType extends 'validate' | 'validateAsync',\n  >(props: {\n    validate: TType extends 'validate'\n      ? FieldValidateOrFn<any, any, any>\n      : FieldAsyncValidateOrFn<any, any, any>\n    value: TValue\n    type: TType\n    // When `api` is 'field', the return type cannot be `FormValidationError`\n  }): unknown {\n    if (isStandardSchemaValidator(props.validate)) {\n      return standardSchemaValidators[props.type](\n        props.value,\n        props.validate,\n      ) as never\n    }\n\n    return (props.validate as FieldValidateFn<any, any>)(props.value) as never\n  }\n\n  /**\n   * Mounts the field instance to the form.\n   */\n  mount = () => {\n    const cleanup = this.store.mount()\n\n    if (this.options.defaultValue !== undefined && !this.getMeta().isTouched) {\n      this.form.setFieldValue(this.name, this.options.defaultValue, {\n        dontUpdateMeta: true,\n      })\n    }\n\n    const info = this.getInfo()\n    info.instance = this as never\n\n    this.update(this.options as never)\n\n    const { onMount } = this.options.validators || {}\n\n    if (onMount) {\n      const error = this.runValidator({\n        validate: onMount,\n        value: {\n          value: this.state.value,\n          fieldApi: this,\n          validationSource: 'field',\n        },\n        type: 'validate',\n      })\n      if (error) {\n        this.setMeta(\n          (prev) =>\n            ({\n              ...prev,\n              // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n              errorMap: { ...prev?.errorMap, onMount: error },\n              errorSourceMap: {\n                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n                ...prev?.errorSourceMap,\n                onMount: 'field',\n              },\n            }) as never,\n        )\n      }\n    }\n\n    this.options.listeners?.onMount?.({\n      value: this.state.value,\n      fieldApi: this,\n    })\n\n    return cleanup\n  }\n\n  /**\n   * Updates the field instance with new options.\n   */\n  update = (\n    opts: FieldApiOptions<\n      TParentData,\n      TName,\n      TData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TFormOnMount,\n      TFormOnChange,\n      TFormOnChangeAsync,\n      TFormOnBlur,\n      TFormOnBlurAsync,\n      TFormOnSubmit,\n      TFormOnSubmitAsync,\n      TFormOnDynamic,\n      TFormOnDynamicAsync,\n      TFormOnServer,\n      TParentSubmitMeta\n    >,\n  ) => {\n    this.options = opts\n    this.name = opts.name\n\n    // Default Value\n    if (!this.state.meta.isTouched && this.options.defaultValue !== undefined) {\n      const formField = this.form.getFieldValue(this.name)\n      if (!evaluate(formField, opts.defaultValue)) {\n        this.form.setFieldValue(this.name, opts.defaultValue as never, {\n          dontUpdateMeta: true,\n          dontValidate: true,\n          dontRunListeners: true,\n        })\n      }\n    }\n\n    if (!this.form.getFieldMeta(this.name)) {\n      this.form.setFieldMeta(this.name, this.state.meta)\n    }\n  }\n\n  /**\n   * Gets the current field value.\n   * @deprecated Use `field.state.value` instead.\n   */\n  getValue = (): TData => {\n    return this.form.getFieldValue(this.name) as TData\n  }\n\n  /**\n   * Sets the field value and run the `change` validator.\n   */\n  setValue = (updater: Updater<TData>, options?: UpdateMetaOptions) => {\n    this.form.setFieldValue(\n      this.name,\n      updater as never,\n      mergeOpts(options, { dontRunListeners: true, dontValidate: true }),\n    )\n\n    if (!options?.dontRunListeners) {\n      this.triggerOnChangeListener()\n    }\n\n    if (!options?.dontValidate) {\n      this.validate('change')\n    }\n  }\n\n  getMeta = () => this.store.state.meta\n\n  /**\n   * Sets the field metadata.\n   */\n  setMeta = (\n    updater: Updater<\n      FieldMetaBase<\n        TParentData,\n        TName,\n        TData,\n        TOnMount,\n        TOnChange,\n        TOnChangeAsync,\n        TOnBlur,\n        TOnBlurAsync,\n        TOnSubmit,\n        TOnSubmitAsync,\n        TOnDynamic,\n        TOnDynamicAsync,\n        TFormOnMount,\n        TFormOnChange,\n        TFormOnChangeAsync,\n        TFormOnBlur,\n        TFormOnBlurAsync,\n        TFormOnSubmit,\n        TFormOnSubmitAsync,\n        TFormOnDynamic,\n        TFormOnDynamicAsync\n      >\n    >,\n  ) => this.form.setFieldMeta(this.name, updater)\n\n  /**\n   * Gets the field information object.\n   */\n  getInfo = () => this.form.getFieldInfo(this.name)\n\n  /**\n   * Pushes a new value to the field.\n   */\n  pushValue = (\n    value: TData extends any[] ? TData[number] : never,\n    options?: UpdateMetaOptions,\n  ) => {\n    this.form.pushFieldValue(\n      this.name,\n      value as any,\n      mergeOpts(options, { dontRunListeners: true }),\n    )\n\n    if (!options?.dontRunListeners) {\n      this.triggerOnChangeListener()\n    }\n  }\n\n  /**\n   * Inserts a value at the specified index, shifting the subsequent values to the right.\n   */\n  insertValue = (\n    index: number,\n    value: TData extends any[] ? TData[number] : never,\n    options?: UpdateMetaOptions,\n  ) => {\n    this.form.insertFieldValue(\n      this.name,\n      index,\n      value as any,\n      mergeOpts(options, { dontRunListeners: true }),\n    )\n\n    if (!options?.dontRunListeners) {\n      this.triggerOnChangeListener()\n    }\n  }\n\n  /**\n   * Replaces a value at the specified index.\n   */\n  replaceValue = (\n    index: number,\n    value: TData extends any[] ? TData[number] : never,\n    options?: UpdateMetaOptions,\n  ) => {\n    this.form.replaceFieldValue(\n      this.name,\n      index,\n      value as any,\n      mergeOpts(options, { dontRunListeners: true }),\n    )\n\n    if (!options?.dontRunListeners) {\n      this.triggerOnChangeListener()\n    }\n  }\n\n  /**\n   * Removes a value at the specified index.\n   */\n  removeValue = (index: number, options?: UpdateMetaOptions) => {\n    this.form.removeFieldValue(\n      this.name,\n      index,\n      mergeOpts(options, { dontRunListeners: true }),\n    )\n\n    if (!options?.dontRunListeners) {\n      this.triggerOnChangeListener()\n    }\n  }\n\n  /**\n   * Swaps the values at the specified indices.\n   */\n  swapValues = (\n    aIndex: number,\n    bIndex: number,\n    options?: UpdateMetaOptions,\n  ) => {\n    this.form.swapFieldValues(\n      this.name,\n      aIndex,\n      bIndex,\n      mergeOpts(options, { dontRunListeners: true }),\n    )\n\n    if (!options?.dontRunListeners) {\n      this.triggerOnChangeListener()\n    }\n  }\n\n  /**\n   * Moves the value at the first specified index to the second specified index.\n   */\n  moveValue = (aIndex: number, bIndex: number, options?: UpdateMetaOptions) => {\n    this.form.moveFieldValues(\n      this.name,\n      aIndex,\n      bIndex,\n      mergeOpts(options, { dontRunListeners: true }),\n    )\n\n    if (!options?.dontRunListeners) {\n      this.triggerOnChangeListener()\n    }\n  }\n\n  /**\n   * Clear all values from the array.\n   */\n  clearValues = (options?: UpdateMetaOptions) => {\n    this.form.clearFieldValues(\n      this.name,\n      mergeOpts(options, { dontRunListeners: true }),\n    )\n\n    if (!options?.dontRunListeners) {\n      this.triggerOnChangeListener()\n    }\n  }\n\n  /**\n   * @private\n   */\n  getLinkedFields = (cause: ValidationCause) => {\n    const fields = Object.values(this.form.fieldInfo) as FieldInfo<any>[]\n\n    const linkedFields: AnyFieldApi[] = []\n    for (const field of fields) {\n      if (!field.instance) continue\n      const { onChangeListenTo, onBlurListenTo } =\n        field.instance.options.validators || {}\n      if (cause === 'change' && onChangeListenTo?.includes(this.name)) {\n        linkedFields.push(field.instance)\n      }\n      if (cause === 'blur' && onBlurListenTo?.includes(this.name as string)) {\n        linkedFields.push(field.instance)\n      }\n    }\n\n    return linkedFields\n  }\n\n  /**\n   * @private\n   */\n  validateSync = (\n    cause: ValidationCause,\n    errorFromForm: ValidationErrorMap,\n  ) => {\n    const validates = getSyncValidatorArray(cause, {\n      ...this.options,\n      form: this.form,\n      validationLogic:\n        this.form.options.validationLogic || defaultValidationLogic,\n    })\n\n    const linkedFields = this.getLinkedFields(cause)\n    const linkedFieldValidates = linkedFields.reduce(\n      (acc, field) => {\n        const fieldValidates = getSyncValidatorArray(cause, {\n          ...field.options,\n          form: field.form,\n          validationLogic:\n            field.form.options.validationLogic || defaultValidationLogic,\n        })\n        fieldValidates.forEach((validate) => {\n          ;(validate as any).field = field\n        })\n        return acc.concat(fieldValidates as never)\n      },\n      [] as Array<\n        SyncValidator<any> & {\n          field: AnyFieldApi\n        }\n      >,\n    )\n\n    // Needs type cast as eslint errantly believes this is always falsy\n    let hasErrored = false as boolean\n\n    batch(() => {\n      const validateFieldFn = (\n        field: AnyFieldApi,\n        validateObj: SyncValidator<any>,\n      ) => {\n        const errorMapKey = getErrorMapKey(validateObj.cause)\n\n        const fieldLevelError = validateObj.validate\n          ? normalizeError(\n              field.runValidator({\n                validate: validateObj.validate,\n                value: {\n                  value: field.store.state.value,\n                  validationSource: 'field',\n                  fieldApi: field,\n                },\n                type: 'validate',\n              }),\n            )\n          : undefined\n\n        const formLevelError = errorFromForm[errorMapKey]\n\n        const { newErrorValue, newSource } =\n          determineFieldLevelErrorSourceAndValue({\n            formLevelError,\n            fieldLevelError,\n          })\n\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (field.state.meta.errorMap?.[errorMapKey] !== newErrorValue) {\n          field.setMeta((prev) => ({\n            ...prev,\n            errorMap: {\n              ...prev.errorMap,\n              [errorMapKey]: newErrorValue,\n            },\n            errorSourceMap: {\n              ...prev.errorSourceMap,\n              [errorMapKey]: newSource,\n            },\n          }))\n        }\n        if (newErrorValue) {\n          hasErrored = true\n        }\n      }\n\n      for (const validateObj of validates) {\n        validateFieldFn(this, validateObj)\n      }\n      for (const fieldValitateObj of linkedFieldValidates) {\n        if (!fieldValitateObj.validate) continue\n        validateFieldFn(fieldValitateObj.field, fieldValitateObj)\n      }\n    })\n\n    /**\n     *  when we have an error for onSubmit in the state, we want\n     *  to clear the error as soon as the user enters a valid value in the field\n     */\n    const submitErrKey = getErrorMapKey('submit')\n\n    if (\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      this.state.meta.errorMap?.[submitErrKey] &&\n      cause !== 'submit' &&\n      !hasErrored\n    ) {\n      this.setMeta((prev) => ({\n        ...prev,\n        errorMap: {\n          ...prev.errorMap,\n          [submitErrKey]: undefined,\n        },\n        errorSourceMap: {\n          ...prev.errorSourceMap,\n          [submitErrKey]: undefined,\n        },\n      }))\n    }\n\n    return { hasErrored }\n  }\n\n  /**\n   * @private\n   */\n  validateAsync = async (\n    cause: ValidationCause,\n    formValidationResultPromise: Promise<\n      FieldErrorMapFromValidator<\n        TParentData,\n        TName,\n        TData,\n        TOnMount,\n        TOnChange,\n        TOnChangeAsync,\n        TOnBlur,\n        TOnBlurAsync,\n        TOnSubmit,\n        TOnSubmitAsync\n      >\n    >,\n  ) => {\n    const validates = getAsyncValidatorArray(cause, {\n      ...this.options,\n      form: this.form,\n      validationLogic:\n        this.form.options.validationLogic || defaultValidationLogic,\n    })\n\n    // Get the field-specific error messages that are coming from the form's validator\n    const asyncFormValidationResults = await formValidationResultPromise\n\n    const linkedFields = this.getLinkedFields(cause)\n    const linkedFieldValidates = linkedFields.reduce(\n      (acc, field) => {\n        const fieldValidates = getAsyncValidatorArray(cause, {\n          ...field.options,\n          form: field.form,\n          validationLogic:\n            field.form.options.validationLogic || defaultValidationLogic,\n        })\n        fieldValidates.forEach((validate) => {\n          ;(validate as any).field = field\n        })\n        return acc.concat(fieldValidates as never)\n      },\n      [] as Array<\n        AsyncValidator<any> & {\n          field: AnyFieldApi\n        }\n      >,\n    )\n\n    /**\n     * We have to use a for loop and generate our promises this way, otherwise it won't be sync\n     * when there are no validators needed to be run\n     */\n    const validatesPromises: Promise<ValidationError | undefined>[] = []\n    const linkedPromises: Promise<ValidationError | undefined>[] = []\n\n    // Check if there are actual async validators to run before setting isValidating\n    // This prevents unnecessary re-renders when there are no async validators\n    // See: https://github.com/TanStack/form/issues/1130\n    const hasAsyncValidators =\n      validates.some((v) => v.validate) ||\n      linkedFieldValidates.some((v) => v.validate)\n\n    if (hasAsyncValidators) {\n      if (!this.state.meta.isValidating) {\n        this.setMeta((prev) => ({ ...prev, isValidating: true }))\n      }\n\n      for (const linkedField of linkedFields) {\n        linkedField.setMeta((prev) => ({ ...prev, isValidating: true }))\n      }\n    }\n\n    const validateFieldAsyncFn = (\n      field: AnyFieldApi,\n      validateObj: AsyncValidator<any>,\n      promises: Promise<ValidationError | undefined>[],\n    ) => {\n      const errorMapKey = getErrorMapKey(validateObj.cause)\n      const fieldValidatorMeta = field.getInfo().validationMetaMap[errorMapKey]\n\n      fieldValidatorMeta?.lastAbortController.abort()\n      const controller = new AbortController()\n\n      this.getInfo().validationMetaMap[errorMapKey] = {\n        lastAbortController: controller,\n      }\n\n      promises.push(\n        new Promise<ValidationError | undefined>(async (resolve) => {\n          let rawError!: ValidationError | undefined\n          try {\n            rawError = await new Promise((rawResolve, rawReject) => {\n              if (this.timeoutIds.validations[validateObj.cause]) {\n                clearTimeout(this.timeoutIds.validations[validateObj.cause]!)\n              }\n\n              this.timeoutIds.validations[validateObj.cause] = setTimeout(\n                async () => {\n                  if (controller.signal.aborted) return rawResolve(undefined)\n                  try {\n                    rawResolve(\n                      await this.runValidator({\n                        validate: validateObj.validate,\n                        value: {\n                          value: field.store.state.value,\n                          fieldApi: field,\n                          signal: controller.signal,\n                          validationSource: 'field',\n                        },\n                        type: 'validateAsync',\n                      }),\n                    )\n                  } catch (e) {\n                    rawReject(e)\n                  }\n                },\n                validateObj.debounceMs,\n              )\n            })\n          } catch (e: unknown) {\n            rawError = e as ValidationError\n          }\n          if (controller.signal.aborted) return resolve(undefined)\n\n          const fieldLevelError = normalizeError(rawError)\n          const formLevelError =\n            asyncFormValidationResults[this.name]?.[errorMapKey]\n\n          const { newErrorValue, newSource } =\n            determineFieldLevelErrorSourceAndValue({\n              formLevelError,\n              fieldLevelError,\n            })\n\n          field.setMeta((prev) => {\n            return {\n              ...prev,\n              errorMap: {\n                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n                ...prev?.errorMap,\n                [errorMapKey]: newErrorValue,\n              },\n              errorSourceMap: {\n                ...prev.errorSourceMap,\n                [errorMapKey]: newSource,\n              },\n            }\n          })\n\n          resolve(newErrorValue)\n        }),\n      )\n    }\n\n    // TODO: Dedupe this logic to reduce bundle size\n    for (const validateObj of validates) {\n      if (!validateObj.validate) continue\n      validateFieldAsyncFn(this, validateObj, validatesPromises)\n    }\n    for (const fieldValitateObj of linkedFieldValidates) {\n      if (!fieldValitateObj.validate) continue\n      validateFieldAsyncFn(\n        fieldValitateObj.field,\n        fieldValitateObj,\n        linkedPromises,\n      )\n    }\n\n    let results: ValidationError[] = []\n    if (validatesPromises.length || linkedPromises.length) {\n      results = await Promise.all(validatesPromises)\n      await Promise.all(linkedPromises)\n    }\n\n    // Only reset isValidating if we set it to true earlier\n    if (hasAsyncValidators) {\n      this.setMeta((prev) => ({ ...prev, isValidating: false }))\n\n      for (const linkedField of linkedFields) {\n        linkedField.setMeta((prev) => ({ ...prev, isValidating: false }))\n      }\n    }\n\n    return results.filter(Boolean)\n  }\n\n  /**\n   * Validates the field value.\n   */\n  validate = (\n    cause: ValidationCause,\n    opts?: { skipFormValidation?: boolean },\n  ): ValidationError[] | Promise<ValidationError[]> => {\n    // If the field is pristine, do not validate\n    if (!this.state.meta.isTouched) return []\n\n    // Attempt to sync validate first\n    const { fieldsErrorMap } = opts?.skipFormValidation\n      ? { fieldsErrorMap: {} as never }\n      : this.form.validateSync(cause)\n    const { hasErrored } = this.validateSync(\n      cause,\n      fieldsErrorMap[this.name] ?? {},\n    )\n\n    if (hasErrored && !this.options.asyncAlways) {\n      this.getInfo().validationMetaMap[\n        getErrorMapKey(cause)\n      ]?.lastAbortController.abort()\n      return this.state.meta.errors\n    }\n\n    // No error? Attempt async validation\n    const formValidationResultPromise = opts?.skipFormValidation\n      ? Promise.resolve({})\n      : this.form.validateAsync(cause)\n    return this.validateAsync(cause, formValidationResultPromise)\n  }\n\n  /**\n   * Handles the change event.\n   */\n  handleChange = (updater: Updater<TData>) => {\n    this.setValue(updater)\n  }\n\n  /**\n   * Handles the blur event.\n   */\n  handleBlur = () => {\n    const prevTouched = this.state.meta.isTouched\n    if (!prevTouched) {\n      this.setMeta((prev) => ({ ...prev, isTouched: true }))\n    }\n    if (!this.state.meta.isBlurred) {\n      this.setMeta((prev) => ({ ...prev, isBlurred: true }))\n    }\n    this.validate('blur')\n\n    this.triggerOnBlurListener()\n  }\n\n  /**\n   * Updates the field's errorMap\n   */\n  setErrorMap = (\n    errorMap: ValidationErrorMap<\n      UnwrapFieldValidateOrFn<TName, TOnMount, TFormOnMount>,\n      UnwrapFieldValidateOrFn<TName, TOnChange, TFormOnChange>,\n      UnwrapFieldAsyncValidateOrFn<TName, TOnChangeAsync, TFormOnChangeAsync>,\n      UnwrapFieldValidateOrFn<TName, TOnBlur, TFormOnBlur>,\n      UnwrapFieldAsyncValidateOrFn<TName, TOnBlurAsync, TFormOnBlurAsync>,\n      UnwrapFieldValidateOrFn<TName, TOnSubmit, TFormOnSubmit>,\n      UnwrapFieldAsyncValidateOrFn<TName, TOnSubmitAsync, TFormOnSubmitAsync>,\n      UnwrapFieldValidateOrFn<TName, TOnDynamic, TFormOnDynamic>,\n      UnwrapFieldAsyncValidateOrFn<TName, TOnDynamicAsync, TFormOnDynamicAsync>\n    >,\n  ) => {\n    this.setMeta((prev) => ({\n      ...prev,\n      errorMap: {\n        ...prev.errorMap,\n        ...errorMap,\n      },\n    }))\n  }\n\n  /**\n   * Parses the field's value with the given schema and returns\n   * issues (if any). This method does NOT set any internal errors.\n   * @param schema The standard schema to parse this field's value with.\n   */\n  parseValueWithSchema = (schema: StandardSchemaV1<TData, unknown>) => {\n    return standardSchemaValidators.validate(\n      { value: this.state.value, validationSource: 'field' },\n      schema,\n    )\n  }\n\n  /**\n   * Parses the field's value with the given schema and returns\n   * issues (if any). This method does NOT set any internal errors.\n   * @param schema The standard schema to parse this field's value with.\n   */\n  parseValueWithSchemaAsync = (schema: StandardSchemaV1<TData, unknown>) => {\n    return standardSchemaValidators.validateAsync(\n      { value: this.state.value, validationSource: 'field' },\n      schema,\n    )\n  }\n\n  private triggerOnBlurListener() {\n    const formDebounceMs = this.form.options.listeners?.onBlurDebounceMs\n    if (formDebounceMs && formDebounceMs > 0) {\n      if (this.timeoutIds.formListeners.blur) {\n        clearTimeout(this.timeoutIds.formListeners.blur)\n      }\n\n      this.timeoutIds.formListeners.blur = setTimeout(() => {\n        this.form.options.listeners?.onBlur?.({\n          formApi: this.form,\n          fieldApi: this,\n        })\n      }, formDebounceMs)\n    } else {\n      this.form.options.listeners?.onBlur?.({\n        formApi: this.form,\n        fieldApi: this,\n      })\n    }\n\n    const fieldDebounceMs = this.options.listeners?.onBlurDebounceMs\n    if (fieldDebounceMs && fieldDebounceMs > 0) {\n      if (this.timeoutIds.listeners.blur) {\n        clearTimeout(this.timeoutIds.listeners.blur)\n      }\n\n      this.timeoutIds.listeners.blur = setTimeout(() => {\n        this.options.listeners?.onBlur?.({\n          value: this.state.value,\n          fieldApi: this,\n        })\n      }, fieldDebounceMs)\n    } else {\n      this.options.listeners?.onBlur?.({\n        value: this.state.value,\n        fieldApi: this,\n      })\n    }\n  }\n\n  /**\n   * @private\n   */\n  triggerOnChangeListener = () => {\n    const formDebounceMs = this.form.options.listeners?.onChangeDebounceMs\n    if (formDebounceMs && formDebounceMs > 0) {\n      if (this.timeoutIds.formListeners.change) {\n        clearTimeout(this.timeoutIds.formListeners.change)\n      }\n\n      this.timeoutIds.formListeners.change = setTimeout(() => {\n        this.form.options.listeners?.onChange?.({\n          formApi: this.form,\n          fieldApi: this,\n        })\n      }, formDebounceMs)\n    } else {\n      this.form.options.listeners?.onChange?.({\n        formApi: this.form,\n        fieldApi: this,\n      })\n    }\n\n    const fieldDebounceMs = this.options.listeners?.onChangeDebounceMs\n    if (fieldDebounceMs && fieldDebounceMs > 0) {\n      if (this.timeoutIds.listeners.change) {\n        clearTimeout(this.timeoutIds.listeners.change)\n      }\n\n      this.timeoutIds.listeners.change = setTimeout(() => {\n        this.options.listeners?.onChange?.({\n          value: this.state.value,\n          fieldApi: this,\n        })\n      }, fieldDebounceMs)\n    } else {\n      this.options.listeners?.onChange?.({\n        value: this.state.value,\n        fieldApi: this,\n      })\n    }\n  }\n}\n\nfunction normalizeError(rawError?: ValidationError) {\n  if (rawError) {\n    return rawError\n  }\n\n  return undefined\n}\n\nfunction getErrorMapKey(cause: ValidationCause) {\n  switch (cause) {\n    case 'submit':\n      return 'onSubmit'\n    case 'blur':\n      return 'onBlur'\n    case 'mount':\n      return 'onMount'\n    case 'server':\n      return 'onServer'\n    case 'dynamic':\n      return 'onDynamic'\n    case 'change':\n    default:\n      return 'onChange'\n  }\n}\n"],"names":["opts"],"mappings":";;;;;AAk9BO,MAAM,SAkDX;AAAA;AAAA;AAAA;AAAA,EAwGA,YACE,MAyBA;AA9FF,SAAA,UAwBI,CAAA;AA8JJ,SAAA,QAAQ,MAAM;AACZ,YAAM,UAAU,KAAK,MAAM,MAAA;AAE3B,UAAI,KAAK,QAAQ,iBAAiB,UAAa,CAAC,KAAK,QAAA,EAAU,WAAW;AACxE,aAAK,KAAK,cAAc,KAAK,MAAM,KAAK,QAAQ,cAAc;AAAA,UAC5D,gBAAgB;AAAA,QAAA,CACjB;AAAA,MACH;AAEA,YAAM,OAAO,KAAK,QAAA;AAClB,WAAK,WAAW;AAEhB,WAAK,OAAO,KAAK,OAAgB;AAEjC,YAAM,EAAE,QAAA,IAAY,KAAK,QAAQ,cAAc,CAAA;AAE/C,UAAI,SAAS;AACX,cAAM,QAAQ,KAAK,aAAa;AAAA,UAC9B,UAAU;AAAA,UACV,OAAO;AAAA,YACL,OAAO,KAAK,MAAM;AAAA,YAClB,UAAU;AAAA,YACV,kBAAkB;AAAA,UAAA;AAAA,UAEpB,MAAM;AAAA,QAAA,CACP;AACD,YAAI,OAAO;AACT,eAAK;AAAA,YACH,CAAC,UACE;AAAA,cACC,GAAG;AAAA;AAAA,cAEH,UAAU,EAAE,GAAG,MAAM,UAAU,SAAS,MAAA;AAAA,cACxC,gBAAgB;AAAA;AAAA,gBAEd,GAAG,MAAM;AAAA,gBACT,SAAS;AAAA,cAAA;AAAA,YACX;AAAA,UACF;AAAA,QAEN;AAAA,MACF;AAEA,WAAK,QAAQ,WAAW,UAAU;AAAA,QAChC,OAAO,KAAK,MAAM;AAAA,QAClB,UAAU;AAAA,MAAA,CACX;AAED,aAAO;AAAA,IACT;AAKA,SAAA,SAAS,CACPA,UAyBG;AACH,WAAK,UAAUA;AACf,WAAK,OAAOA,MAAK;AAGjB,UAAI,CAAC,KAAK,MAAM,KAAK,aAAa,KAAK,QAAQ,iBAAiB,QAAW;AACzE,cAAM,YAAY,KAAK,KAAK,cAAc,KAAK,IAAI;AACnD,YAAI,CAAC,SAAS,WAAWA,MAAK,YAAY,GAAG;AAC3C,eAAK,KAAK,cAAc,KAAK,MAAMA,MAAK,cAAuB;AAAA,YAC7D,gBAAgB;AAAA,YAChB,cAAc;AAAA,YACd,kBAAkB;AAAA,UAAA,CACnB;AAAA,QACH;AAAA,MACF;AAEA,UAAI,CAAC,KAAK,KAAK,aAAa,KAAK,IAAI,GAAG;AACtC,aAAK,KAAK,aAAa,KAAK,MAAM,KAAK,MAAM,IAAI;AAAA,MACnD;AAAA,IACF;AAMA,SAAA,WAAW,MAAa;AACtB,aAAO,KAAK,KAAK,cAAc,KAAK,IAAI;AAAA,IAC1C;AAKA,SAAA,WAAW,CAAC,SAAyB,YAAgC;AACnE,WAAK,KAAK;AAAA,QACR,KAAK;AAAA,QACL;AAAA,QACA,UAAU,SAAS,EAAE,kBAAkB,MAAM,cAAc,MAAM;AAAA,MAAA;AAGnE,UAAI,CAAC,SAAS,kBAAkB;AAC9B,aAAK,wBAAA;AAAA,MACP;AAEA,UAAI,CAAC,SAAS,cAAc;AAC1B,aAAK,SAAS,QAAQ;AAAA,MACxB;AAAA,IACF;AAEA,SAAA,UAAU,MAAM,KAAK,MAAM,MAAM;AAKjC,SAAA,UAAU,CACR,YAyBG,KAAK,KAAK,aAAa,KAAK,MAAM,OAAO;AAK9C,SAAA,UAAU,MAAM,KAAK,KAAK,aAAa,KAAK,IAAI;AAKhD,SAAA,YAAY,CACV,OACA,YACG;AACH,WAAK,KAAK;AAAA,QACR,KAAK;AAAA,QACL;AAAA,QACA,UAAU,SAAS,EAAE,kBAAkB,MAAM;AAAA,MAAA;AAG/C,UAAI,CAAC,SAAS,kBAAkB;AAC9B,aAAK,wBAAA;AAAA,MACP;AAAA,IACF;AAKA,SAAA,cAAc,CACZ,OACA,OACA,YACG;AACH,WAAK,KAAK;AAAA,QACR,KAAK;AAAA,QACL;AAAA,QACA;AAAA,QACA,UAAU,SAAS,EAAE,kBAAkB,MAAM;AAAA,MAAA;AAG/C,UAAI,CAAC,SAAS,kBAAkB;AAC9B,aAAK,wBAAA;AAAA,MACP;AAAA,IACF;AAKA,SAAA,eAAe,CACb,OACA,OACA,YACG;AACH,WAAK,KAAK;AAAA,QACR,KAAK;AAAA,QACL;AAAA,QACA;AAAA,QACA,UAAU,SAAS,EAAE,kBAAkB,MAAM;AAAA,MAAA;AAG/C,UAAI,CAAC,SAAS,kBAAkB;AAC9B,aAAK,wBAAA;AAAA,MACP;AAAA,IACF;AAKA,SAAA,cAAc,CAAC,OAAe,YAAgC;AAC5D,WAAK,KAAK;AAAA,QACR,KAAK;AAAA,QACL;AAAA,QACA,UAAU,SAAS,EAAE,kBAAkB,MAAM;AAAA,MAAA;AAG/C,UAAI,CAAC,SAAS,kBAAkB;AAC9B,aAAK,wBAAA;AAAA,MACP;AAAA,IACF;AAKA,SAAA,aAAa,CACX,QACA,QACA,YACG;AACH,WAAK,KAAK;AAAA,QACR,KAAK;AAAA,QACL;AAAA,QACA;AAAA,QACA,UAAU,SAAS,EAAE,kBAAkB,MAAM;AAAA,MAAA;AAG/C,UAAI,CAAC,SAAS,kBAAkB;AAC9B,aAAK,wBAAA;AAAA,MACP;AAAA,IACF;AAKA,SAAA,YAAY,CAAC,QAAgB,QAAgB,YAAgC;AAC3E,WAAK,KAAK;AAAA,QACR,KAAK;AAAA,QACL;AAAA,QACA;AAAA,QACA,UAAU,SAAS,EAAE,kBAAkB,MAAM;AAAA,MAAA;AAG/C,UAAI,CAAC,SAAS,kBAAkB;AAC9B,aAAK,wBAAA;AAAA,MACP;AAAA,IACF;AAKA,SAAA,cAAc,CAAC,YAAgC;AAC7C,WAAK,KAAK;AAAA,QACR,KAAK;AAAA,QACL,UAAU,SAAS,EAAE,kBAAkB,MAAM;AAAA,MAAA;AAG/C,UAAI,CAAC,SAAS,kBAAkB;AAC9B,aAAK,wBAAA;AAAA,MACP;AAAA,IACF;AAKA,SAAA,kBAAkB,CAAC,UAA2B;AAC5C,YAAM,SAAS,OAAO,OAAO,KAAK,KAAK,SAAS;AAEhD,YAAM,eAA8B,CAAA;AACpC,iBAAW,SAAS,QAAQ;AAC1B,YAAI,CAAC,MAAM,SAAU;AACrB,cAAM,EAAE,kBAAkB,eAAA,IACxB,MAAM,SAAS,QAAQ,cAAc,CAAA;AACvC,YAAI,UAAU,YAAY,kBAAkB,SAAS,KAAK,IAAI,GAAG;AAC/D,uBAAa,KAAK,MAAM,QAAQ;AAAA,QAClC;AACA,YAAI,UAAU,UAAU,gBAAgB,SAAS,KAAK,IAAc,GAAG;AACrE,uBAAa,KAAK,MAAM,QAAQ;AAAA,QAClC;AAAA,MACF;AAEA,aAAO;AAAA,IACT;AAKA,SAAA,eAAe,CACb,OACA,kBACG;AACH,YAAM,YAAY,sBAAsB,OAAO;AAAA,QAC7C,GAAG,KAAK;AAAA,QACR,MAAM,KAAK;AAAA,QACX,iBACE,KAAK,KAAK,QAAQ,mBAAmB;AAAA,MAAA,CACxC;AAED,YAAM,eAAe,KAAK,gBAAgB,KAAK;AAC/C,YAAM,uBAAuB,aAAa;AAAA,QACxC,CAAC,KAAK,UAAU;AACd,gBAAM,iBAAiB,sBAAsB,OAAO;AAAA,YAClD,GAAG,MAAM;AAAA,YACT,MAAM,MAAM;AAAA,YACZ,iBACE,MAAM,KAAK,QAAQ,mBAAmB;AAAA,UAAA,CACzC;AACD,yBAAe,QAAQ,CAAC,aAAa;AACjC,qBAAiB,QAAQ;AAAA,UAC7B,CAAC;AACD,iBAAO,IAAI,OAAO,cAAuB;AAAA,QAC3C;AAAA,QACA,CAAA;AAAA,MAAC;AAQH,UAAI,aAAa;AAEjB,YAAM,MAAM;AACV,cAAM,kBAAkB,CACtB,OACA,gBACG;AACH,gBAAM,cAAc,eAAe,YAAY,KAAK;AAEpD,gBAAM,kBAAkB,YAAY,WAChC;AAAA,YACE,MAAM,aAAa;AAAA,cACjB,UAAU,YAAY;AAAA,cACtB,OAAO;AAAA,gBACL,OAAO,MAAM,MAAM,MAAM;AAAA,gBACzB,kBAAkB;AAAA,gBAClB,UAAU;AAAA,cAAA;AAAA,cAEZ,MAAM;AAAA,YAAA,CACP;AAAA,UAAA,IAEH;AAEJ,gBAAM,iBAAiB,cAAc,WAAW;AAEhD,gBAAM,EAAE,eAAe,UAAA,IACrB,uCAAuC;AAAA,YACrC;AAAA,YACA;AAAA,UAAA,CACD;AAGH,cAAI,MAAM,MAAM,KAAK,WAAW,WAAW,MAAM,eAAe;AAC9D,kBAAM,QAAQ,CAAC,UAAU;AAAA,cACvB,GAAG;AAAA,cACH,UAAU;AAAA,gBACR,GAAG,KAAK;AAAA,gBACR,CAAC,WAAW,GAAG;AAAA,cAAA;AAAA,cAEjB,gBAAgB;AAAA,gBACd,GAAG,KAAK;AAAA,gBACR,CAAC,WAAW,GAAG;AAAA,cAAA;AAAA,YACjB,EACA;AAAA,UACJ;AACA,cAAI,eAAe;AACjB,yBAAa;AAAA,UACf;AAAA,QACF;AAEA,mBAAW,eAAe,WAAW;AACnC,0BAAgB,MAAM,WAAW;AAAA,QACnC;AACA,mBAAW,oBAAoB,sBAAsB;AACnD,cAAI,CAAC,iBAAiB,SAAU;AAChC,0BAAgB,iBAAiB,OAAO,gBAAgB;AAAA,QAC1D;AAAA,MACF,CAAC;AAMD,YAAM,eAAe,eAAe,QAAQ;AAE5C;AAAA;AAAA,QAEE,KAAK,MAAM,KAAK,WAAW,YAAY,KACvC,UAAU,YACV,CAAC;AAAA,QACD;AACA,aAAK,QAAQ,CAAC,UAAU;AAAA,UACtB,GAAG;AAAA,UACH,UAAU;AAAA,YACR,GAAG,KAAK;AAAA,YACR,CAAC,YAAY,GAAG;AAAA,UAAA;AAAA,UAElB,gBAAgB;AAAA,YACd,GAAG,KAAK;AAAA,YACR,CAAC,YAAY,GAAG;AAAA,UAAA;AAAA,QAClB,EACA;AAAA,MACJ;AAEA,aAAO,EAAE,WAAA;AAAA,IACX;AAKA,SAAA,gBAAgB,OACd,OACA,gCAcG;AACH,YAAM,YAAY,uBAAuB,OAAO;AAAA,QAC9C,GAAG,KAAK;AAAA,QACR,MAAM,KAAK;AAAA,QACX,iBACE,KAAK,KAAK,QAAQ,mBAAmB;AAAA,MAAA,CACxC;AAGD,YAAM,6BAA6B,MAAM;AAEzC,YAAM,eAAe,KAAK,gBAAgB,KAAK;AAC/C,YAAM,uBAAuB,aAAa;AAAA,QACxC,CAAC,KAAK,UAAU;AACd,gBAAM,iBAAiB,uBAAuB,OAAO;AAAA,YACnD,GAAG,MAAM;AAAA,YACT,MAAM,MAAM;AAAA,YACZ,iBACE,MAAM,KAAK,QAAQ,mBAAmB;AAAA,UAAA,CACzC;AACD,yBAAe,QAAQ,CAAC,aAAa;AACjC,qBAAiB,QAAQ;AAAA,UAC7B,CAAC;AACD,iBAAO,IAAI,OAAO,cAAuB;AAAA,QAC3C;AAAA,QACA,CAAA;AAAA,MAAC;AAWH,YAAM,oBAA4D,CAAA;AAClE,YAAM,iBAAyD,CAAA;AAK/D,YAAM,qBACJ,UAAU,KAAK,CAAC,MAAM,EAAE,QAAQ,KAChC,qBAAqB,KAAK,CAAC,MAAM,EAAE,QAAQ;AAE7C,UAAI,oBAAoB;AACtB,YAAI,CAAC,KAAK,MAAM,KAAK,cAAc;AACjC,eAAK,QAAQ,CAAC,UAAU,EAAE,GAAG,MAAM,cAAc,OAAO;AAAA,QAC1D;AAEA,mBAAW,eAAe,cAAc;AACtC,sBAAY,QAAQ,CAAC,UAAU,EAAE,GAAG,MAAM,cAAc,OAAO;AAAA,QACjE;AAAA,MACF;AAEA,YAAM,uBAAuB,CAC3B,OACA,aACA,aACG;AACH,cAAM,cAAc,eAAe,YAAY,KAAK;AACpD,cAAM,qBAAqB,MAAM,QAAA,EAAU,kBAAkB,WAAW;AAExE,4BAAoB,oBAAoB,MAAA;AACxC,cAAM,aAAa,IAAI,gBAAA;AAEvB,aAAK,QAAA,EAAU,kBAAkB,WAAW,IAAI;AAAA,UAC9C,qBAAqB;AAAA,QAAA;AAGvB,iBAAS;AAAA,UACP,IAAI,QAAqC,OAAO,YAAY;AAC1D,gBAAI;AACJ,gBAAI;AACF,yBAAW,MAAM,IAAI,QAAQ,CAAC,YAAY,cAAc;AACtD,oBAAI,KAAK,WAAW,YAAY,YAAY,KAAK,GAAG;AAClD,+BAAa,KAAK,WAAW,YAAY,YAAY,KAAK,CAAE;AAAA,gBAC9D;AAEA,qBAAK,WAAW,YAAY,YAAY,KAAK,IAAI;AAAA,kBAC/C,YAAY;AACV,wBAAI,WAAW,OAAO,QAAS,QAAO,WAAW,MAAS;AAC1D,wBAAI;AACF;AAAA,wBACE,MAAM,KAAK,aAAa;AAAA,0BACtB,UAAU,YAAY;AAAA,0BACtB,OAAO;AAAA,4BACL,OAAO,MAAM,MAAM,MAAM;AAAA,4BACzB,UAAU;AAAA,4BACV,QAAQ,WAAW;AAAA,4BACnB,kBAAkB;AAAA,0BAAA;AAAA,0BAEpB,MAAM;AAAA,wBAAA,CACP;AAAA,sBAAA;AAAA,oBAEL,SAAS,GAAG;AACV,gCAAU,CAAC;AAAA,oBACb;AAAA,kBACF;AAAA,kBACA,YAAY;AAAA,gBAAA;AAAA,cAEhB,CAAC;AAAA,YACH,SAAS,GAAY;AACnB,yBAAW;AAAA,YACb;AACA,gBAAI,WAAW,OAAO,QAAS,QAAO,QAAQ,MAAS;AAEvD,kBAAM,kBAAkB,eAAe,QAAQ;AAC/C,kBAAM,iBACJ,2BAA2B,KAAK,IAAI,IAAI,WAAW;AAErD,kBAAM,EAAE,eAAe,UAAA,IACrB,uCAAuC;AAAA,cACrC;AAAA,cACA;AAAA,YAAA,CACD;AAEH,kBAAM,QAAQ,CAAC,SAAS;AACtB,qBAAO;AAAA,gBACL,GAAG;AAAA,gBACH,UAAU;AAAA;AAAA,kBAER,GAAG,MAAM;AAAA,kBACT,CAAC,WAAW,GAAG;AAAA,gBAAA;AAAA,gBAEjB,gBAAgB;AAAA,kBACd,GAAG,KAAK;AAAA,kBACR,CAAC,WAAW,GAAG;AAAA,gBAAA;AAAA,cACjB;AAAA,YAEJ,CAAC;AAED,oBAAQ,aAAa;AAAA,UACvB,CAAC;AAAA,QAAA;AAAA,MAEL;AAGA,iBAAW,eAAe,WAAW;AACnC,YAAI,CAAC,YAAY,SAAU;AAC3B,6BAAqB,MAAM,aAAa,iBAAiB;AAAA,MAC3D;AACA,iBAAW,oBAAoB,sBAAsB;AACnD,YAAI,CAAC,iBAAiB,SAAU;AAChC;AAAA,UACE,iBAAiB;AAAA,UACjB;AAAA,UACA;AAAA,QAAA;AAAA,MAEJ;AAEA,UAAI,UAA6B,CAAA;AACjC,UAAI,kBAAkB,UAAU,eAAe,QAAQ;AACrD,kBAAU,MAAM,QAAQ,IAAI,iBAAiB;AAC7C,cAAM,QAAQ,IAAI,cAAc;AAAA,MAClC;AAGA,UAAI,oBAAoB;AACtB,aAAK,QAAQ,CAAC,UAAU,EAAE,GAAG,MAAM,cAAc,QAAQ;AAEzD,mBAAW,eAAe,cAAc;AACtC,sBAAY,QAAQ,CAAC,UAAU,EAAE,GAAG,MAAM,cAAc,QAAQ;AAAA,QAClE;AAAA,MACF;AAEA,aAAO,QAAQ,OAAO,OAAO;AAAA,IAC/B;AAKA,SAAA,WAAW,CACT,OACAA,UACmD;AAEnD,UAAI,CAAC,KAAK,MAAM,KAAK,kBAAkB,CAAA;AAGvC,YAAM,EAAE,eAAA,IAAmBA,OAAM,qBAC7B,EAAE,gBAAgB,CAAA,EAAC,IACnB,KAAK,KAAK,aAAa,KAAK;AAChC,YAAM,EAAE,eAAe,KAAK;AAAA,QAC1B;AAAA,QACA,eAAe,KAAK,IAAI,KAAK,CAAA;AAAA,MAAC;AAGhC,UAAI,cAAc,CAAC,KAAK,QAAQ,aAAa;AAC3C,aAAK,QAAA,EAAU,kBACb,eAAe,KAAK,CACtB,GAAG,oBAAoB,MAAA;AACvB,eAAO,KAAK,MAAM,KAAK;AAAA,MACzB;AAGA,YAAM,8BAA8BA,OAAM,qBACtC,QAAQ,QAAQ,CAAA,CAAE,IAClB,KAAK,KAAK,cAAc,KAAK;AACjC,aAAO,KAAK,cAAc,OAAO,2BAA2B;AAAA,IAC9D;AAKA,SAAA,eAAe,CAAC,YAA4B;AAC1C,WAAK,SAAS,OAAO;AAAA,IACvB;AAKA,SAAA,aAAa,MAAM;AACjB,YAAM,cAAc,KAAK,MAAM,KAAK;AACpC,UAAI,CAAC,aAAa;AAChB,aAAK,QAAQ,CAAC,UAAU,EAAE,GAAG,MAAM,WAAW,OAAO;AAAA,MACvD;AACA,UAAI,CAAC,KAAK,MAAM,KAAK,WAAW;AAC9B,aAAK,QAAQ,CAAC,UAAU,EAAE,GAAG,MAAM,WAAW,OAAO;AAAA,MACvD;AACA,WAAK,SAAS,MAAM;AAEpB,WAAK,sBAAA;AAAA,IACP;AAKA,SAAA,cAAc,CACZ,aAWG;AACH,WAAK,QAAQ,CAAC,UAAU;AAAA,QACtB,GAAG;AAAA,QACH,UAAU;AAAA,UACR,GAAG,KAAK;AAAA,UACR,GAAG;AAAA,QAAA;AAAA,MACL,EACA;AAAA,IACJ;AAOA,SAAA,uBAAuB,CAAC,WAA6C;AACnE,aAAO,yBAAyB;AAAA,QAC9B,EAAE,OAAO,KAAK,MAAM,OAAO,kBAAkB,QAAA;AAAA,QAC7C;AAAA,MAAA;AAAA,IAEJ;AAOA,SAAA,4BAA4B,CAAC,WAA6C;AACxE,aAAO,yBAAyB;AAAA,QAC9B,EAAE,OAAO,KAAK,MAAM,OAAO,kBAAkB,QAAA;AAAA,QAC7C;AAAA,MAAA;AAAA,IAEJ;AA6CA,SAAA,0BAA0B,MAAM;AAC9B,YAAM,iBAAiB,KAAK,KAAK,QAAQ,WAAW;AACpD,UAAI,kBAAkB,iBAAiB,GAAG;AACxC,YAAI,KAAK,WAAW,cAAc,QAAQ;AACxC,uBAAa,KAAK,WAAW,cAAc,MAAM;AAAA,QACnD;AAEA,aAAK,WAAW,cAAc,SAAS,WAAW,MAAM;AACtD,eAAK,KAAK,QAAQ,WAAW,WAAW;AAAA,YACtC,SAAS,KAAK;AAAA,YACd,UAAU;AAAA,UAAA,CACX;AAAA,QACH,GAAG,cAAc;AAAA,MACnB,OAAO;AACL,aAAK,KAAK,QAAQ,WAAW,WAAW;AAAA,UACtC,SAAS,KAAK;AAAA,UACd,UAAU;AAAA,QAAA,CACX;AAAA,MACH;AAEA,YAAM,kBAAkB,KAAK,QAAQ,WAAW;AAChD,UAAI,mBAAmB,kBAAkB,GAAG;AAC1C,YAAI,KAAK,WAAW,UAAU,QAAQ;AACpC,uBAAa,KAAK,WAAW,UAAU,MAAM;AAAA,QAC/C;AAEA,aAAK,WAAW,UAAU,SAAS,WAAW,MAAM;AAClD,eAAK,QAAQ,WAAW,WAAW;AAAA,YACjC,OAAO,KAAK,MAAM;AAAA,YAClB,UAAU;AAAA,UAAA,CACX;AAAA,QACH,GAAG,eAAe;AAAA,MACpB,OAAO;AACL,aAAK,QAAQ,WAAW,WAAW;AAAA,UACjC,OAAO,KAAK,MAAM;AAAA,UAClB,UAAU;AAAA,QAAA,CACX;AAAA,MACH;AAAA,IACF;AAh4BE,SAAK,OAAO,KAAK;AACjB,SAAK,OAAO,KAAK;AACjB,SAAK,UAAU;AAEf,SAAK,aAAa;AAAA,MAChB,aAAa,CAAA;AAAA,MACb,WAAW,CAAA;AAAA,MACX,eAAe,CAAA;AAAA,IAAC;AAGlB,SAAK,QAAQ,IAAI,QAAQ;AAAA,MACvB,MAAM,CAAC,KAAK,KAAK,KAAK;AAAA,MACtB,IAAI,MAAM;AACR,cAAM,OAAO,KAAK,KAAK,aAAa,KAAK,IAAI,KAAK;AAAA,UAChD,GAAG;AAAA,UACH,GAAG,KAAK;AAAA,QAAA;AAGV,YAAI,QAAQ,KAAK,KAAK,cAAc,KAAK,IAAI;AAC7C,YACE,CAAC,KAAK,aACL,UAAsB,UACvB,KAAK,QAAQ,iBAAiB,UAC9B,CAAC,SAAS,OAAO,KAAK,QAAQ,YAAY,GAC1C;AACA,kBAAQ,KAAK,QAAQ;AAAA,QACvB;AAEA,eAAO;AAAA,UACL;AAAA,UACA;AAAA,QAAA;AAAA,MAwBJ;AAAA,IAAA,CACD;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EA/FA,IAAI,QAAQ;AACV,WAAO,KAAK,MAAM;AAAA,EACpB;AAAA;AAAA;AAAA;AAAA,EAkGA,aAKE,OAOU;AACV,QAAI,0BAA0B,MAAM,QAAQ,GAAG;AAC7C,aAAO,yBAAyB,MAAM,IAAI;AAAA,QACxC,MAAM;AAAA,QACN,MAAM;AAAA,MAAA;AAAA,IAEV;AAEA,WAAQ,MAAM,SAAuC,MAAM,KAAK;AAAA,EAClE;AAAA,EA6tBQ,wBAAwB;AAC9B,UAAM,iBAAiB,KAAK,KAAK,QAAQ,WAAW;AACpD,QAAI,kBAAkB,iBAAiB,GAAG;AACxC,UAAI,KAAK,WAAW,cAAc,MAAM;AACtC,qBAAa,KAAK,WAAW,cAAc,IAAI;AAAA,MACjD;AAEA,WAAK,WAAW,cAAc,OAAO,WAAW,MAAM;AACpD,aAAK,KAAK,QAAQ,WAAW,SAAS;AAAA,UACpC,SAAS,KAAK;AAAA,UACd,UAAU;AAAA,QAAA,CACX;AAAA,MACH,GAAG,cAAc;AAAA,IACnB,OAAO;AACL,WAAK,KAAK,QAAQ,WAAW,SAAS;AAAA,QACpC,SAAS,KAAK;AAAA,QACd,UAAU;AAAA,MAAA,CACX;AAAA,IACH;AAEA,UAAM,kBAAkB,KAAK,QAAQ,WAAW;AAChD,QAAI,mBAAmB,kBAAkB,GAAG;AAC1C,UAAI,KAAK,WAAW,UAAU,MAAM;AAClC,qBAAa,KAAK,WAAW,UAAU,IAAI;AAAA,MAC7C;AAEA,WAAK,WAAW,UAAU,OAAO,WAAW,MAAM;AAChD,aAAK,QAAQ,WAAW,SAAS;AAAA,UAC/B,OAAO,KAAK,MAAM;AAAA,UAClB,UAAU;AAAA,QAAA,CACX;AAAA,MACH,GAAG,eAAe;AAAA,IACpB,OAAO;AACL,WAAK,QAAQ,WAAW,SAAS;AAAA,QAC/B,OAAO,KAAK,MAAM;AAAA,QAClB,UAAU;AAAA,MAAA,CACX;AAAA,IACH;AAAA,EACF;AA4CF;AAEA,SAAS,eAAe,UAA4B;AAClD,MAAI,UAAU;AACZ,WAAO;AAAA,EACT;AAEA,SAAO;AACT;AAEA,SAAS,eAAe,OAAwB;AAC9C,UAAQ,OAAA;AAAA,IACN,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AACH,aAAO;AAAA,IACT,KAAK;AAAA,IACL;AACE,aAAO;AAAA,EAAA;AAEb;"}
\ No newline at end of file
+{"version":3,"file":"FieldApi.js","sources":["../../src/FieldApi.ts"],"sourcesContent":["import { Derived, batch } from '@tanstack/store'\nimport {\n  isStandardSchemaValidator,\n  standardSchemaValidators,\n} from './standardSchemaValidator'\nimport { defaultFieldMeta } from './metaHelper'\nimport {\n  determineFieldLevelErrorSourceAndValue,\n  evaluate,\n  getAsyncValidatorArray,\n  getBy,\n  getSyncValidatorArray,\n  mergeOpts,\n} from './utils'\nimport { defaultValidationLogic } from './ValidationLogic'\nimport type { DeepKeys, DeepValue, UnwrapOneLevelOfArray } from './util-types'\nimport type {\n  StandardSchemaV1,\n  StandardSchemaV1Issue,\n  TStandardSchemaValidatorValue,\n} from './standardSchemaValidator'\nimport type {\n  FieldInfo,\n  FormApi,\n  FormAsyncValidateOrFn,\n  FormValidateAsyncFn,\n  FormValidateFn,\n  FormValidateOrFn,\n} from './FormApi'\nimport type {\n  ListenerCause,\n  UpdateMetaOptions,\n  ValidationCause,\n  ValidationError,\n  ValidationErrorMap,\n  ValidationErrorMapSource,\n} from './types'\nimport type { AsyncValidator, SyncValidator, Updater } from './utils'\n\n/**\n * @private\n */\n// TODO: Add the `Unwrap` type to the errors\ntype FieldErrorMapFromValidator<\n  TFormData,\n  TName extends DeepKeys<TFormData>,\n  TData extends DeepValue<TFormData, TName>,\n  TOnMount extends undefined | FieldValidateOrFn<TFormData, TName, TData>,\n  TOnChange extends undefined | FieldValidateOrFn<TFormData, TName, TData>,\n  TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TFormData, TName, TData>,\n  TOnBlur extends undefined | FieldValidateOrFn<TFormData, TName, TData>,\n  TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TFormData, TName, TData>,\n  TOnSubmit extends undefined | FieldValidateOrFn<TFormData, TName, TData>,\n  TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TFormData, TName, TData>,\n> = Partial<\n  Record<\n    DeepKeys<TFormData>,\n    ValidationErrorMap<\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync\n    >\n  >\n>\n\n/**\n * @private\n */\nexport type FieldValidateFn<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n> = (props: {\n  value: TData\n  fieldApi: FieldApi<\n    TParentData,\n    TName,\n    TData,\n    // This is technically an edge-type; which we try to keep non-`any`, but in this case\n    // It's referring to an inaccessible type from the field validate function inner types, so it's not a big deal\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any\n  >\n}) => unknown\n\n/**\n * @private\n */\nexport type FieldValidateOrFn<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n> =\n  | FieldValidateFn<TParentData, TName, TData>\n  | StandardSchemaV1<TData, unknown>\n\ntype StandardBrandedSchemaV1<T> = T & { __standardSchemaV1: true }\n\ntype UnwrapFormValidateOrFnForInner<\n  TValidateOrFn extends undefined | FormValidateOrFn<any>,\n> = [TValidateOrFn] extends [FormValidateFn<any>]\n  ? ReturnType<TValidateOrFn>\n  : [TValidateOrFn] extends [StandardSchemaV1<infer TOut, any>]\n    ? StandardBrandedSchemaV1<TOut>\n    : undefined\n\nexport type UnwrapFieldValidateOrFn<\n  TName extends string,\n  TValidateOrFn extends undefined | FieldValidateOrFn<any, any, any>,\n  TFormValidateOrFn extends undefined | FormValidateOrFn<any>,\n> =\n  | ([TFormValidateOrFn] extends [StandardSchemaV1<any, infer TStandardOut>]\n      ? TName extends keyof TStandardOut\n        ? StandardSchemaV1Issue[]\n        : undefined\n      : undefined)\n  | (UnwrapFormValidateOrFnForInner<TFormValidateOrFn> extends infer TFormValidateVal\n      ? TFormValidateVal extends { __standardSchemaV1: true }\n        ? [DeepValue<TFormValidateVal, TName>] extends [never]\n          ? undefined\n          : StandardSchemaV1Issue[]\n        : TFormValidateVal extends { fields: any }\n          ? TName extends keyof TFormValidateVal['fields']\n            ? TFormValidateVal['fields'][TName]\n            : undefined\n          : undefined\n      : never)\n  | ([TValidateOrFn] extends [FieldValidateFn<any, any, any>]\n      ? ReturnType<TValidateOrFn>\n      : [TValidateOrFn] extends [StandardSchemaV1<any, any>]\n        ? // TODO: Check if `disableErrorFlat` is enabled, if so, return StandardSchemaV1Issue[][]\n          StandardSchemaV1Issue[]\n        : undefined)\n\n/**\n * @private\n */\nexport type FieldValidateAsyncFn<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n> = (options: {\n  value: TData\n  fieldApi: FieldApi<\n    TParentData,\n    TName,\n    TData,\n    // This is technically an edge-type; which we try to keep non-`any`, but in this case\n    // It's referring to an inaccessible type from the field validate function inner types, so it's not a big deal\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any\n  >\n  signal: AbortSignal\n}) => unknown | Promise<unknown>\n\n/**\n * @private\n */\nexport type FieldAsyncValidateOrFn<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n> =\n  | FieldValidateAsyncFn<TParentData, TName, TData>\n  | StandardSchemaV1<TData, unknown>\n\ntype UnwrapFormAsyncValidateOrFnForInner<\n  TValidateOrFn extends undefined | FormAsyncValidateOrFn<any>,\n> = [TValidateOrFn] extends [FormValidateAsyncFn<any>]\n  ? Awaited<ReturnType<TValidateOrFn>>\n  : [TValidateOrFn] extends [StandardSchemaV1<infer TOut, any>]\n    ? StandardBrandedSchemaV1<TOut>\n    : undefined\n\nexport type UnwrapFieldAsyncValidateOrFn<\n  TName extends string,\n  TValidateOrFn extends undefined | FieldAsyncValidateOrFn<any, any, any>,\n  TFormValidateOrFn extends undefined | FormAsyncValidateOrFn<any>,\n> =\n  | ([TFormValidateOrFn] extends [StandardSchemaV1<any, infer TStandardOut>]\n      ? TName extends keyof TStandardOut\n        ? StandardSchemaV1Issue[]\n        : undefined\n      : undefined)\n  | (UnwrapFormAsyncValidateOrFnForInner<TFormValidateOrFn> extends infer TFormValidateVal\n      ? TFormValidateVal extends { __standardSchemaV1: true }\n        ? [DeepValue<TFormValidateVal, TName>] extends [never]\n          ? undefined\n          : StandardSchemaV1Issue[]\n        : TFormValidateVal extends { fields: any }\n          ? TName extends keyof TFormValidateVal['fields']\n            ? TFormValidateVal['fields'][TName]\n            : undefined\n          : undefined\n      : never)\n  | ([TValidateOrFn] extends [FieldValidateAsyncFn<any, any, any>]\n      ? Awaited<ReturnType<TValidateOrFn>>\n      : [TValidateOrFn] extends [StandardSchemaV1<any, any>]\n        ? // TODO: Check if `disableErrorFlat` is enabled, if so, return StandardSchemaV1Issue[][]\n          StandardSchemaV1Issue[]\n        : undefined)\n\n/**\n * @private\n */\nexport type FieldListenerFn<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n> = (props: {\n  value: TData\n  fieldApi: FieldApi<\n    TParentData,\n    TName,\n    TData,\n    // This is technically an edge-type; which we try to keep non-`any`, but in this case\n    // It's referring to an inaccessible type from the field listener function inner types, so it's not a big deal\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any\n  >\n}) => void\n\nexport interface FieldValidators<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName>,\n  TOnMount extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChange extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnBlur extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnSubmit extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnDynamic extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnDynamicAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n> {\n  /**\n   * An optional function, that runs on the mount event of input.\n   */\n  onMount?: TOnMount\n  /**\n   * An optional function, that runs on the change event of input.\n   *\n   * @example z.string().min(1)\n   */\n  onChange?: TOnChange\n  /**\n   * An optional property similar to `onChange` but async validation\n   *\n   * @example z.string().refine(async (val) => val.length > 3, { message: 'Testing 123' })\n   */\n  onChangeAsync?: TOnChangeAsync\n  /**\n   * An optional number to represent how long the `onChangeAsync` should wait before running\n   *\n   * If set to a number larger than 0, will debounce the async validation event by this length of time in milliseconds\n   */\n  onChangeAsyncDebounceMs?: number\n  /**\n   * An optional list of field names that should trigger this field's `onChange` and `onChangeAsync` events when its value changes\n   */\n  onChangeListenTo?: DeepKeys<TParentData>[]\n  /**\n   * An optional function, that runs on the blur event of input.\n   *\n   * @example z.string().min(1)\n   */\n  onBlur?: TOnBlur\n  /**\n   * An optional property similar to `onBlur` but async validation.\n   *\n   * @example z.string().refine(async (val) => val.length > 3, { message: 'Testing 123' })\n   */\n  onBlurAsync?: TOnBlurAsync\n\n  /**\n   * An optional number to represent how long the `onBlurAsync` should wait before running\n   *\n   * If set to a number larger than 0, will debounce the async validation event by this length of time in milliseconds\n   */\n  onBlurAsyncDebounceMs?: number\n  /**\n   * An optional list of field names that should trigger this field's `onBlur` and `onBlurAsync` events when its value changes\n   */\n  onBlurListenTo?: DeepKeys<TParentData>[]\n  /**\n   * An optional function, that runs on the submit event of form.\n   *\n   * @example z.string().min(1)\n   */\n  onSubmit?: TOnSubmit\n  /**\n   * An optional property similar to `onSubmit` but async validation.\n   *\n   * @example z.string().refine(async (val) => val.length > 3, { message: 'Testing 123' })\n   */\n  onSubmitAsync?: TOnSubmitAsync\n  onDynamic?: TOnDynamic\n  onDynamicAsync?: TOnDynamicAsync\n  onDynamicAsyncDebounceMs?: number\n}\n\nexport interface FieldListeners<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName> = DeepValue<TParentData, TName>,\n> {\n  onChange?: FieldListenerFn<TParentData, TName, TData>\n  onChangeDebounceMs?: number\n  onBlur?: FieldListenerFn<TParentData, TName, TData>\n  onBlurDebounceMs?: number\n  onMount?: FieldListenerFn<TParentData, TName, TData>\n  onSubmit?: FieldListenerFn<TParentData, TName, TData>\n}\n\n/**\n * An object type representing the options for a field in a form.\n */\nexport interface FieldOptions<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName>,\n  TOnMount extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChange extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnBlur extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnSubmit extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnDynamic extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnDynamicAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n> {\n  /**\n   * The field name. The type will be `DeepKeys<TParentData>` to ensure your name is a deep key of the parent dataset.\n   */\n  name: TName\n  /**\n   * An optional default value for the field.\n   */\n  defaultValue?: NoInfer<TData>\n  /**\n   * The default time to debounce async validation if there is not a more specific debounce time passed.\n   */\n  asyncDebounceMs?: number\n  /**\n   * If `true`, always run async validation, even if there are errors emitted during synchronous validation.\n   */\n  asyncAlways?: boolean\n  /**\n   * A list of validators to pass to the field\n   */\n  validators?: FieldValidators<\n    TParentData,\n    TName,\n    TData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TOnDynamic,\n    TOnDynamicAsync\n  >\n  /**\n   * An optional object with default metadata for the field.\n   */\n  defaultMeta?: Partial<\n    FieldMeta<\n      TParentData,\n      TName,\n      TData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      any,\n      any,\n      any,\n      any,\n      any,\n      any,\n      any,\n      any,\n      any\n    >\n  >\n  /**\n   * A list of listeners which attach to the corresponding events\n   */\n  listeners?: FieldListeners<TParentData, TName, TData>\n  /**\n   * Disable the `flat(1)` operation on `field.errors`. This is useful if you want to keep the error structure as is. Not suggested for most use-cases.\n   */\n  disableErrorFlat?: boolean\n}\n\n/**\n * An object type representing the required options for the FieldApi class.\n */\nexport interface FieldApiOptions<\n  in out TParentData,\n  in out TName extends DeepKeys<TParentData>,\n  in out TData extends DeepValue<TParentData, TName>,\n  in out TOnMount extends\n    | undefined\n    | FieldValidateOrFn<TParentData, TName, TData>,\n  in out TOnChange extends\n    | undefined\n    | FieldValidateOrFn<TParentData, TName, TData>,\n  in out TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  in out TOnBlur extends\n    | undefined\n    | FieldValidateOrFn<TParentData, TName, TData>,\n  in out TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  in out TOnSubmit extends\n    | undefined\n    | FieldValidateOrFn<TParentData, TName, TData>,\n  in out TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  in out TOnDynamic extends\n    | undefined\n    | FieldValidateOrFn<TParentData, TName, TData>,\n  in out TOnDynamicAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  in out TFormOnMount extends undefined | FormValidateOrFn<TParentData>,\n  in out TFormOnChange extends undefined | FormValidateOrFn<TParentData>,\n  in out TFormOnChangeAsync extends\n    | undefined\n    | FormAsyncValidateOrFn<TParentData>,\n  in out TFormOnBlur extends undefined | FormValidateOrFn<TParentData>,\n  in out TFormOnBlurAsync extends\n    | undefined\n    | FormAsyncValidateOrFn<TParentData>,\n  in out TFormOnSubmit extends undefined | FormValidateOrFn<TParentData>,\n  in out TFormOnSubmitAsync extends\n    | undefined\n    | FormAsyncValidateOrFn<TParentData>,\n  in out TFormOnDynamic extends undefined | FormValidateOrFn<TParentData>,\n  in out TFormOnDynamicAsync extends\n    | undefined\n    | FormAsyncValidateOrFn<TParentData>,\n  in out TFormOnServer extends undefined | FormAsyncValidateOrFn<TParentData>,\n  in out TParentSubmitMeta,\n> extends FieldOptions<\n  TParentData,\n  TName,\n  TData,\n  TOnMount,\n  TOnChange,\n  TOnChangeAsync,\n  TOnBlur,\n  TOnBlurAsync,\n  TOnSubmit,\n  TOnSubmitAsync,\n  TOnDynamic,\n  TOnDynamicAsync\n> {\n  form: FormApi<\n    TParentData,\n    TFormOnMount,\n    TFormOnChange,\n    TFormOnChangeAsync,\n    TFormOnBlur,\n    TFormOnBlurAsync,\n    TFormOnSubmit,\n    TFormOnSubmitAsync,\n    TFormOnDynamic,\n    TFormOnDynamicAsync,\n    TFormOnServer,\n    TParentSubmitMeta\n  >\n}\n\nexport type FieldMetaBase<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName>,\n  TOnMount extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChange extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnBlur extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnSubmit extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnDynamic extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnDynamicAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TFormOnMount extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChange extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChangeAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnBlur extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnBlurAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnSubmit extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnDynamic extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n> = {\n  /**\n   * A flag indicating whether the field has been touched.\n   */\n  isTouched: boolean\n  /**\n   * A flag indicating whether the field has been blurred.\n   */\n  isBlurred: boolean\n  /**\n   * A flag that is `true` if the field's value has been modified by the user. Opposite of `isPristine`.\n   */\n  isDirty: boolean\n  /**\n   * A map of errors related to the field value.\n   */\n  errorMap: ValidationErrorMap<\n    UnwrapFieldValidateOrFn<TName, TOnMount, TFormOnMount>,\n    UnwrapFieldValidateOrFn<TName, TOnChange, TFormOnChange>,\n    UnwrapFieldAsyncValidateOrFn<TName, TOnChangeAsync, TFormOnChangeAsync>,\n    UnwrapFieldValidateOrFn<TName, TOnBlur, TFormOnBlur>,\n    UnwrapFieldAsyncValidateOrFn<TName, TOnBlurAsync, TFormOnBlurAsync>,\n    UnwrapFieldValidateOrFn<TName, TOnSubmit, TFormOnSubmit>,\n    UnwrapFieldAsyncValidateOrFn<TName, TOnSubmitAsync, TFormOnSubmitAsync>,\n    UnwrapFieldValidateOrFn<TName, TOnDynamic, TFormOnDynamic>,\n    UnwrapFieldAsyncValidateOrFn<TName, TOnDynamicAsync, TFormOnDynamicAsync>\n  >\n\n  /**\n   * @private allows tracking the source of the errors in the error map\n   */\n  errorSourceMap: ValidationErrorMapSource\n  /**\n   * A flag indicating whether the field is currently being validated.\n   */\n  isValidating: boolean\n}\n\nexport type AnyFieldMetaBase = FieldMetaBase<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any\n>\n\nexport type FieldMetaDerived<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName>,\n  TOnMount extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChange extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnBlur extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnSubmit extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnDynamic extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnDynamicAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TFormOnMount extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChange extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChangeAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnBlur extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnBlurAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnSubmit extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnDynamic extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n> = {\n  /**\n   * An array of errors related to the field value.\n   */\n  errors: Array<\n    | UnwrapOneLevelOfArray<\n        UnwrapFieldValidateOrFn<TName, TOnMount, TFormOnMount>\n      >\n    | UnwrapOneLevelOfArray<\n        UnwrapFieldValidateOrFn<TName, TOnChange, TFormOnChange>\n      >\n    | UnwrapOneLevelOfArray<\n        UnwrapFieldAsyncValidateOrFn<TName, TOnChangeAsync, TFormOnChangeAsync>\n      >\n    | UnwrapOneLevelOfArray<\n        UnwrapFieldValidateOrFn<TName, TOnBlur, TFormOnBlur>\n      >\n    | UnwrapOneLevelOfArray<\n        UnwrapFieldAsyncValidateOrFn<TName, TOnBlurAsync, TFormOnBlurAsync>\n      >\n    | UnwrapOneLevelOfArray<\n        UnwrapFieldValidateOrFn<TName, TOnSubmit, TFormOnSubmit>\n      >\n    | UnwrapOneLevelOfArray<\n        UnwrapFieldAsyncValidateOrFn<TName, TOnSubmitAsync, TFormOnSubmitAsync>\n      >\n    | UnwrapOneLevelOfArray<\n        UnwrapFieldValidateOrFn<TName, TOnDynamic, TFormOnDynamic>\n      >\n    | UnwrapOneLevelOfArray<\n        UnwrapFieldAsyncValidateOrFn<\n          TName,\n          TOnDynamicAsync,\n          TFormOnDynamicAsync\n        >\n      >\n  >\n  /**\n   * A flag that is `true` if the field's value has not been modified by the user. Opposite of `isDirty`.\n   */\n  isPristine: boolean\n  /**\n   * A boolean indicating if the field is valid. Evaluates `true` if there are no field errors.\n   */\n  isValid: boolean\n  /**\n   * A flag indicating whether the field's current value is the default value\n   */\n  isDefaultValue: boolean\n}\n\nexport type AnyFieldMetaDerived = FieldMetaDerived<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any\n>\n\n/**\n * An object type representing the metadata of a field in a form.\n */\nexport type FieldMeta<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName>,\n  TOnMount extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChange extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnBlur extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnSubmit extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnDynamic extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnDynamicAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TFormOnMount extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChange extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChangeAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnBlur extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnBlurAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnSubmit extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnDynamic extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n> = FieldMetaBase<\n  TParentData,\n  TName,\n  TData,\n  TOnMount,\n  TOnChange,\n  TOnChangeAsync,\n  TOnBlur,\n  TOnBlurAsync,\n  TOnSubmit,\n  TOnSubmitAsync,\n  TOnDynamic,\n  TOnDynamicAsync,\n  TFormOnMount,\n  TFormOnChange,\n  TFormOnChangeAsync,\n  TFormOnBlur,\n  TFormOnBlurAsync,\n  TFormOnSubmit,\n  TFormOnSubmitAsync,\n  TFormOnDynamic,\n  TFormOnDynamicAsync\n> &\n  FieldMetaDerived<\n    TParentData,\n    TName,\n    TData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TOnDynamic,\n    TOnDynamicAsync,\n    TFormOnMount,\n    TFormOnChange,\n    TFormOnChangeAsync,\n    TFormOnBlur,\n    TFormOnBlurAsync,\n    TFormOnSubmit,\n    TFormOnSubmitAsync,\n    TFormOnDynamic,\n    TFormOnDynamicAsync\n  >\n\nexport type AnyFieldMeta = FieldMeta<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any\n>\n\n/**\n * An object type representing the state of a field.\n */\nexport type FieldState<\n  TParentData,\n  TName extends DeepKeys<TParentData>,\n  TData extends DeepValue<TParentData, TName>,\n  TOnMount extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChange extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnBlur extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnSubmit extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TOnDynamic extends undefined | FieldValidateOrFn<TParentData, TName, TData>,\n  TOnDynamicAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  TFormOnMount extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChange extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnChangeAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnBlur extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnBlurAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnSubmit extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n  TFormOnDynamic extends undefined | FormValidateOrFn<TParentData>,\n  TFormOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TParentData>,\n> = {\n  /**\n   * The current value of the field.\n   */\n  value: TData\n  /**\n   * The current metadata of the field.\n   */\n  meta: FieldMeta<\n    TParentData,\n    TName,\n    TData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TOnDynamic,\n    TOnDynamicAsync,\n    TFormOnMount,\n    TFormOnChange,\n    TFormOnChangeAsync,\n    TFormOnBlur,\n    TFormOnBlurAsync,\n    TFormOnSubmit,\n    TFormOnSubmitAsync,\n    TFormOnDynamic,\n    TFormOnDynamicAsync\n  >\n}\n\n/**\n * @public\n *\n * A type representing the Field API with all generics set to `any` for convenience.\n */\nexport type AnyFieldApi = FieldApi<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any\n>\n\n/**\n * We cannot use methods and must use arrow functions. Otherwise, our React adapters\n * will break due to loss of the method when using spread.\n */\n\n/**\n * A class representing the API for managing a form field.\n *\n * Normally, you will not need to create a new `FieldApi` instance directly.\n * Instead, you will use a framework hook/function like `useField` or `createField`\n * to create a new instance for you that uses your framework's reactivity model.\n * However, if you need to create a new instance manually, you can do so by calling\n * the `new FieldApi` constructor.\n */\nexport class FieldApi<\n  in out TParentData,\n  in out TName extends DeepKeys<TParentData>,\n  in out TData extends DeepValue<TParentData, TName>,\n  in out TOnMount extends\n    | undefined\n    | FieldValidateOrFn<TParentData, TName, TData>,\n  in out TOnChange extends\n    | undefined\n    | FieldValidateOrFn<TParentData, TName, TData>,\n  in out TOnChangeAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  in out TOnBlur extends\n    | undefined\n    | FieldValidateOrFn<TParentData, TName, TData>,\n  in out TOnBlurAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  in out TOnSubmit extends\n    | undefined\n    | FieldValidateOrFn<TParentData, TName, TData>,\n  in out TOnSubmitAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  in out TOnDynamic extends\n    | undefined\n    | FieldValidateOrFn<TParentData, TName, TData>,\n  in out TOnDynamicAsync extends\n    | undefined\n    | FieldAsyncValidateOrFn<TParentData, TName, TData>,\n  in out TFormOnMount extends undefined | FormValidateOrFn<TParentData>,\n  in out TFormOnChange extends undefined | FormValidateOrFn<TParentData>,\n  in out TFormOnChangeAsync extends\n    | undefined\n    | FormAsyncValidateOrFn<TParentData>,\n  in out TFormOnBlur extends undefined | FormValidateOrFn<TParentData>,\n  in out TFormOnBlurAsync extends\n    | undefined\n    | FormAsyncValidateOrFn<TParentData>,\n  in out TFormOnSubmit extends undefined | FormValidateOrFn<TParentData>,\n  in out TFormOnSubmitAsync extends\n    | undefined\n    | FormAsyncValidateOrFn<TParentData>,\n  in out TFormOnDynamic extends undefined | FormValidateOrFn<TParentData>,\n  in out TFormOnDynamicAsync extends\n    | undefined\n    | FormAsyncValidateOrFn<TParentData>,\n  in out TFormOnServer extends undefined | FormAsyncValidateOrFn<TParentData>,\n  in out TParentSubmitMeta,\n> {\n  /**\n   * A reference to the form API instance.\n   */\n  form: FieldApiOptions<\n    TParentData,\n    TName,\n    TData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TOnDynamic,\n    TOnDynamicAsync,\n    TFormOnMount,\n    TFormOnChange,\n    TFormOnChangeAsync,\n    TFormOnBlur,\n    TFormOnBlurAsync,\n    TFormOnSubmit,\n    TFormOnSubmitAsync,\n    TFormOnDynamic,\n    TFormOnDynamicAsync,\n    TFormOnServer,\n    TParentSubmitMeta\n  >['form']\n  /**\n   * The field name.\n   */\n  name: TName\n  /**\n   * The field options.\n   */\n  options: FieldApiOptions<\n    TParentData,\n    TName,\n    TData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TOnDynamic,\n    TOnDynamicAsync,\n    TFormOnMount,\n    TFormOnChange,\n    TFormOnChangeAsync,\n    TFormOnBlur,\n    TFormOnBlurAsync,\n    TFormOnSubmit,\n    TFormOnSubmitAsync,\n    TFormOnDynamic,\n    TFormOnDynamicAsync,\n    TFormOnServer,\n    TParentSubmitMeta\n  > = {} as any\n  /**\n   * The field state store.\n   */\n  store!: Derived<\n    FieldState<\n      TParentData,\n      TName,\n      TData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TFormOnMount,\n      TFormOnChange,\n      TFormOnChangeAsync,\n      TFormOnBlur,\n      TFormOnBlurAsync,\n      TFormOnSubmit,\n      TFormOnSubmitAsync,\n      TFormOnDynamic,\n      TFormOnDynamicAsync\n    >\n  >\n  /**\n   * The current field state.\n   */\n  get state() {\n    return this.store.state\n  }\n  timeoutIds: {\n    validations: Record<ValidationCause, ReturnType<typeof setTimeout> | null>\n    listeners: Record<ListenerCause, ReturnType<typeof setTimeout> | null>\n    formListeners: Record<ListenerCause, ReturnType<typeof setTimeout> | null>\n  }\n\n  /**\n   * Initializes a new `FieldApi` instance.\n   */\n  constructor(\n    opts: FieldApiOptions<\n      TParentData,\n      TName,\n      TData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TFormOnMount,\n      TFormOnChange,\n      TFormOnChangeAsync,\n      TFormOnBlur,\n      TFormOnBlurAsync,\n      TFormOnSubmit,\n      TFormOnSubmitAsync,\n      TFormOnDynamic,\n      TFormOnDynamicAsync,\n      TFormOnServer,\n      TParentSubmitMeta\n    >,\n  ) {\n    this.form = opts.form\n    this.name = opts.name\n    this.options = opts\n\n    this.timeoutIds = {\n      validations: {} as Record<ValidationCause, never>,\n      listeners: {} as Record<ListenerCause, never>,\n      formListeners: {} as Record<ListenerCause, never>,\n    }\n\n    this.store = new Derived({\n      deps: [this.form.store],\n      fn: () => {\n        const meta = this.form.getFieldMeta(this.name) ?? {\n          ...defaultFieldMeta,\n          ...opts.defaultMeta,\n        }\n\n        let value = this.form.getFieldValue(this.name)\n        if (\n          !meta.isTouched &&\n          (value as unknown) === undefined &&\n          this.options.defaultValue !== undefined &&\n          !evaluate(value, this.options.defaultValue)\n        ) {\n          value = this.options.defaultValue\n        }\n\n        return {\n          value,\n          meta,\n        } as FieldState<\n          TParentData,\n          TName,\n          TData,\n          TOnMount,\n          TOnChange,\n          TOnChangeAsync,\n          TOnBlur,\n          TOnBlurAsync,\n          TOnSubmit,\n          TOnSubmitAsync,\n          TOnDynamic,\n          TOnDynamicAsync,\n          TFormOnMount,\n          TFormOnChange,\n          TFormOnChangeAsync,\n          TFormOnBlur,\n          TFormOnBlurAsync,\n          TFormOnSubmit,\n          TFormOnSubmitAsync,\n          TFormOnDynamic,\n          TFormOnDynamicAsync\n        >\n      },\n    })\n  }\n\n  /**\n   * @private\n   */\n  runValidator<\n    TValue extends TStandardSchemaValidatorValue<TData> & {\n      fieldApi: AnyFieldApi\n    },\n    TType extends 'validate' | 'validateAsync',\n  >(props: {\n    validate: TType extends 'validate'\n      ? FieldValidateOrFn<any, any, any>\n      : FieldAsyncValidateOrFn<any, any, any>\n    value: TValue\n    type: TType\n    // When `api` is 'field', the return type cannot be `FormValidationError`\n  }): unknown {\n    if (isStandardSchemaValidator(props.validate)) {\n      return standardSchemaValidators[props.type](\n        props.value,\n        props.validate,\n      ) as never\n    }\n\n    return (props.validate as FieldValidateFn<any, any>)(props.value) as never\n  }\n\n  /**\n   * Mounts the field instance to the form.\n   */\n  mount = () => {\n    const cleanup = this.store.mount()\n\n    if (this.options.defaultValue !== undefined && !this.getMeta().isTouched) {\n      this.form.setFieldValue(this.name, this.options.defaultValue, {\n        dontUpdateMeta: true,\n      })\n    }\n\n    const info = this.getInfo()\n    info.instance = this as never\n\n    this.update(this.options as never)\n    const { onMount } = this.options.validators || {}\n\n    if (onMount) {\n      const error = this.runValidator({\n        validate: onMount,\n        value: {\n          value: this.state.value,\n          fieldApi: this,\n          validationSource: 'field',\n        },\n        type: 'validate',\n      })\n      if (error) {\n        this.setMeta(\n          (prev) =>\n            ({\n              ...prev,\n              // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n              errorMap: { ...prev?.errorMap, onMount: error },\n              errorSourceMap: {\n                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n                ...prev?.errorSourceMap,\n                onMount: 'field',\n              },\n            }) as never,\n        )\n      }\n    }\n\n    this.options.listeners?.onMount?.({\n      value: this.state.value,\n      fieldApi: this,\n    })\n\n    return cleanup\n  }\n\n  /**\n   * Updates the field instance with new options.\n   */\n  update = (\n    opts: FieldApiOptions<\n      TParentData,\n      TName,\n      TData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TFormOnMount,\n      TFormOnChange,\n      TFormOnChangeAsync,\n      TFormOnBlur,\n      TFormOnBlurAsync,\n      TFormOnSubmit,\n      TFormOnSubmitAsync,\n      TFormOnDynamic,\n      TFormOnDynamicAsync,\n      TFormOnServer,\n      TParentSubmitMeta\n    >,\n  ) => {\n    this.options = opts\n    this.name = opts.name\n\n    // Default Value\n    if (!this.state.meta.isTouched && this.options.defaultValue !== undefined) {\n      const formField = this.form.getFieldValue(this.name)\n      if (!evaluate(formField, opts.defaultValue)) {\n        this.form.setFieldValue(this.name, opts.defaultValue as never, {\n          dontUpdateMeta: true,\n          dontValidate: true,\n          dontRunListeners: true,\n        })\n      }\n    }\n\n    if (!this.form.getFieldMeta(this.name)) {\n      this.form.setFieldMeta(this.name, this.state.meta)\n    }\n  }\n\n  /**\n   * Gets the current field value.\n   * @deprecated Use `field.state.value` instead.\n   */\n  getValue = (): TData => {\n    return this.form.getFieldValue(this.name) as TData\n  }\n\n  /**\n   * Sets the field value and run the `change` validator.\n   */\n  setValue = (updater: Updater<TData>, options?: UpdateMetaOptions) => {\n    this.form.setFieldValue(\n      this.name,\n      updater as never,\n      mergeOpts(options, { dontRunListeners: true, dontValidate: true }),\n    )\n\n    if (!options?.dontRunListeners) {\n      this.triggerOnChangeListener()\n    }\n\n    if (!options?.dontValidate) {\n      this.validate('change')\n    }\n  }\n\n  getMeta = () => this.store.state.meta\n\n  /**\n   * Sets the field metadata.\n   */\n  setMeta = (\n    updater: Updater<\n      FieldMetaBase<\n        TParentData,\n        TName,\n        TData,\n        TOnMount,\n        TOnChange,\n        TOnChangeAsync,\n        TOnBlur,\n        TOnBlurAsync,\n        TOnSubmit,\n        TOnSubmitAsync,\n        TOnDynamic,\n        TOnDynamicAsync,\n        TFormOnMount,\n        TFormOnChange,\n        TFormOnChangeAsync,\n        TFormOnBlur,\n        TFormOnBlurAsync,\n        TFormOnSubmit,\n        TFormOnSubmitAsync,\n        TFormOnDynamic,\n        TFormOnDynamicAsync\n      >\n    >,\n  ) => this.form.setFieldMeta(this.name, updater)\n\n  /**\n   * Gets the field information object.\n   */\n  getInfo = () => this.form.getFieldInfo(this.name)\n\n  /**\n   * Pushes a new value to the field.\n   */\n  pushValue = (\n    value: TData extends any[] ? TData[number] : never,\n    options?: UpdateMetaOptions,\n  ) => {\n    this.form.pushFieldValue(\n      this.name,\n      value as any,\n      mergeOpts(options, { dontRunListeners: true }),\n    )\n\n    if (!options?.dontRunListeners) {\n      this.triggerOnChangeListener()\n    }\n  }\n\n  /**\n   * Inserts a value at the specified index, shifting the subsequent values to the right.\n   */\n  insertValue = (\n    index: number,\n    value: TData extends any[] ? TData[number] : never,\n    options?: UpdateMetaOptions,\n  ) => {\n    this.form.insertFieldValue(\n      this.name,\n      index,\n      value as any,\n      mergeOpts(options, { dontRunListeners: true }),\n    )\n\n    if (!options?.dontRunListeners) {\n      this.triggerOnChangeListener()\n    }\n  }\n\n  /**\n   * Replaces a value at the specified index.\n   */\n  replaceValue = (\n    index: number,\n    value: TData extends any[] ? TData[number] : never,\n    options?: UpdateMetaOptions,\n  ) => {\n    this.form.replaceFieldValue(\n      this.name,\n      index,\n      value as any,\n      mergeOpts(options, { dontRunListeners: true }),\n    )\n\n    if (!options?.dontRunListeners) {\n      this.triggerOnChangeListener()\n    }\n  }\n\n  /**\n   * Removes a value at the specified index.\n   */\n  removeValue = (index: number, options?: UpdateMetaOptions) => {\n    this.form.removeFieldValue(\n      this.name,\n      index,\n      mergeOpts(options, { dontRunListeners: true }),\n    )\n\n    if (!options?.dontRunListeners) {\n      this.triggerOnChangeListener()\n    }\n  }\n\n  /**\n   * Swaps the values at the specified indices.\n   */\n  swapValues = (\n    aIndex: number,\n    bIndex: number,\n    options?: UpdateMetaOptions,\n  ) => {\n    this.form.swapFieldValues(\n      this.name,\n      aIndex,\n      bIndex,\n      mergeOpts(options, { dontRunListeners: true }),\n    )\n\n    if (!options?.dontRunListeners) {\n      this.triggerOnChangeListener()\n    }\n  }\n\n  /**\n   * Moves the value at the first specified index to the second specified index.\n   */\n  moveValue = (aIndex: number, bIndex: number, options?: UpdateMetaOptions) => {\n    this.form.moveFieldValues(\n      this.name,\n      aIndex,\n      bIndex,\n      mergeOpts(options, { dontRunListeners: true }),\n    )\n\n    if (!options?.dontRunListeners) {\n      this.triggerOnChangeListener()\n    }\n  }\n\n  /**\n   * Clear all values from the array.\n   */\n  clearValues = (options?: UpdateMetaOptions) => {\n    this.form.clearFieldValues(\n      this.name,\n      mergeOpts(options, { dontRunListeners: true }),\n    )\n\n    if (!options?.dontRunListeners) {\n      this.triggerOnChangeListener()\n    }\n  }\n\n  /**\n   * @private\n   */\n  getLinkedFields = (cause: ValidationCause) => {\n    const fields = Object.values(this.form.fieldInfo) as FieldInfo<any>[]\n\n    const linkedFields: AnyFieldApi[] = []\n    for (const field of fields) {\n      if (!field.instance) continue\n      const { onChangeListenTo, onBlurListenTo } =\n        field.instance.options.validators || {}\n      if (cause === 'change' && onChangeListenTo?.includes(this.name)) {\n        linkedFields.push(field.instance)\n      }\n      if (cause === 'blur' && onBlurListenTo?.includes(this.name as string)) {\n        linkedFields.push(field.instance)\n      }\n    }\n\n    return linkedFields\n  }\n\n  /**\n   * @private\n   */\n  validateSync = (\n    cause: ValidationCause,\n    errorFromForm: ValidationErrorMap,\n  ) => {\n    const validates = getSyncValidatorArray(cause, {\n      ...this.options,\n      form: this.form,\n      validationLogic:\n        this.form.options.validationLogic || defaultValidationLogic,\n    })\n\n    const linkedFields = this.getLinkedFields(cause)\n    const linkedFieldValidates = linkedFields.reduce(\n      (acc, field) => {\n        const fieldValidates = getSyncValidatorArray(cause, {\n          ...field.options,\n          form: field.form,\n          validationLogic:\n            field.form.options.validationLogic || defaultValidationLogic,\n        })\n        fieldValidates.forEach((validate) => {\n          ;(validate as any).field = field\n        })\n        return acc.concat(fieldValidates as never)\n      },\n      [] as Array<\n        SyncValidator<any> & {\n          field: AnyFieldApi\n        }\n      >,\n    )\n\n    // Needs type cast as eslint errantly believes this is always falsy\n    let hasErrored = false as boolean\n\n    batch(() => {\n      const validateFieldFn = (\n        field: AnyFieldApi,\n        validateObj: SyncValidator<any>,\n      ) => {\n        const errorMapKey = getErrorMapKey(validateObj.cause)\n\n        const fieldLevelError = validateObj.validate\n          ? normalizeError(\n              field.runValidator({\n                validate: validateObj.validate,\n                value: {\n                  value: field.store.state.value,\n                  validationSource: 'field',\n                  fieldApi: field,\n                },\n                type: 'validate',\n              }),\n            )\n          : undefined\n\n        const formLevelError = errorFromForm[errorMapKey]\n\n        const { newErrorValue, newSource } =\n          determineFieldLevelErrorSourceAndValue({\n            formLevelError,\n            fieldLevelError,\n          })\n\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (field.state.meta.errorMap?.[errorMapKey] !== newErrorValue) {\n          field.setMeta((prev) => ({\n            ...prev,\n            errorMap: {\n              ...prev.errorMap,\n              [errorMapKey]: newErrorValue,\n            },\n            errorSourceMap: {\n              ...prev.errorSourceMap,\n              [errorMapKey]: newSource,\n            },\n          }))\n        }\n        if (newErrorValue) {\n          hasErrored = true\n        }\n      }\n\n      for (const validateObj of validates) {\n        validateFieldFn(this, validateObj)\n      }\n      for (const fieldValitateObj of linkedFieldValidates) {\n        if (!fieldValitateObj.validate) continue\n        validateFieldFn(fieldValitateObj.field, fieldValitateObj)\n      }\n    })\n\n    /**\n     *  when we have an error for onSubmit in the state, we want\n     *  to clear the error as soon as the user enters a valid value in the field\n     */\n    const submitErrKey = getErrorMapKey('submit')\n\n    if (\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      this.state.meta.errorMap?.[submitErrKey] &&\n      cause !== 'submit' &&\n      !hasErrored\n    ) {\n      this.setMeta((prev) => ({\n        ...prev,\n        errorMap: {\n          ...prev.errorMap,\n          [submitErrKey]: undefined,\n        },\n        errorSourceMap: {\n          ...prev.errorSourceMap,\n          [submitErrKey]: undefined,\n        },\n      }))\n    }\n\n    return { hasErrored }\n  }\n\n  /**\n   * @private\n   */\n  validateAsync = async (\n    cause: ValidationCause,\n    formValidationResultPromise: Promise<\n      FieldErrorMapFromValidator<\n        TParentData,\n        TName,\n        TData,\n        TOnMount,\n        TOnChange,\n        TOnChangeAsync,\n        TOnBlur,\n        TOnBlurAsync,\n        TOnSubmit,\n        TOnSubmitAsync\n      >\n    >,\n  ) => {\n    const validates = getAsyncValidatorArray(cause, {\n      ...this.options,\n      form: this.form,\n      validationLogic:\n        this.form.options.validationLogic || defaultValidationLogic,\n    })\n\n    // Get the field-specific error messages that are coming from the form's validator\n    const asyncFormValidationResults = await formValidationResultPromise\n\n    const linkedFields = this.getLinkedFields(cause)\n    const linkedFieldValidates = linkedFields.reduce(\n      (acc, field) => {\n        const fieldValidates = getAsyncValidatorArray(cause, {\n          ...field.options,\n          form: field.form,\n          validationLogic:\n            field.form.options.validationLogic || defaultValidationLogic,\n        })\n        fieldValidates.forEach((validate) => {\n          ;(validate as any).field = field\n        })\n        return acc.concat(fieldValidates as never)\n      },\n      [] as Array<\n        AsyncValidator<any> & {\n          field: AnyFieldApi\n        }\n      >,\n    )\n\n    /**\n     * We have to use a for loop and generate our promises this way, otherwise it won't be sync\n     * when there are no validators needed to be run\n     */\n    const validatesPromises: Promise<ValidationError | undefined>[] = []\n    const linkedPromises: Promise<ValidationError | undefined>[] = []\n\n    // Check if there are actual async validators to run before setting isValidating\n    // This prevents unnecessary re-renders when there are no async validators\n    // See: https://github.com/TanStack/form/issues/1130\n    const hasAsyncValidators =\n      validates.some((v) => v.validate) ||\n      linkedFieldValidates.some((v) => v.validate)\n\n    if (hasAsyncValidators) {\n      if (!this.state.meta.isValidating) {\n        this.setMeta((prev) => ({ ...prev, isValidating: true }))\n      }\n\n      for (const linkedField of linkedFields) {\n        linkedField.setMeta((prev) => ({ ...prev, isValidating: true }))\n      }\n    }\n\n    const validateFieldAsyncFn = (\n      field: AnyFieldApi,\n      validateObj: AsyncValidator<any>,\n      promises: Promise<ValidationError | undefined>[],\n    ) => {\n      const errorMapKey = getErrorMapKey(validateObj.cause)\n      const fieldValidatorMeta = field.getInfo().validationMetaMap[errorMapKey]\n\n      fieldValidatorMeta?.lastAbortController.abort()\n      const controller = new AbortController()\n\n      this.getInfo().validationMetaMap[errorMapKey] = {\n        lastAbortController: controller,\n      }\n\n      promises.push(\n        new Promise<ValidationError | undefined>(async (resolve) => {\n          let rawError!: ValidationError | undefined\n          try {\n            rawError = await new Promise((rawResolve, rawReject) => {\n              if (this.timeoutIds.validations[validateObj.cause]) {\n                clearTimeout(this.timeoutIds.validations[validateObj.cause]!)\n              }\n\n              this.timeoutIds.validations[validateObj.cause] = setTimeout(\n                async () => {\n                  if (controller.signal.aborted) return rawResolve(undefined)\n                  try {\n                    rawResolve(\n                      await this.runValidator({\n                        validate: validateObj.validate,\n                        value: {\n                          value: field.store.state.value,\n                          fieldApi: field,\n                          signal: controller.signal,\n                          validationSource: 'field',\n                        },\n                        type: 'validateAsync',\n                      }),\n                    )\n                  } catch (e) {\n                    rawReject(e)\n                  }\n                },\n                validateObj.debounceMs,\n              )\n            })\n          } catch (e: unknown) {\n            rawError = e as ValidationError\n          }\n          if (controller.signal.aborted) return resolve(undefined)\n\n          const fieldLevelError = normalizeError(rawError)\n          const formLevelError =\n            asyncFormValidationResults[this.name]?.[errorMapKey]\n\n          const { newErrorValue, newSource } =\n            determineFieldLevelErrorSourceAndValue({\n              formLevelError,\n              fieldLevelError,\n            })\n\n          field.setMeta((prev) => {\n            return {\n              ...prev,\n              errorMap: {\n                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n                ...prev?.errorMap,\n                [errorMapKey]: newErrorValue,\n              },\n              errorSourceMap: {\n                ...prev.errorSourceMap,\n                [errorMapKey]: newSource,\n              },\n            }\n          })\n\n          resolve(newErrorValue)\n        }),\n      )\n    }\n\n    // TODO: Dedupe this logic to reduce bundle size\n    for (const validateObj of validates) {\n      if (!validateObj.validate) continue\n      validateFieldAsyncFn(this, validateObj, validatesPromises)\n    }\n    for (const fieldValitateObj of linkedFieldValidates) {\n      if (!fieldValitateObj.validate) continue\n      validateFieldAsyncFn(\n        fieldValitateObj.field,\n        fieldValitateObj,\n        linkedPromises,\n      )\n    }\n\n    let results: ValidationError[] = []\n    if (validatesPromises.length || linkedPromises.length) {\n      results = await Promise.all(validatesPromises)\n      await Promise.all(linkedPromises)\n    }\n\n    // Only reset isValidating if we set it to true earlier\n    if (hasAsyncValidators) {\n      this.setMeta((prev) => ({ ...prev, isValidating: false }))\n\n      for (const linkedField of linkedFields) {\n        linkedField.setMeta((prev) => ({ ...prev, isValidating: false }))\n      }\n    }\n\n    return results.filter(Boolean)\n  }\n\n  /**\n   * Validates the field value.\n   */\n  validate = (\n    cause: ValidationCause,\n    opts?: { skipFormValidation?: boolean },\n  ): ValidationError[] | Promise<ValidationError[]> => {\n    // If the field is pristine, do not validate\n    if (!this.state.meta.isTouched) return []\n\n    // Attempt to sync validate first\n    const { fieldsErrorMap } = opts?.skipFormValidation\n      ? { fieldsErrorMap: {} as never }\n      : this.form.validateSync(cause)\n    const { hasErrored } = this.validateSync(\n      cause,\n      fieldsErrorMap[this.name] ?? {},\n    )\n\n    if (hasErrored && !this.options.asyncAlways) {\n      this.getInfo().validationMetaMap[\n        getErrorMapKey(cause)\n      ]?.lastAbortController.abort()\n      return this.state.meta.errors\n    }\n\n    // No error? Attempt async validation\n    const formValidationResultPromise = opts?.skipFormValidation\n      ? Promise.resolve({})\n      : this.form.validateAsync(cause)\n    return this.validateAsync(cause, formValidationResultPromise)\n  }\n\n  /**\n   * Handles the change event.\n   */\n  handleChange = (updater: Updater<TData>) => {\n    this.setValue(updater)\n  }\n\n  /**\n   * Handles the blur event.\n   */\n  handleBlur = () => {\n    const prevTouched = this.state.meta.isTouched\n    if (!prevTouched) {\n      this.setMeta((prev) => ({ ...prev, isTouched: true }))\n    }\n    if (!this.state.meta.isBlurred) {\n      this.setMeta((prev) => ({ ...prev, isBlurred: true }))\n    }\n    this.validate('blur')\n\n    this.triggerOnBlurListener()\n  }\n\n  /**\n   * Updates the field's errorMap\n   */\n  setErrorMap = (\n    errorMap: ValidationErrorMap<\n      UnwrapFieldValidateOrFn<TName, TOnMount, TFormOnMount>,\n      UnwrapFieldValidateOrFn<TName, TOnChange, TFormOnChange>,\n      UnwrapFieldAsyncValidateOrFn<TName, TOnChangeAsync, TFormOnChangeAsync>,\n      UnwrapFieldValidateOrFn<TName, TOnBlur, TFormOnBlur>,\n      UnwrapFieldAsyncValidateOrFn<TName, TOnBlurAsync, TFormOnBlurAsync>,\n      UnwrapFieldValidateOrFn<TName, TOnSubmit, TFormOnSubmit>,\n      UnwrapFieldAsyncValidateOrFn<TName, TOnSubmitAsync, TFormOnSubmitAsync>,\n      UnwrapFieldValidateOrFn<TName, TOnDynamic, TFormOnDynamic>,\n      UnwrapFieldAsyncValidateOrFn<TName, TOnDynamicAsync, TFormOnDynamicAsync>\n    >,\n  ) => {\n    this.setMeta((prev) => ({\n      ...prev,\n      errorMap: {\n        ...prev.errorMap,\n        ...errorMap,\n      },\n    }))\n  }\n\n  /**\n   * Parses the field's value with the given schema and returns\n   * issues (if any). This method does NOT set any internal errors.\n   * @param schema The standard schema to parse this field's value with.\n   */\n  parseValueWithSchema = (schema: StandardSchemaV1<TData, unknown>) => {\n    return standardSchemaValidators.validate(\n      { value: this.state.value, validationSource: 'field' },\n      schema,\n    )\n  }\n\n  /**\n   * Parses the field's value with the given schema and returns\n   * issues (if any). This method does NOT set any internal errors.\n   * @param schema The standard schema to parse this field's value with.\n   */\n  parseValueWithSchemaAsync = (schema: StandardSchemaV1<TData, unknown>) => {\n    return standardSchemaValidators.validateAsync(\n      { value: this.state.value, validationSource: 'field' },\n      schema,\n    )\n  }\n\n  private triggerOnBlurListener() {\n    const formDebounceMs = this.form.options.listeners?.onBlurDebounceMs\n    if (formDebounceMs && formDebounceMs > 0) {\n      if (this.timeoutIds.formListeners.blur) {\n        clearTimeout(this.timeoutIds.formListeners.blur)\n      }\n\n      this.timeoutIds.formListeners.blur = setTimeout(() => {\n        this.form.options.listeners?.onBlur?.({\n          formApi: this.form,\n          fieldApi: this,\n        })\n      }, formDebounceMs)\n    } else {\n      this.form.options.listeners?.onBlur?.({\n        formApi: this.form,\n        fieldApi: this,\n      })\n    }\n\n    const fieldDebounceMs = this.options.listeners?.onBlurDebounceMs\n    if (fieldDebounceMs && fieldDebounceMs > 0) {\n      if (this.timeoutIds.listeners.blur) {\n        clearTimeout(this.timeoutIds.listeners.blur)\n      }\n\n      this.timeoutIds.listeners.blur = setTimeout(() => {\n        this.options.listeners?.onBlur?.({\n          value: this.state.value,\n          fieldApi: this,\n        })\n      }, fieldDebounceMs)\n    } else {\n      this.options.listeners?.onBlur?.({\n        value: this.state.value,\n        fieldApi: this,\n      })\n    }\n  }\n\n  /**\n   * @private\n   */\n  triggerOnChangeListener = () => {\n    const formDebounceMs = this.form.options.listeners?.onChangeDebounceMs\n    if (formDebounceMs && formDebounceMs > 0) {\n      if (this.timeoutIds.formListeners.change) {\n        clearTimeout(this.timeoutIds.formListeners.change)\n      }\n\n      this.timeoutIds.formListeners.change = setTimeout(() => {\n        this.form.options.listeners?.onChange?.({\n          formApi: this.form,\n          fieldApi: this,\n        })\n      }, formDebounceMs)\n    } else {\n      this.form.options.listeners?.onChange?.({\n        formApi: this.form,\n        fieldApi: this,\n      })\n    }\n\n    const fieldDebounceMs = this.options.listeners?.onChangeDebounceMs\n    if (fieldDebounceMs && fieldDebounceMs > 0) {\n      if (this.timeoutIds.listeners.change) {\n        clearTimeout(this.timeoutIds.listeners.change)\n      }\n\n      this.timeoutIds.listeners.change = setTimeout(() => {\n        this.options.listeners?.onChange?.({\n          value: this.state.value,\n          fieldApi: this,\n        })\n      }, fieldDebounceMs)\n    } else {\n      this.options.listeners?.onChange?.({\n        value: this.state.value,\n        fieldApi: this,\n      })\n    }\n  }\n}\n\nfunction normalizeError(rawError?: ValidationError) {\n  if (rawError) {\n    return rawError\n  }\n\n  return undefined\n}\n\nfunction getErrorMapKey(cause: ValidationCause) {\n  switch (cause) {\n    case 'submit':\n      return 'onSubmit'\n    case 'blur':\n      return 'onBlur'\n    case 'mount':\n      return 'onMount'\n    case 'server':\n      return 'onServer'\n    case 'dynamic':\n      return 'onDynamic'\n    case 'change':\n    default:\n      return 'onChange'\n  }\n}\n"],"names":["opts"],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/esm/FormApi.js b/dist/esm/FormApi.js
index 54337b6f2434cda7c82f6c259b71b439249301dd..ff7b44c1a050899c6925eb4af09eb87c2bac8cb4 100644
--- a/dist/esm/FormApi.js
+++ b/dist/esm/FormApi.js
@@ -1,5 +1,5 @@
 import { batch, Store, Derived } from "@tanstack/store";
-import { throttleFormState, evaluate, getSyncValidatorArray, determineFormLevelErrorSourceAndValue, getAsyncValidatorArray, getBy, functionalUpdate, setBy, deleteBy, mergeOpts, isGlobalFormValidationError, uuid, isNonEmptyArray } from "./utils.js";
+import { evaluate, getSyncValidatorArray, determineFormLevelErrorSourceAndValue, getAsyncValidatorArray, getBy, functionalUpdate, setBy, deleteBy, mergeOpts, isGlobalFormValidationError, uuid, isNonEmptyArray, throttleFormState } from "./utils.js";
 import { defaultValidationLogic } from "./ValidationLogic.js";
 import { standardSchemaValidators, isStandardSchemaValidator } from "./standardSchemaValidator.js";
 import { defaultFieldMeta, metaHelper } from "./metaHelper.js";
@@ -35,44 +35,7 @@ class FormApi {
     this.mount = () => {
       const cleanupFieldMetaDerived = this.fieldMetaDerived.mount();
       const cleanupStoreDerived = this.store.mount();
-      const cleanupDevtoolBroadcast = this.store.subscribe(() => {
-        throttleFormState(this);
-      });
-      const cleanupFormStateListener = formEventClient.on(
-        "request-form-state",
-        (e) => {
-          if (e.payload.id === this._formId) {
-            formEventClient.emit("form-api", {
-              id: this._formId,
-              state: this.store.state,
-              options: this.options
-            });
-          }
-        }
-      );
-      const cleanupFormResetListener = formEventClient.on(
-        "request-form-reset",
-        (e) => {
-          if (e.payload.id === this._formId) {
-            this.reset();
-          }
-        }
-      );
-      const cleanupFormForceSubmitListener = formEventClient.on(
-        "request-form-force-submit",
-        (e) => {
-          if (e.payload.id === this._formId) {
-            this._devtoolsSubmissionOverride = true;
-            this.handleSubmit();
-            this._devtoolsSubmissionOverride = false;
-          }
-        }
-      );
       const cleanup = () => {
-        cleanupFormForceSubmitListener();
-        cleanupFormResetListener();
-        cleanupFormStateListener();
-        cleanupDevtoolBroadcast();
         cleanupFieldMetaDerived();
         cleanupStoreDerived();
         formEventClient.emit("form-unmounted", {
@@ -211,15 +174,14 @@ class FormApi {
           });
           const { formError, fieldErrors } = normalizeError(rawError);
           const errorMapKey = getErrorMapKey(validateObj.cause);
-          const allFieldsToProcess = /* @__PURE__ */ new Set([
-            ...Object.keys(this.state.fieldMeta),
-            ...Object.keys(fieldErrors || {})
-          ]);
-          for (const field of allFieldsToProcess) {
-            if (this.baseStore.state.fieldMetaBase[field] === void 0 && !fieldErrors?.[field]) {
+          for (const field of Object.keys(
+            this.state.fieldMeta
+          )) {
+            if (this.baseStore.state.fieldMetaBase[field] === void 0) {
               continue;
             }
-            const fieldMeta = this.getFieldMeta(field) ?? defaultFieldMeta;
+            const fieldMeta = this.getFieldMeta(field);
+            if (!fieldMeta) continue;
             const {
               errorMap: currentErrorMap,
               errorSourceMap: currentErrorMapSource
@@ -227,8 +189,12 @@ class FormApi {
             const newFormValidatorError = fieldErrors?.[field];
             const { newErrorValue, newSource } = determineFormLevelErrorSourceAndValue({
               newFormValidatorError,
-              isPreviousErrorFromFormValidator: currentErrorMapSource[errorMapKey] === "form",
-              previousErrorValue: currentErrorMap[errorMapKey]
+              isPreviousErrorFromFormValidator: (
+                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
+                currentErrorMapSource?.[errorMapKey] === "form"
+              ),
+              // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
+              previousErrorValue: currentErrorMap?.[errorMapKey]
             });
             if (newSource === "form") {
               currentValidationErrorMap[field] = {
@@ -236,8 +202,11 @@ class FormApi {
                 [errorMapKey]: newFormValidatorError
               };
             }
-            if (currentErrorMap[errorMapKey] !== newErrorValue) {
-              this.setFieldMeta(field, (prev = defaultFieldMeta) => ({
+            if (
+              // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
+              currentErrorMap?.[errorMapKey] !== newErrorValue
+            ) {
+              this.setFieldMeta(field, (prev) => ({
                 ...prev,
                 errorMap: {
                   ...prev.errorMap,
@@ -276,6 +245,28 @@ class FormApi {
             }
           }));
         }
+        if (cause !== "submit" && !hasErrored) {
+          for (const field of Object.keys(
+            this.state.fieldMeta
+          )) {
+            const fieldMeta = this.getFieldMeta(field);
+            if (fieldMeta && // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
+            fieldMeta.errorMap?.[submitErrKey] !== void 0 && // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
+            fieldMeta.errorSourceMap?.[submitErrKey] === "form") {
+              this.setFieldMeta(field, (prev) => ({
+                ...prev,
+                errorMap: {
+                  ...prev.errorMap,
+                  [submitErrKey]: void 0
+                },
+                errorSourceMap: {
+                  ...prev.errorSourceMap,
+                  [submitErrKey]: void 0
+                }
+              }));
+            }
+          }
+        }
         const serverErrKey = getErrorMapKey("server");
         if (
           // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
@@ -289,6 +280,28 @@ class FormApi {
             }
           }));
         }
+        if (cause !== "server" && !hasErrored) {
+          for (const field of Object.keys(
+            this.state.fieldMeta
+          )) {
+            const fieldMeta = this.getFieldMeta(field);
+            if (fieldMeta && // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
+            fieldMeta.errorMap?.[serverErrKey] !== void 0 && // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
+            fieldMeta.errorSourceMap?.[serverErrKey] === "form") {
+              this.setFieldMeta(field, (prev) => ({
+                ...prev,
+                errorMap: {
+                  ...prev.errorMap,
+                  [serverErrKey]: void 0
+                },
+                errorSourceMap: {
+                  ...prev.errorSourceMap,
+                  [serverErrKey]: void 0
+                }
+              }));
+            }
+          }
+        }
       });
       return { hasErrored, fieldsErrorMap: currentValidationErrorMap };
     };
@@ -998,6 +1011,30 @@ class FormApi {
     });
     this.handleSubmit = this.handleSubmit.bind(this);
     this.update(opts || {});
+    this.store.subscribe(() => {
+      throttleFormState(this);
+    });
+    formEventClient.on("request-form-state", (e) => {
+      if (e.payload.id === this._formId) {
+        formEventClient.emit("form-api", {
+          id: this._formId,
+          state: this.store.state,
+          options: this.options
+        });
+      }
+    });
+    formEventClient.on("request-form-reset", (e) => {
+      if (e.payload.id === this._formId) {
+        this.reset();
+      }
+    });
+    formEventClient.on("request-form-force-submit", (e) => {
+      if (e.payload.id === this._formId) {
+        this._devtoolsSubmissionOverride = true;
+        this.handleSubmit();
+        this._devtoolsSubmissionOverride = false;
+      }
+    });
   }
   get state() {
     return this.store.state;
diff --git a/dist/esm/FormApi.js.map b/dist/esm/FormApi.js.map
index 5c456ace459cba96487a789868bbe842e137aab9..88d721a24e70969abc6acbf81cb6de0730ba6ba9 100644
--- a/dist/esm/FormApi.js.map
+++ b/dist/esm/FormApi.js.map
@@ -1 +1 @@
-{"version":3,"file":"FormApi.js","sources":["../../src/FormApi.ts"],"sourcesContent":["import { Derived, Store, batch } from '@tanstack/store'\nimport {\n  deleteBy,\n  determineFormLevelErrorSourceAndValue,\n  evaluate,\n  functionalUpdate,\n  getAsyncValidatorArray,\n  getBy,\n  getSyncValidatorArray,\n  isGlobalFormValidationError,\n  isNonEmptyArray,\n  mergeOpts,\n  setBy,\n  throttleFormState,\n  uuid,\n} from './utils'\nimport { defaultValidationLogic } from './ValidationLogic'\nimport {\n  isStandardSchemaValidator,\n  standardSchemaValidators,\n} from './standardSchemaValidator'\nimport { defaultFieldMeta, metaHelper } from './metaHelper'\nimport { formEventClient } from './EventClient'\n\n// types\nimport type { ValidationLogicFn } from './ValidationLogic'\nimport type {\n  StandardSchemaV1,\n  StandardSchemaV1Issue,\n  TStandardSchemaValidatorValue,\n} from './standardSchemaValidator'\nimport type {\n  AnyFieldApi,\n  AnyFieldMeta,\n  AnyFieldMetaBase,\n  FieldApi,\n} from './FieldApi'\nimport type {\n  ExtractGlobalFormError,\n  FieldManipulator,\n  FormValidationError,\n  FormValidationErrorMap,\n  ListenerCause,\n  UpdateMetaOptions,\n  ValidationCause,\n  ValidationError,\n  ValidationErrorMap,\n  ValidationErrorMapKeys,\n} from './types'\nimport type { DeepKeys, DeepKeysOfType, DeepValue } from './util-types'\nimport type { Updater } from './utils'\n\n/**\n * @private\n */\n// TODO: Add the `Unwrap` type to the errors\ntype FormErrorMapFromValidator<\n  TFormData,\n  TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnDynamic extends undefined | FormValidateOrFn<TFormData>,\n  TOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n> = Partial<\n  Record<\n    DeepKeys<TFormData>,\n    ValidationErrorMap<\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync\n    >\n  >\n>\n\nexport type FormValidateFn<TFormData> = (props: {\n  value: TFormData\n  formApi: FormApi<\n    TFormData,\n    // This is technically an edge-type; which we try to keep non-`any`, but in this case\n    // It's referring to an inaccessible type from the field validate function inner types, so it's not a big deal\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any\n  >\n}) => unknown\n\n/**\n * @private\n */\nexport type FormValidateOrFn<TFormData> =\n  | FormValidateFn<TFormData>\n  | StandardSchemaV1<TFormData, unknown>\n\nexport type UnwrapFormValidateOrFn<\n  TValidateOrFn extends undefined | FormValidateOrFn<any>,\n> = [TValidateOrFn] extends [FormValidateFn<any>]\n  ? ExtractGlobalFormError<ReturnType<TValidateOrFn>>\n  : [TValidateOrFn] extends [StandardSchemaV1<any, any>]\n    ? Record<string, StandardSchemaV1Issue[]>\n    : undefined\n\n/**\n * @private\n */\nexport type FormValidateAsyncFn<TFormData> = (props: {\n  value: TFormData\n  formApi: FormApi<\n    TFormData,\n    // This is technically an edge-type; which we try to keep non-`any`, but in this case\n    // It's referring to an inaccessible type from the field validate function inner types, so it's not a big deal\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any\n  >\n  signal: AbortSignal\n}) => unknown | Promise<unknown>\n\nexport type FormValidator<TFormData, TType, TFn = unknown> = {\n  validate(options: { value: TType }, fn: TFn): ValidationError\n  validateAsync(\n    options: { value: TType },\n    fn: TFn,\n  ): Promise<FormValidationError<TFormData>>\n}\n\ntype ValidationPromiseResult<TFormData> =\n  | {\n      fieldErrors: Partial<Record<DeepKeys<TFormData>, ValidationError>>\n      errorMapKey: ValidationErrorMapKeys\n    }\n  | undefined\n\n/**\n * @private\n */\nexport type FormAsyncValidateOrFn<TFormData> =\n  | FormValidateAsyncFn<TFormData>\n  | StandardSchemaV1<TFormData, unknown>\n\nexport type UnwrapFormAsyncValidateOrFn<\n  TValidateOrFn extends undefined | FormAsyncValidateOrFn<any>,\n> = [TValidateOrFn] extends [FormValidateAsyncFn<any>]\n  ? ExtractGlobalFormError<Awaited<ReturnType<TValidateOrFn>>>\n  : [TValidateOrFn] extends [StandardSchemaV1<any, any>]\n    ? Record<string, StandardSchemaV1Issue[]>\n    : undefined\n\nexport interface FormValidators<\n  TFormData,\n  TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnDynamic extends undefined | FormValidateOrFn<TFormData>,\n  TOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n> {\n  /**\n   * Optional function that fires as soon as the component mounts.\n   */\n  onMount?: TOnMount\n  /**\n   * Optional function that checks the validity of your data whenever a value changes\n   */\n  onChange?: TOnChange\n  /**\n   * Optional onChange asynchronous counterpart to onChange. Useful for more complex validation logic that might involve server requests.\n   */\n  onChangeAsync?: TOnChangeAsync\n  /**\n   * The default time in milliseconds that if set to a number larger than 0, will debounce the async validation event by this length of time in milliseconds.\n   */\n  onChangeAsyncDebounceMs?: number\n  /**\n   * Optional function that validates the form data when a field loses focus, returns a `FormValidationError`\n   */\n  onBlur?: TOnBlur\n  /**\n   * Optional onBlur asynchronous validation method for when a field loses focus returns a ` FormValidationError` or a promise of `Promise<FormValidationError>`\n   */\n  onBlurAsync?: TOnBlurAsync\n  /**\n   * The default time in milliseconds that if set to a number larger than 0, will debounce the async validation event by this length of time in milliseconds.\n   */\n  onBlurAsyncDebounceMs?: number\n  onSubmit?: TOnSubmit\n  onSubmitAsync?: TOnSubmitAsync\n  onDynamic?: TOnDynamic\n  onDynamicAsync?: TOnDynamicAsync\n  onDynamicAsyncDebounceMs?: number\n}\n\n/**\n * @private\n */\nexport interface FormTransform<\n  TFormData,\n  TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnDynamic extends undefined | FormValidateOrFn<TFormData>,\n  TOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnServer extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TSubmitMeta = never,\n> {\n  fn: (\n    formBase: FormApi<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer,\n      TSubmitMeta\n    >,\n  ) => FormApi<\n    TFormData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TOnDynamic,\n    TOnDynamicAsync,\n    TOnServer,\n    TSubmitMeta\n  >\n  deps: unknown[]\n}\n\nexport interface FormListeners<\n  TFormData,\n  TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnDynamic extends undefined | FormValidateOrFn<TFormData>,\n  TOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnServer extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TSubmitMeta = never,\n> {\n  onChange?: (props: {\n    formApi: FormApi<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer,\n      TSubmitMeta\n    >\n    fieldApi: AnyFieldApi\n  }) => void\n  onChangeDebounceMs?: number\n\n  onBlur?: (props: {\n    formApi: FormApi<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer,\n      TSubmitMeta\n    >\n    fieldApi: AnyFieldApi\n  }) => void\n  onBlurDebounceMs?: number\n\n  onMount?: (props: {\n    formApi: FormApi<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer,\n      TSubmitMeta\n    >\n  }) => void\n\n  onSubmit?: (props: {\n    formApi: FormApi<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer,\n      TSubmitMeta\n    >\n    meta: TSubmitMeta\n  }) => void\n}\n\n/**\n * An object representing the base properties of a form, unrelated to any validators\n */\nexport interface BaseFormOptions<in out TFormData, in out TSubmitMeta = never> {\n  /**\n   * Set initial values for your form.\n   */\n  defaultValues?: TFormData\n  /**\n   * onSubmitMeta, the data passed from the handleSubmit handler, to the onSubmit function props\n   */\n  onSubmitMeta?: TSubmitMeta\n}\n\n/**\n * An object representing the options for a form.\n */\nexport interface FormOptions<\n  in out TFormData,\n  in out TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnDynamic extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnServer extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TSubmitMeta = never,\n> extends BaseFormOptions<TFormData, TSubmitMeta> {\n  /**\n   * The form name, used for devtools and identification\n   */\n  formId?: string\n  /**\n   * The default state for the form.\n   */\n  defaultState?: Partial<\n    FormState<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer\n    >\n  >\n  /**\n   * If true, always run async validation, even when sync validation has produced an error. Defaults to undefined.\n   */\n  asyncAlways?: boolean\n  /**\n   * Optional time in milliseconds if you want to introduce a delay before firing off an async action.\n   */\n  asyncDebounceMs?: number\n  /**\n   * If true, allows the form to be submitted in an invalid state i.e. canSubmit will remain true regardless of validation errors. Defaults to undefined.\n   */\n  canSubmitWhenInvalid?: boolean\n  /**\n   * A list of validators to pass to the form\n   */\n  validators?: FormValidators<\n    TFormData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TOnDynamic,\n    TOnDynamicAsync\n  >\n\n  validationLogic?: ValidationLogicFn\n\n  /**\n   * form level listeners\n   */\n  listeners?: FormListeners<\n    TFormData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TOnDynamic,\n    TOnDynamicAsync,\n    TOnServer,\n    TSubmitMeta\n  >\n\n  /**\n   * A function to be called when the form is submitted, what should happen once the user submits a valid form returns `any` or a promise `Promise<any>`\n   */\n  onSubmit?: (props: {\n    value: TFormData\n    formApi: FormApi<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer,\n      TSubmitMeta\n    >\n    meta: TSubmitMeta\n  }) => any | Promise<any>\n  /**\n   * Specify an action for scenarios where the user tries to submit an invalid form.\n   */\n  onSubmitInvalid?: (props: {\n    value: TFormData\n    formApi: FormApi<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer,\n      TSubmitMeta\n    >\n    meta: TSubmitMeta\n  }) => void\n  transform?: FormTransform<\n    NoInfer<TFormData>,\n    NoInfer<TOnMount>,\n    NoInfer<TOnChange>,\n    NoInfer<TOnChangeAsync>,\n    NoInfer<TOnBlur>,\n    NoInfer<TOnBlurAsync>,\n    NoInfer<TOnSubmit>,\n    NoInfer<TOnSubmitAsync>,\n    NoInfer<TOnDynamic>,\n    NoInfer<TOnDynamicAsync>,\n    NoInfer<TOnServer>,\n    NoInfer<TSubmitMeta>\n  >\n}\n\nexport type AnyFormOptions = FormOptions<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any\n>\n\n/**\n * An object representing the validation metadata for a field. Not intended for public usage.\n */\nexport type ValidationMeta = {\n  /**\n   * An abort controller stored in memory to cancel previous async validation attempts.\n   */\n  lastAbortController: AbortController\n}\n\n/**\n * An object representing the field information for a specific field within the form.\n */\nexport type FieldInfo<TFormData> = {\n  /**\n   * An instance of the FieldAPI.\n   */\n  instance: FieldApi<\n    TFormData,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any\n  > | null\n  /**\n   * A record of field validation internal handling.\n   */\n  validationMetaMap: Record<ValidationErrorMapKeys, ValidationMeta | undefined>\n}\n\n/**\n * An object representing the current state of the form.\n */\nexport type BaseFormState<\n  in out TFormData,\n  in out TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnDynamic extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnServer extends undefined | FormAsyncValidateOrFn<TFormData>,\n> = {\n  /**\n   * The current values of the form fields.\n   */\n  values: TFormData\n  /**\n   * The error map for the form itself.\n   */\n  errorMap: ValidationErrorMap<\n    UnwrapFormValidateOrFn<TOnMount>,\n    UnwrapFormValidateOrFn<TOnChange>,\n    UnwrapFormAsyncValidateOrFn<TOnChangeAsync>,\n    UnwrapFormValidateOrFn<TOnBlur>,\n    UnwrapFormAsyncValidateOrFn<TOnBlurAsync>,\n    UnwrapFormValidateOrFn<TOnSubmit>,\n    UnwrapFormAsyncValidateOrFn<TOnSubmitAsync>,\n    UnwrapFormValidateOrFn<TOnDynamic>,\n    UnwrapFormAsyncValidateOrFn<TOnDynamicAsync>,\n    UnwrapFormAsyncValidateOrFn<TOnServer>\n  >\n  /**\n   * An internal mechanism used for keeping track of validation logic in a form.\n   */\n  validationMetaMap: Record<ValidationErrorMapKeys, ValidationMeta | undefined>\n  /**\n   * A record of field metadata for each field in the form, not including the derived properties, like `errors` and such\n   */\n  fieldMetaBase: Partial<Record<DeepKeys<TFormData>, AnyFieldMetaBase>>\n  /**\n   * A boolean indicating if the form is currently in the process of being submitted after `handleSubmit` is called.\n   *\n   * Goes back to `false` when submission completes for one of the following reasons:\n   * - the validation step returned errors.\n   * - the `onSubmit` function has completed.\n   *\n   * Note: if you're running async operations in your `onSubmit` function make sure to await them to ensure `isSubmitting` is set to `false` only when the async operation completes.\n   *\n   * This is useful for displaying loading indicators or disabling form inputs during submission.\n   *\n   */\n  isSubmitting: boolean\n  /**\n   * A boolean indicating if the `onSubmit` function has completed successfully.\n   *\n   * Goes back to `false` at each new submission attempt.\n   *\n   * Note: you can use isSubmitting to check if the form is currently submitting.\n   */\n  isSubmitted: boolean\n  /**\n   * A boolean indicating if the form or any of its fields are currently validating.\n   */\n  isValidating: boolean\n  /**\n   * A counter for tracking the number of submission attempts.\n   */\n  submissionAttempts: number\n  /**\n   * A boolean indicating if the last submission was successful.\n   */\n  isSubmitSuccessful: boolean\n  /**\n   * @private, used to force a re-evaluation of the form state when options change\n   */\n  _force_re_eval?: boolean\n}\n\nexport type DerivedFormState<\n  in out TFormData,\n  in out TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnDynamic extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnServer extends undefined | FormAsyncValidateOrFn<TFormData>,\n> = {\n  /**\n   * A boolean indicating if the form is currently validating.\n   */\n  isFormValidating: boolean\n  /**\n   * A boolean indicating if the form is valid.\n   */\n  isFormValid: boolean\n  /**\n   * The error array for the form itself.\n   */\n  errors: Array<\n    | UnwrapFormValidateOrFn<TOnMount>\n    | UnwrapFormValidateOrFn<TOnChange>\n    | UnwrapFormAsyncValidateOrFn<TOnChangeAsync>\n    | UnwrapFormValidateOrFn<TOnBlur>\n    | UnwrapFormAsyncValidateOrFn<TOnBlurAsync>\n    | UnwrapFormValidateOrFn<TOnSubmit>\n    | UnwrapFormAsyncValidateOrFn<TOnSubmitAsync>\n    | UnwrapFormValidateOrFn<TOnDynamic>\n    | UnwrapFormAsyncValidateOrFn<TOnDynamicAsync>\n    | UnwrapFormAsyncValidateOrFn<TOnServer>\n  >\n  /**\n   * A boolean indicating if any of the form fields are currently validating.\n   */\n  isFieldsValidating: boolean\n  /**\n   * A boolean indicating if all the form fields are valid. Evaluates `true` if there are no field errors.\n   */\n  isFieldsValid: boolean\n  /**\n   * A boolean indicating if any of the form fields have been touched.\n   */\n  isTouched: boolean\n  /**\n   * A boolean indicating if any of the form fields have been blurred.\n   */\n  isBlurred: boolean\n  /**\n   * A boolean indicating if any of the form's fields' values have been modified by the user. Evaluates `true` if the user have modified at least one of the fields. Opposite of `isPristine`.\n   */\n  isDirty: boolean\n  /**\n   * A boolean indicating if none of the form's fields' values have been modified by the user. Evaluates `true` if the user have not modified any of the fields. Opposite of `isDirty`.\n   */\n  isPristine: boolean\n  /**\n   * A boolean indicating if all of the form's fields are the same as default values.\n   */\n  isDefaultValue: boolean\n  /**\n   * A boolean indicating if the form and all its fields are valid. Evaluates `true` if there are no errors.\n   */\n  isValid: boolean\n  /**\n   * A boolean indicating if the form can be submitted based on its current state.\n   */\n  canSubmit: boolean\n  /**\n   * A record of field metadata for each field in the form.\n   */\n  fieldMeta: Partial<Record<DeepKeys<TFormData>, AnyFieldMeta>>\n}\n\nexport interface FormState<\n  in out TFormData,\n  in out TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnDynamic extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnServer extends undefined | FormAsyncValidateOrFn<TFormData>,\n>\n  extends\n    BaseFormState<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer\n    >,\n    DerivedFormState<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer\n    > {}\n\nexport type AnyFormState = FormState<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any\n>\n\nfunction getDefaultFormState<\n  TFormData,\n  TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnDynamic extends undefined | FormValidateOrFn<TFormData>,\n  TOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnServer extends undefined | FormAsyncValidateOrFn<TFormData>,\n>(\n  defaultState: Partial<\n    FormState<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer\n    >\n  >,\n): BaseFormState<\n  TFormData,\n  TOnMount,\n  TOnChange,\n  TOnChangeAsync,\n  TOnBlur,\n  TOnBlurAsync,\n  TOnSubmit,\n  TOnSubmitAsync,\n  TOnDynamic,\n  TOnDynamicAsync,\n  TOnServer\n> {\n  return {\n    values: defaultState.values ?? ({} as never),\n    errorMap: defaultState.errorMap ?? {},\n    fieldMetaBase: defaultState.fieldMetaBase ?? ({} as never),\n    isSubmitted: defaultState.isSubmitted ?? false,\n    isSubmitting: defaultState.isSubmitting ?? false,\n    isValidating: defaultState.isValidating ?? false,\n    submissionAttempts: defaultState.submissionAttempts ?? 0,\n    isSubmitSuccessful: defaultState.isSubmitSuccessful ?? false,\n    validationMetaMap: defaultState.validationMetaMap ?? {\n      onChange: undefined,\n      onBlur: undefined,\n      onSubmit: undefined,\n      onMount: undefined,\n      onServer: undefined,\n      onDynamic: undefined,\n    },\n  }\n}\n\n/**\n * @public\n *\n * A type representing the Form API with all generics set to `any` for convenience.\n */\nexport type AnyFormApi = FormApi<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any\n>\n\n/**\n * We cannot use methods and must use arrow functions. Otherwise, our React adapters\n * will break due to loss of the method when using spread.\n */\n\n/**\n * A class representing the Form API. It handles the logic and interactions with the form state.\n *\n * Normally, you will not need to create a new `FormApi` instance directly. Instead, you will use a framework\n * hook/function like `useForm` or `createForm` to create a new instance for you that uses your framework's reactivity model.\n * However, if you need to create a new instance manually, you can do so by calling the `new FormApi` constructor.\n */\nexport class FormApi<\n  in out TFormData,\n  in out TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnDynamic extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnServer extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TSubmitMeta = never,\n> implements FieldManipulator<TFormData, TSubmitMeta> {\n  /**\n   * The options for the form.\n   */\n  options: FormOptions<\n    TFormData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TOnDynamic,\n    TOnDynamicAsync,\n    TOnServer,\n    TSubmitMeta\n  > = {}\n  baseStore!: Store<\n    BaseFormState<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer\n    >\n  >\n  fieldMetaDerived: Derived<\n    FormState<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer\n    >['fieldMeta']\n  >\n  store: Derived<\n    FormState<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer\n    >\n  >\n  /**\n   * A record of field information for each field in the form.\n   */\n  fieldInfo: Record<DeepKeys<TFormData>, FieldInfo<TFormData>> = {} as any\n\n  get state() {\n    return this.store.state\n  }\n\n  /**\n   * @private\n   */\n  prevTransformArray: unknown[] = []\n\n  /**\n   * @private\n   */\n  timeoutIds: {\n    validations: Record<ValidationCause, ReturnType<typeof setTimeout> | null>\n    listeners: Record<ListenerCause, ReturnType<typeof setTimeout> | null>\n    formListeners: Record<ListenerCause, ReturnType<typeof setTimeout> | null>\n  }\n  /**\n   * @private\n   */\n  _formId: string\n  /**\n   * @private\n   */\n  private _devtoolsSubmissionOverride: boolean\n\n  /**\n   * Constructs a new `FormApi` instance with the given form options.\n   */\n  constructor(\n    opts?: FormOptions<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer,\n      TSubmitMeta\n    >,\n  ) {\n    this.timeoutIds = {\n      validations: {} as Record<ValidationCause, never>,\n      listeners: {} as Record<ListenerCause, never>,\n      formListeners: {} as Record<ListenerCause, never>,\n    }\n\n    this._formId = opts?.formId ?? uuid()\n\n    this._devtoolsSubmissionOverride = false\n\n    this.baseStore = new Store(\n      getDefaultFormState({\n        ...(opts?.defaultState as any),\n        values: opts?.defaultValues ?? opts?.defaultState?.values,\n        isFormValid: true,\n      }),\n    )\n\n    this.fieldMetaDerived = new Derived({\n      deps: [this.baseStore],\n      fn: ({ prevDepVals, currDepVals, prevVal: _prevVal }) => {\n        const prevVal = _prevVal as\n          | Record<DeepKeys<TFormData>, AnyFieldMeta>\n          | undefined\n        const prevBaseStore = prevDepVals?.[0]\n        const currBaseStore = currDepVals[0]\n\n        let originalMetaCount = 0\n\n        const fieldMeta: FormState<\n          TFormData,\n          TOnMount,\n          TOnChange,\n          TOnChangeAsync,\n          TOnBlur,\n          TOnBlurAsync,\n          TOnSubmit,\n          TOnSubmitAsync,\n          TOnDynamic,\n          TOnDynamicAsync,\n          TOnServer\n        >['fieldMeta'] = {}\n\n        for (const fieldName of Object.keys(\n          currBaseStore.fieldMetaBase,\n        ) as Array<keyof typeof currBaseStore.fieldMetaBase>) {\n          const currBaseMeta = currBaseStore.fieldMetaBase[\n            fieldName as never\n          ] as AnyFieldMetaBase\n\n          const prevBaseMeta = prevBaseStore?.fieldMetaBase[\n            fieldName as never\n          ] as AnyFieldMetaBase | undefined\n\n          const prevFieldInfo =\n            prevVal?.[fieldName as never as keyof typeof prevVal]\n\n          const curFieldVal = getBy(currBaseStore.values, fieldName)\n\n          let fieldErrors = prevFieldInfo?.errors\n          if (\n            !prevBaseMeta ||\n            currBaseMeta.errorMap !== prevBaseMeta.errorMap\n          ) {\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            fieldErrors = Object.values(currBaseMeta.errorMap ?? {}).filter(\n              (val) => val !== undefined,\n            )\n\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            const fieldInstance = this.getFieldInfo(fieldName)?.instance\n\n            if (fieldInstance && !fieldInstance.options.disableErrorFlat) {\n              fieldErrors = fieldErrors.flat(1)\n            }\n          }\n\n          // As primitives, we don't need to aggressively persist the same referential value for performance reasons\n          const isFieldValid = !isNonEmptyArray(fieldErrors)\n          const isFieldPristine = !currBaseMeta.isDirty\n          const isDefaultValue =\n            evaluate(\n              curFieldVal,\n              getBy(this.options.defaultValues, fieldName),\n            ) ||\n            evaluate(\n              curFieldVal,\n              // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n              this.getFieldInfo(fieldName)?.instance?.options.defaultValue,\n            )\n\n          if (\n            prevFieldInfo &&\n            prevFieldInfo.isPristine === isFieldPristine &&\n            prevFieldInfo.isValid === isFieldValid &&\n            prevFieldInfo.isDefaultValue === isDefaultValue &&\n            prevFieldInfo.errors === fieldErrors &&\n            currBaseMeta === prevBaseMeta\n          ) {\n            fieldMeta[fieldName] = prevFieldInfo\n            originalMetaCount++\n            continue\n          }\n\n          fieldMeta[fieldName] = {\n            ...currBaseMeta,\n            errors: fieldErrors ?? [],\n            isPristine: isFieldPristine,\n            isValid: isFieldValid,\n            isDefaultValue: isDefaultValue,\n          } satisfies AnyFieldMeta as AnyFieldMeta\n        }\n\n        if (!Object.keys(currBaseStore.fieldMetaBase).length) return fieldMeta\n\n        if (\n          prevVal &&\n          originalMetaCount === Object.keys(currBaseStore.fieldMetaBase).length\n        ) {\n          return prevVal\n        }\n\n        return fieldMeta\n      },\n    })\n\n    this.store = new Derived({\n      deps: [this.baseStore, this.fieldMetaDerived],\n      fn: ({ prevDepVals, currDepVals, prevVal: _prevVal }) => {\n        const prevVal = _prevVal as\n          | FormState<\n              TFormData,\n              TOnMount,\n              TOnChange,\n              TOnChangeAsync,\n              TOnBlur,\n              TOnBlurAsync,\n              TOnSubmit,\n              TOnSubmitAsync,\n              TOnDynamic,\n              TOnDynamicAsync,\n              TOnServer\n            >\n          | undefined\n        const prevBaseStore = prevDepVals?.[0]\n        const currBaseStore = currDepVals[0]\n        const currFieldMeta = currDepVals[1]\n\n        // Computed state\n        const fieldMetaValues = Object.values(currFieldMeta).filter(\n          Boolean,\n        ) as AnyFieldMeta[]\n\n        const isFieldsValidating = fieldMetaValues.some(\n          (field) => field.isValidating,\n        )\n\n        const isFieldsValid = fieldMetaValues.every((field) => field.isValid)\n\n        const isTouched = fieldMetaValues.some((field) => field.isTouched)\n        const isBlurred = fieldMetaValues.some((field) => field.isBlurred)\n        const isDefaultValue = fieldMetaValues.every(\n          (field) => field.isDefaultValue,\n        )\n\n        const shouldInvalidateOnMount =\n          // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n          isTouched && currBaseStore.errorMap?.onMount\n\n        const isDirty = fieldMetaValues.some((field) => field.isDirty)\n        const isPristine = !isDirty\n\n        const hasOnMountError = Boolean(\n          // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n          currBaseStore.errorMap?.onMount ||\n          // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n          fieldMetaValues.some((f) => f?.errorMap?.onMount),\n        )\n\n        const isValidating = !!isFieldsValidating\n\n        // As `errors` is not a primitive, we need to aggressively persist the same referencial value for performance reasons\n        let errors = prevVal?.errors ?? []\n        if (\n          !prevBaseStore ||\n          currBaseStore.errorMap !== prevBaseStore.errorMap\n        ) {\n          errors = Object.values(currBaseStore.errorMap).reduce<\n            Array<\n              | UnwrapFormValidateOrFn<TOnMount>\n              | UnwrapFormValidateOrFn<TOnChange>\n              | UnwrapFormAsyncValidateOrFn<TOnChangeAsync>\n              | UnwrapFormValidateOrFn<TOnBlur>\n              | UnwrapFormAsyncValidateOrFn<TOnBlurAsync>\n              | UnwrapFormValidateOrFn<TOnSubmit>\n              | UnwrapFormAsyncValidateOrFn<TOnSubmitAsync>\n              | UnwrapFormAsyncValidateOrFn<TOnServer>\n            >\n          >((prev, curr) => {\n            if (curr === undefined) return prev\n\n            if (curr && isGlobalFormValidationError(curr)) {\n              prev.push(curr.form as never)\n              return prev\n            }\n            prev.push(curr as never)\n            return prev\n          }, [])\n        }\n\n        const isFormValid = errors.length === 0\n        const isValid = isFieldsValid && isFormValid\n        const submitInvalid = this.options.canSubmitWhenInvalid ?? false\n        const canSubmit =\n          (currBaseStore.submissionAttempts === 0 &&\n            !isTouched &&\n            !hasOnMountError) ||\n          (!isValidating && !currBaseStore.isSubmitting && isValid) ||\n          submitInvalid\n\n        let errorMap = currBaseStore.errorMap\n        if (shouldInvalidateOnMount) {\n          errors = errors.filter(\n            (err) => err !== currBaseStore.errorMap.onMount,\n          )\n          errorMap = Object.assign(errorMap, { onMount: undefined })\n        }\n\n        if (\n          prevVal &&\n          prevBaseStore &&\n          prevVal.errorMap === errorMap &&\n          prevVal.fieldMeta === this.fieldMetaDerived.state &&\n          prevVal.errors === errors &&\n          prevVal.isFieldsValidating === isFieldsValidating &&\n          prevVal.isFieldsValid === isFieldsValid &&\n          prevVal.isFormValid === isFormValid &&\n          prevVal.isValid === isValid &&\n          prevVal.canSubmit === canSubmit &&\n          prevVal.isTouched === isTouched &&\n          prevVal.isBlurred === isBlurred &&\n          prevVal.isPristine === isPristine &&\n          prevVal.isDefaultValue === isDefaultValue &&\n          prevVal.isDirty === isDirty &&\n          evaluate(prevBaseStore, currBaseStore)\n        ) {\n          return prevVal\n        }\n\n        let state = {\n          ...currBaseStore,\n          errorMap,\n          fieldMeta: this.fieldMetaDerived.state,\n          errors,\n          isFieldsValidating,\n          isFieldsValid,\n          isFormValid,\n          isValid,\n          canSubmit,\n          isTouched,\n          isBlurred,\n          isPristine,\n          isDefaultValue,\n          isDirty,\n        } as FormState<\n          TFormData,\n          TOnMount,\n          TOnChange,\n          TOnChangeAsync,\n          TOnBlur,\n          TOnBlurAsync,\n          TOnSubmit,\n          TOnSubmitAsync,\n          TOnDynamic,\n          TOnDynamicAsync,\n          TOnServer\n        >\n\n        // Only run transform if state has shallowly changed - IE how React.useEffect works\n        const transformArray = this.options.transform?.deps ?? []\n        const shouldTransform =\n          transformArray.length !== this.prevTransformArray.length ||\n          transformArray.some((val, i) => val !== this.prevTransformArray[i])\n\n        if (shouldTransform) {\n          const newObj = Object.assign({}, this, { state })\n          // This mutates the state\n          this.options.transform?.fn(newObj)\n          state = newObj.state\n          this.prevTransformArray = transformArray\n        }\n\n        return state\n      },\n    })\n\n    this.handleSubmit = this.handleSubmit.bind(this)\n\n    this.update(opts || {})\n  }\n\n  get formId(): string {\n    return this._formId\n  }\n\n  /**\n   * @private\n   */\n  runValidator<\n    TValue extends TStandardSchemaValidatorValue<TFormData> & {\n      formApi: AnyFormApi\n    },\n    TType extends 'validate' | 'validateAsync',\n  >(props: {\n    validate: TType extends 'validate'\n      ? FormValidateOrFn<TFormData>\n      : FormAsyncValidateOrFn<TFormData>\n    value: TValue\n    type: TType\n  }): unknown {\n    if (isStandardSchemaValidator(props.validate)) {\n      return standardSchemaValidators[props.type](\n        props.value,\n        props.validate,\n      ) as never\n    }\n\n    return (props.validate as FormValidateFn<any>)(props.value) as never\n  }\n\n  mount = () => {\n    const cleanupFieldMetaDerived = this.fieldMetaDerived.mount()\n    const cleanupStoreDerived = this.store.mount()\n\n    // devtool broadcasts\n    const cleanupDevtoolBroadcast = this.store.subscribe(() => {\n      throttleFormState(this)\n    })\n\n    // devtool requests\n    const cleanupFormStateListener = formEventClient.on(\n      'request-form-state',\n      (e) => {\n        if (e.payload.id === this._formId) {\n          formEventClient.emit('form-api', {\n            id: this._formId,\n            state: this.store.state,\n            options: this.options,\n          })\n        }\n      },\n    )\n\n    const cleanupFormResetListener = formEventClient.on(\n      'request-form-reset',\n      (e) => {\n        if (e.payload.id === this._formId) {\n          this.reset()\n        }\n      },\n    )\n\n    const cleanupFormForceSubmitListener = formEventClient.on(\n      'request-form-force-submit',\n      (e) => {\n        if (e.payload.id === this._formId) {\n          this._devtoolsSubmissionOverride = true\n          this.handleSubmit()\n          this._devtoolsSubmissionOverride = false\n        }\n      },\n    )\n\n    const cleanup = () => {\n      cleanupFormForceSubmitListener()\n      cleanupFormResetListener()\n      cleanupFormStateListener()\n      cleanupDevtoolBroadcast()\n      cleanupFieldMetaDerived()\n      cleanupStoreDerived()\n\n      // broadcast form unmount for devtools\n      formEventClient.emit('form-unmounted', {\n        id: this._formId,\n      })\n    }\n\n    this.options.listeners?.onMount?.({ formApi: this })\n\n    const { onMount } = this.options.validators || {}\n\n    // broadcast form state for devtools on mounting\n    formEventClient.emit('form-api', {\n      id: this._formId,\n      state: this.store.state,\n      options: this.options,\n    })\n\n    // if no validation skip\n    if (!onMount) return cleanup\n\n    // validate\n    this.validateSync('mount')\n    return cleanup\n  }\n\n  /**\n   * Updates the form options and form state.\n   */\n  update = (\n    options?: FormOptions<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer,\n      TSubmitMeta\n    >,\n  ) => {\n    if (!options) return\n\n    const oldOptions = this.options\n\n    // Options need to be updated first so that when the store is updated, the state is correct for the derived state\n    this.options = options\n\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    const shouldUpdateReeval = !!options.transform?.deps?.some(\n      (val, i) => val !== this.prevTransformArray[i],\n    )\n\n    const shouldUpdateValues =\n      options.defaultValues &&\n      !evaluate(options.defaultValues, oldOptions.defaultValues) &&\n      !this.state.isTouched\n\n    const shouldUpdateState =\n      !evaluate(options.defaultState, oldOptions.defaultState) &&\n      !this.state.isTouched\n\n    if (!shouldUpdateValues && !shouldUpdateState && !shouldUpdateReeval) return\n\n    batch(() => {\n      this.baseStore.setState(() =>\n        getDefaultFormState(\n          Object.assign(\n            {},\n            this.state as any,\n\n            shouldUpdateState ? options.defaultState : {},\n\n            shouldUpdateValues\n              ? {\n                  values: options.defaultValues,\n                }\n              : {},\n\n            shouldUpdateReeval\n              ? { _force_re_eval: !this.state._force_re_eval }\n              : {},\n          ),\n        ),\n      )\n    })\n\n    formEventClient.emit('form-api', {\n      id: this._formId,\n      state: this.store.state,\n      options: this.options,\n    })\n  }\n\n  /**\n   * Resets the form state to the default values.\n   * If values are provided, the form will be reset to those values instead and the default values will be updated.\n   *\n   * @param values - Optional values to reset the form to.\n   * @param opts - Optional options to control the reset behavior.\n   */\n  reset = (values?: TFormData, opts?: { keepDefaultValues?: boolean }) => {\n    const { fieldMeta: currentFieldMeta } = this.state\n    const fieldMetaBase = this.resetFieldMeta(currentFieldMeta)\n\n    if (values && !opts?.keepDefaultValues) {\n      this.options = {\n        ...this.options,\n        defaultValues: values,\n      }\n    }\n\n    this.baseStore.setState(() =>\n      getDefaultFormState({\n        ...(this.options.defaultState as any),\n        values:\n          values ??\n          this.options.defaultValues ??\n          this.options.defaultState?.values,\n        fieldMetaBase,\n      }),\n    )\n  }\n\n  /**\n   * Validates all fields using the correct handlers for a given validation cause.\n   */\n  validateAllFields = async (cause: ValidationCause) => {\n    const fieldValidationPromises: Promise<ValidationError[]>[] = [] as any\n    batch(() => {\n      void (Object.values(this.fieldInfo) as FieldInfo<any>[]).forEach(\n        (field) => {\n          if (!field.instance) return\n          const fieldInstance = field.instance\n          // Validate the field\n          fieldValidationPromises.push(\n            // Remember, `validate` is either a sync operation or a promise\n            Promise.resolve().then(() =>\n              fieldInstance.validate(cause, { skipFormValidation: true }),\n            ),\n          )\n          // If any fields are not touched\n          if (!field.instance.state.meta.isTouched) {\n            // Mark them as touched\n            field.instance.setMeta((prev) => ({ ...prev, isTouched: true }))\n          }\n        },\n      )\n    })\n\n    const fieldErrorMapMap = await Promise.all(fieldValidationPromises)\n    return fieldErrorMapMap.flat()\n  }\n\n  /**\n   * Validates the children of a specified array in the form starting from a given index until the end using the correct handlers for a given validation type.\n   */\n  validateArrayFieldsStartingFrom = async <\n    TField extends DeepKeysOfType<TFormData, any[]>,\n  >(\n    field: TField,\n    index: number,\n    cause: ValidationCause,\n  ) => {\n    const currentValue = this.getFieldValue(field)\n\n    const lastIndex = Array.isArray(currentValue)\n      ? Math.max((currentValue as Array<unknown>).length - 1, 0)\n      : null\n\n    // We have to validate all fields that have shifted (at least the current field)\n    const fieldKeysToValidate = [`${field}[${index}]`]\n    for (let i = index + 1; i <= (lastIndex ?? 0); i++) {\n      fieldKeysToValidate.push(`${field}[${i}]`)\n    }\n\n    // We also have to include all fields that are nested in the shifted fields\n    const fieldsToValidate = Object.keys(this.fieldInfo).filter((fieldKey) =>\n      fieldKeysToValidate.some((key) => fieldKey.startsWith(key)),\n    ) as DeepKeys<TFormData>[]\n\n    // Validate the fields\n    const fieldValidationPromises: Promise<ValidationError[]>[] = [] as any\n    batch(() => {\n      fieldsToValidate.forEach((nestedField) => {\n        fieldValidationPromises.push(\n          Promise.resolve().then(() => this.validateField(nestedField, cause)),\n        )\n      })\n    })\n\n    const fieldErrorMapMap = await Promise.all(fieldValidationPromises)\n    return fieldErrorMapMap.flat()\n  }\n\n  /**\n   * Validates a specified field in the form using the correct handlers for a given validation type.\n   */\n  validateField = <TField extends DeepKeys<TFormData>>(\n    field: TField,\n    cause: ValidationCause,\n  ) => {\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    const fieldInstance = this.fieldInfo[field]?.instance\n    if (!fieldInstance) return []\n\n    // If the field is not touched (same logic as in validateAllFields)\n    if (!fieldInstance.state.meta.isTouched) {\n      // Mark it as touched\n      fieldInstance.setMeta((prev) => ({ ...prev, isTouched: true }))\n    }\n\n    return fieldInstance.validate(cause)\n  }\n\n  /**\n   * TODO: This code is copied from FieldApi, we should refactor to share\n   * @private\n   */\n  validateSync = (\n    cause: ValidationCause,\n  ): {\n    hasErrored: boolean\n    fieldsErrorMap: FormErrorMapFromValidator<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync\n    >\n  } => {\n    const validates = getSyncValidatorArray(cause, {\n      ...this.options,\n      form: this,\n      validationLogic: this.options.validationLogic || defaultValidationLogic,\n    })\n\n    let hasErrored = false as boolean\n\n    // This map will only include fields that have errors in the current validation cycle\n    const currentValidationErrorMap: FormErrorMapFromValidator<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync\n    > = {}\n\n    batch(() => {\n      for (const validateObj of validates) {\n        if (!validateObj.validate) continue\n\n        const rawError = this.runValidator({\n          validate: validateObj.validate,\n          value: {\n            value: this.state.values,\n            formApi: this,\n            validationSource: 'form',\n          },\n          type: 'validate',\n        })\n\n        const { formError, fieldErrors } = normalizeError<TFormData>(rawError)\n\n        const errorMapKey = getErrorMapKey(validateObj.cause)\n\n        const allFieldsToProcess = new Set([\n          ...Object.keys(this.state.fieldMeta),\n          ...Object.keys(fieldErrors || {}),\n        ] as DeepKeys<TFormData>[])\n\n        for (const field of allFieldsToProcess) {\n          if (\n            this.baseStore.state.fieldMetaBase[field] === undefined &&\n            !fieldErrors?.[field]\n          ) {\n            continue\n          }\n\n          const fieldMeta = this.getFieldMeta(field) ?? defaultFieldMeta\n          const {\n            errorMap: currentErrorMap,\n            errorSourceMap: currentErrorMapSource,\n          } = fieldMeta\n\n          const newFormValidatorError = fieldErrors?.[field]\n\n          const { newErrorValue, newSource } =\n            determineFormLevelErrorSourceAndValue({\n              newFormValidatorError,\n              isPreviousErrorFromFormValidator:\n                currentErrorMapSource[errorMapKey] === 'form',\n              previousErrorValue: currentErrorMap[errorMapKey],\n            })\n\n          if (newSource === 'form') {\n            currentValidationErrorMap[field] = {\n              ...currentValidationErrorMap[field],\n              [errorMapKey]: newFormValidatorError,\n            }\n          }\n\n          if (currentErrorMap[errorMapKey] !== newErrorValue) {\n            this.setFieldMeta(field, (prev = defaultFieldMeta) => ({\n              ...prev,\n              errorMap: {\n                ...prev.errorMap,\n                [errorMapKey]: newErrorValue,\n              },\n              errorSourceMap: {\n                ...prev.errorSourceMap,\n                [errorMapKey]: newSource,\n              },\n            }))\n          }\n        }\n\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (this.state.errorMap?.[errorMapKey] !== formError) {\n          this.baseStore.setState((prev) => ({\n            ...prev,\n            errorMap: {\n              ...prev.errorMap,\n              [errorMapKey]: formError,\n            },\n          }))\n        }\n\n        if (formError || fieldErrors) {\n          hasErrored = true\n        }\n      }\n\n      /**\n       *  when we have an error for onSubmit in the state, we want\n       *  to clear the error as soon as the user enters a valid value in the field\n       */\n      const submitErrKey = getErrorMapKey('submit')\n      if (\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        this.state.errorMap?.[submitErrKey] &&\n        cause !== 'submit' &&\n        !hasErrored\n      ) {\n        this.baseStore.setState((prev) => ({\n          ...prev,\n          errorMap: {\n            ...prev.errorMap,\n            [submitErrKey]: undefined,\n          },\n        }))\n      }\n\n      /**\n       *  when we have an error for onServer in the state, we want\n       *  to clear the error as soon as the user enters a valid value in the field\n       */\n      const serverErrKey = getErrorMapKey('server')\n      if (\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        this.state.errorMap?.[serverErrKey] &&\n        cause !== 'server' &&\n        !hasErrored\n      ) {\n        this.baseStore.setState((prev) => ({\n          ...prev,\n          errorMap: {\n            ...prev.errorMap,\n            [serverErrKey]: undefined,\n          },\n        }))\n      }\n    })\n\n    return { hasErrored, fieldsErrorMap: currentValidationErrorMap }\n  }\n\n  /**\n   * @private\n   */\n  validateAsync = async (\n    cause: ValidationCause,\n  ): Promise<\n    FormErrorMapFromValidator<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync\n    >\n  > => {\n    const validates = getAsyncValidatorArray(cause, {\n      ...this.options,\n      form: this,\n      validationLogic: this.options.validationLogic || defaultValidationLogic,\n    })\n\n    if (!this.state.isFormValidating) {\n      this.baseStore.setState((prev) => ({ ...prev, isFormValidating: true }))\n    }\n\n    /**\n     * We have to use a for loop and generate our promises this way, otherwise it won't be sync\n     * when there are no validators needed to be run\n     */\n    const promises: Promise<ValidationPromiseResult<TFormData>>[] = []\n\n    let fieldErrorsFromFormValidators:\n      | Partial<Record<DeepKeys<TFormData>, ValidationError>>\n      | undefined\n\n    for (const validateObj of validates) {\n      if (!validateObj.validate) continue\n      const key = getErrorMapKey(validateObj.cause)\n      const fieldValidatorMeta = this.state.validationMetaMap[key]\n\n      fieldValidatorMeta?.lastAbortController.abort()\n      const controller = new AbortController()\n\n      this.state.validationMetaMap[key] = {\n        lastAbortController: controller,\n      }\n\n      promises.push(\n        new Promise<ValidationPromiseResult<TFormData>>(async (resolve) => {\n          let rawError!:\n            | ValidationError\n            | FormValidationError<unknown>\n            | undefined\n          try {\n            rawError = await new Promise((rawResolve, rawReject) => {\n              setTimeout(async () => {\n                if (controller.signal.aborted) return rawResolve(undefined)\n                try {\n                  rawResolve(\n                    await this.runValidator({\n                      validate: validateObj.validate!,\n                      value: {\n                        value: this.state.values,\n                        formApi: this,\n                        validationSource: 'form',\n                        signal: controller.signal,\n                      },\n                      type: 'validateAsync',\n                    }),\n                  )\n                } catch (e) {\n                  rawReject(e)\n                }\n              }, validateObj.debounceMs)\n            })\n          } catch (e: unknown) {\n            rawError = e as ValidationError\n          }\n          const { formError, fieldErrors: fieldErrorsFromNormalizeError } =\n            normalizeError<TFormData>(rawError)\n\n          if (fieldErrorsFromNormalizeError) {\n            fieldErrorsFromFormValidators = fieldErrorsFromFormValidators\n              ? {\n                  ...fieldErrorsFromFormValidators,\n                  ...fieldErrorsFromNormalizeError,\n                }\n              : fieldErrorsFromNormalizeError\n          }\n          const errorMapKey = getErrorMapKey(validateObj.cause)\n\n          for (const field of Object.keys(\n            this.state.fieldMeta,\n          ) as DeepKeys<TFormData>[]) {\n            if (this.baseStore.state.fieldMetaBase[field] === undefined) {\n              continue\n            }\n\n            const fieldMeta = this.getFieldMeta(field)\n            if (!fieldMeta) continue\n\n            const {\n              errorMap: currentErrorMap,\n              errorSourceMap: currentErrorMapSource,\n            } = fieldMeta\n\n            const newFormValidatorError = fieldErrorsFromFormValidators?.[field]\n\n            const { newErrorValue, newSource } =\n              determineFormLevelErrorSourceAndValue({\n                newFormValidatorError,\n                isPreviousErrorFromFormValidator:\n                  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n                  currentErrorMapSource?.[errorMapKey] === 'form',\n                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n                previousErrorValue: currentErrorMap?.[errorMapKey],\n              })\n\n            if (\n              // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n              currentErrorMap?.[errorMapKey] !== newErrorValue\n            ) {\n              this.setFieldMeta(field, (prev) => ({\n                ...prev,\n                errorMap: {\n                  ...prev.errorMap,\n                  [errorMapKey]: newErrorValue,\n                },\n                errorSourceMap: {\n                  ...prev.errorSourceMap,\n                  [errorMapKey]: newSource,\n                },\n              }))\n            }\n          }\n\n          this.baseStore.setState((prev) => ({\n            ...prev,\n            errorMap: {\n              ...prev.errorMap,\n              [errorMapKey]: formError,\n            },\n          }))\n\n          resolve(\n            fieldErrorsFromFormValidators\n              ? { fieldErrors: fieldErrorsFromFormValidators, errorMapKey }\n              : undefined,\n          )\n        }),\n      )\n    }\n\n    let results: ValidationPromiseResult<TFormData>[] = []\n\n    const fieldsErrorMap: FormErrorMapFromValidator<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync\n    > = {}\n    if (promises.length) {\n      results = await Promise.all(promises)\n      for (const fieldValidationResult of results) {\n        if (fieldValidationResult?.fieldErrors) {\n          const { errorMapKey } = fieldValidationResult\n\n          for (const [field, fieldError] of Object.entries(\n            fieldValidationResult.fieldErrors,\n          )) {\n            const oldErrorMap =\n              fieldsErrorMap[field as DeepKeys<TFormData>] || {}\n            const newErrorMap = {\n              ...oldErrorMap,\n              [errorMapKey]: fieldError,\n            }\n            fieldsErrorMap[field as DeepKeys<TFormData>] = newErrorMap\n          }\n        }\n      }\n    }\n\n    this.baseStore.setState((prev) => ({\n      ...prev,\n      isFormValidating: false,\n    }))\n\n    return fieldsErrorMap\n  }\n\n  /**\n   * @private\n   */\n  validate = (\n    cause: ValidationCause,\n  ):\n    | FormErrorMapFromValidator<\n        TFormData,\n        TOnMount,\n        TOnChange,\n        TOnChangeAsync,\n        TOnBlur,\n        TOnBlurAsync,\n        TOnSubmit,\n        TOnSubmitAsync,\n        TOnDynamic,\n        TOnDynamicAsync\n      >\n    | Promise<\n        FormErrorMapFromValidator<\n          TFormData,\n          TOnMount,\n          TOnChange,\n          TOnChangeAsync,\n          TOnBlur,\n          TOnBlurAsync,\n          TOnSubmit,\n          TOnSubmitAsync,\n          TOnDynamic,\n          TOnDynamicAsync\n        >\n      > => {\n    // Attempt to sync validate first\n    const { hasErrored, fieldsErrorMap } = this.validateSync(cause)\n\n    if (hasErrored && !this.options.asyncAlways) {\n      return fieldsErrorMap\n    }\n\n    // No error? Attempt async validation\n    return this.validateAsync(cause)\n  }\n\n  // Needs to edgecase in the React adapter specifically to avoid type errors\n  handleSubmit(): Promise<void>\n  handleSubmit(submitMeta: TSubmitMeta): Promise<void>\n  handleSubmit(submitMeta?: TSubmitMeta): Promise<void> {\n    return this._handleSubmit(submitMeta)\n  }\n\n  /**\n   * Handles the form submission, performs validation, and calls the appropriate onSubmit or onSubmitInvalid callbacks.\n   */\n  _handleSubmit = async (submitMeta?: TSubmitMeta): Promise<void> => {\n    this.baseStore.setState((old) => ({\n      ...old,\n      // Submission attempts mark the form as not submitted\n      isSubmitted: false,\n      // Count submission attempts\n      submissionAttempts: old.submissionAttempts + 1,\n      isSubmitSuccessful: false, // Reset isSubmitSuccessful at the start of submission\n    }))\n\n    batch(() => {\n      void (Object.values(this.fieldInfo) as FieldInfo<any>[]).forEach(\n        (field) => {\n          if (!field.instance) return\n          // If any fields are not touched\n          if (!field.instance.state.meta.isTouched) {\n            // Mark them as touched\n            field.instance.setMeta((prev) => ({ ...prev, isTouched: true }))\n          }\n        },\n      )\n    })\n\n    const submitMetaArg =\n      submitMeta ?? (this.options.onSubmitMeta as TSubmitMeta)\n\n    if (!this.state.canSubmit && !this._devtoolsSubmissionOverride) {\n      this.options.onSubmitInvalid?.({\n        value: this.state.values,\n        formApi: this,\n        meta: submitMetaArg,\n      })\n      return\n    }\n\n    this.baseStore.setState((d) => ({ ...d, isSubmitting: true }))\n\n    const done = () => {\n      this.baseStore.setState((prev) => ({ ...prev, isSubmitting: false }))\n    }\n\n    await this.validateAllFields('submit')\n\n    if (!this.state.isFieldsValid) {\n      done()\n\n      this.options.onSubmitInvalid?.({\n        value: this.state.values,\n        formApi: this,\n        meta: submitMetaArg,\n      })\n\n      formEventClient.emit('form-submission', {\n        id: this._formId,\n        submissionAttempt: this.state.submissionAttempts,\n        successful: false,\n        stage: 'validateAllFields',\n        errors: (Object.values(this.state.fieldMeta) as AnyFieldMeta[])\n          .map((meta: AnyFieldMeta) => meta.errors)\n          .flat(),\n      })\n      return\n    }\n\n    await this.validate('submit')\n\n    // Fields are invalid, do not submit\n    if (!this.state.isValid) {\n      done()\n\n      this.options.onSubmitInvalid?.({\n        value: this.state.values,\n        formApi: this,\n        meta: submitMetaArg,\n      })\n\n      formEventClient.emit('form-submission', {\n        id: this._formId,\n        submissionAttempt: this.state.submissionAttempts,\n        successful: false,\n        stage: 'validate',\n        errors: this.state.errors,\n      })\n\n      return\n    }\n\n    batch(() => {\n      void (Object.values(this.fieldInfo) as FieldInfo<TFormData>[]).forEach(\n        (field) => {\n          field.instance?.options.listeners?.onSubmit?.({\n            value: field.instance.state.value,\n            fieldApi: field.instance,\n          })\n        },\n      )\n    })\n\n    this.options.listeners?.onSubmit?.({ formApi: this, meta: submitMetaArg })\n\n    try {\n      // Run the submit code\n      await this.options.onSubmit?.({\n        value: this.state.values,\n        formApi: this,\n        meta: submitMetaArg,\n      })\n\n      batch(() => {\n        this.baseStore.setState((prev) => ({\n          ...prev,\n          isSubmitted: true,\n          isSubmitSuccessful: true, // Set isSubmitSuccessful to true on successful submission\n        }))\n\n        formEventClient.emit('form-submission', {\n          id: this._formId,\n          submissionAttempt: this.state.submissionAttempts,\n          successful: true,\n        })\n\n        done()\n      })\n    } catch (err) {\n      this.baseStore.setState((prev) => ({\n        ...prev,\n        isSubmitSuccessful: false, // Ensure isSubmitSuccessful is false if an error occurs\n      }))\n\n      formEventClient.emit('form-submission', {\n        id: this._formId,\n        submissionAttempt: this.state.submissionAttempts,\n        successful: false,\n        stage: 'inflight',\n        onError: err,\n      })\n\n      done()\n\n      throw err\n    }\n  }\n\n  /**\n   * Gets the value of the specified field.\n   */\n  getFieldValue = <TField extends DeepKeys<TFormData>>(\n    field: TField,\n  ): DeepValue<TFormData, TField> => getBy(this.state.values, field)\n\n  /**\n   * Gets the metadata of the specified field.\n   */\n  getFieldMeta = <TField extends DeepKeys<TFormData>>(\n    field: TField,\n  ): AnyFieldMeta | undefined => {\n    return this.state.fieldMeta[field]\n  }\n\n  /**\n   * Gets the field info of the specified field.\n   */\n  getFieldInfo = <TField extends DeepKeys<TFormData>>(\n    field: TField,\n  ): FieldInfo<TFormData> => {\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    return (this.fieldInfo[field] ||= {\n      instance: null,\n      validationMetaMap: {\n        onChange: undefined,\n        onBlur: undefined,\n        onSubmit: undefined,\n        onMount: undefined,\n        onServer: undefined,\n        onDynamic: undefined,\n      },\n    })\n  }\n\n  /**\n   * Updates the metadata of the specified field.\n   */\n  setFieldMeta = <TField extends DeepKeys<TFormData>>(\n    field: TField,\n    updater: Updater<AnyFieldMetaBase>,\n  ) => {\n    this.baseStore.setState((prev) => {\n      return {\n        ...prev,\n        fieldMetaBase: {\n          ...prev.fieldMetaBase,\n          [field]: functionalUpdate(\n            updater,\n            prev.fieldMetaBase[field] as never,\n          ),\n        },\n      }\n    })\n  }\n\n  /**\n   * resets every field's meta\n   */\n  resetFieldMeta = <TField extends DeepKeys<TFormData>>(\n    fieldMeta: Partial<Record<TField, AnyFieldMeta>>,\n  ): Partial<Record<TField, AnyFieldMeta>> => {\n    return Object.keys(fieldMeta).reduce(\n      (acc, key) => {\n        const fieldKey = key as TField\n        acc[fieldKey] = defaultFieldMeta\n        return acc\n      },\n      {} as Partial<Record<TField, AnyFieldMeta>>,\n    )\n  }\n\n  /**\n   * Sets the value of the specified field and optionally updates the touched state.\n   */\n  setFieldValue = <TField extends DeepKeys<TFormData>>(\n    field: TField,\n    updater: Updater<DeepValue<TFormData, TField>>,\n    opts?: UpdateMetaOptions,\n  ) => {\n    const dontUpdateMeta = opts?.dontUpdateMeta ?? false\n    const dontRunListeners = opts?.dontRunListeners ?? false\n    const dontValidate = opts?.dontValidate ?? false\n\n    batch(() => {\n      if (!dontUpdateMeta) {\n        this.setFieldMeta(field, (prev) => ({\n          ...prev,\n          isTouched: true,\n          isDirty: true,\n          errorMap: {\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            ...prev?.errorMap,\n            onMount: undefined,\n          },\n        }))\n      }\n\n      this.baseStore.setState((prev) => {\n        return {\n          ...prev,\n          values: setBy(prev.values, field, updater),\n        }\n      })\n    })\n\n    if (!dontRunListeners) {\n      this.getFieldInfo(field).instance?.triggerOnChangeListener()\n    }\n\n    if (!dontValidate) {\n      this.validateField(field, 'change')\n    }\n  }\n\n  deleteField = <TField extends DeepKeys<TFormData>>(field: TField) => {\n    const subFieldsToDelete = Object.keys(this.fieldInfo).filter((f) => {\n      const fieldStr = field.toString()\n      return f !== fieldStr && f.startsWith(fieldStr)\n    })\n\n    const fieldsToDelete = [...subFieldsToDelete, field]\n\n    // Cleanup the last fields\n    this.baseStore.setState((prev) => {\n      const newState = { ...prev }\n      fieldsToDelete.forEach((f) => {\n        newState.values = deleteBy(newState.values, f)\n        delete this.fieldInfo[f as never]\n        delete newState.fieldMetaBase[f as never]\n      })\n\n      return newState\n    })\n  }\n\n  /**\n   * Pushes a value into an array field.\n   */\n  pushFieldValue = <TField extends DeepKeysOfType<TFormData, any[]>>(\n    field: TField,\n    value: DeepValue<TFormData, TField> extends any[]\n      ? DeepValue<TFormData, TField>[number]\n      : never,\n    options?: UpdateMetaOptions,\n  ) => {\n    this.setFieldValue(\n      field,\n      (prev) => [...(Array.isArray(prev) ? prev : []), value] as any,\n      options,\n    )\n  }\n\n  insertFieldValue = async <TField extends DeepKeysOfType<TFormData, any[]>>(\n    field: TField,\n    index: number,\n    value: DeepValue<TFormData, TField> extends any[]\n      ? DeepValue<TFormData, TField>[number]\n      : never,\n    options?: UpdateMetaOptions,\n  ) => {\n    this.setFieldValue(\n      field,\n      (prev) => {\n        return [\n          ...(prev as DeepValue<TFormData, TField>[]).slice(0, index),\n          value,\n          ...(prev as DeepValue<TFormData, TField>[]).slice(index),\n        ] as any\n      },\n      mergeOpts(options, { dontValidate: true }),\n    )\n\n    const dontValidate = options?.dontValidate ?? false\n    if (!dontValidate) {\n      // Validate the whole array + all fields that have shifted\n      await this.validateField(field, 'change')\n    }\n\n    // Shift down all meta after validating to make sure the new field has been mounted\n    metaHelper(this).handleArrayInsert(field, index)\n\n    if (!dontValidate) {\n      await this.validateArrayFieldsStartingFrom(field, index, 'change')\n    }\n  }\n\n  /**\n   * Replaces a value into an array field at the specified index.\n   */\n  replaceFieldValue = async <TField extends DeepKeysOfType<TFormData, any[]>>(\n    field: TField,\n    index: number,\n    value: DeepValue<TFormData, TField> extends any[]\n      ? DeepValue<TFormData, TField>[number]\n      : never,\n    options?: UpdateMetaOptions,\n  ) => {\n    this.setFieldValue(\n      field,\n      (prev) => {\n        return (prev as DeepValue<TFormData, TField>[]).map((d, i) =>\n          i === index ? value : d,\n        ) as any\n      },\n      mergeOpts(options, { dontValidate: true }),\n    )\n\n    const dontValidate = options?.dontValidate ?? false\n    if (!dontValidate) {\n      // Validate the whole array + all fields that have shifted\n      await this.validateField(field, 'change')\n      await this.validateArrayFieldsStartingFrom(field, index, 'change')\n    }\n  }\n\n  /**\n   * Removes a value from an array field at the specified index.\n   */\n  removeFieldValue = async <TField extends DeepKeysOfType<TFormData, any[]>>(\n    field: TField,\n    index: number,\n    options?: UpdateMetaOptions,\n  ) => {\n    const fieldValue = this.getFieldValue(field)\n\n    const lastIndex = Array.isArray(fieldValue)\n      ? Math.max((fieldValue as Array<unknown>).length - 1, 0)\n      : null\n\n    this.setFieldValue(\n      field,\n      (prev) => {\n        return (prev as DeepValue<TFormData, TField>[]).filter(\n          (_d, i) => i !== index,\n        ) as any\n      },\n      mergeOpts(options, { dontValidate: true }),\n    )\n\n    // Shift up all meta\n    metaHelper(this).handleArrayRemove(field, index)\n\n    if (lastIndex !== null) {\n      const start = `${field}[${lastIndex}]`\n      this.deleteField(start as never)\n    }\n\n    const dontValidate = options?.dontValidate ?? false\n    if (!dontValidate) {\n      // Validate the whole array + all fields that have shifted\n      await this.validateField(field, 'change')\n      await this.validateArrayFieldsStartingFrom(field, index, 'change')\n    }\n  }\n\n  /**\n   * Swaps the values at the specified indices within an array field.\n   */\n  swapFieldValues = <TField extends DeepKeysOfType<TFormData, any[]>>(\n    field: TField,\n    index1: number,\n    index2: number,\n    options?: UpdateMetaOptions,\n  ) => {\n    this.setFieldValue(\n      field,\n      (prev: any) => {\n        const prev1 = prev[index1]!\n        const prev2 = prev[index2]!\n        return setBy(setBy(prev, `${index1}`, prev2), `${index2}`, prev1)\n      },\n      mergeOpts(options, { dontValidate: true }),\n    )\n\n    // Swap meta\n    metaHelper(this).handleArraySwap(field, index1, index2)\n\n    const dontValidate = options?.dontValidate ?? false\n    if (!dontValidate) {\n      // Validate the whole array\n      this.validateField(field, 'change')\n      // Validate the swapped fields\n      this.validateField(`${field}[${index1}]` as DeepKeys<TFormData>, 'change')\n      this.validateField(`${field}[${index2}]` as DeepKeys<TFormData>, 'change')\n    }\n  }\n\n  /**\n   * Moves the value at the first specified index to the second specified index within an array field.\n   */\n  moveFieldValues = <TField extends DeepKeysOfType<TFormData, any[]>>(\n    field: TField,\n    index1: number,\n    index2: number,\n    options?: UpdateMetaOptions,\n  ) => {\n    this.setFieldValue(\n      field,\n      (prev: any) => {\n        const next: any = [...prev]\n        next.splice(index2, 0, next.splice(index1, 1)[0])\n        return next\n      },\n      mergeOpts(options, { dontValidate: true }),\n    )\n\n    // Move meta between index1 and index2\n    metaHelper(this).handleArrayMove(field, index1, index2)\n\n    const dontValidate = options?.dontValidate ?? false\n    if (!dontValidate) {\n      // Validate the whole array\n      this.validateField(field, 'change')\n      // Validate the moved fields\n      this.validateField(`${field}[${index1}]` as DeepKeys<TFormData>, 'change')\n      this.validateField(`${field}[${index2}]` as DeepKeys<TFormData>, 'change')\n    }\n  }\n\n  /**\n   * Clear all values within an array field.\n   */\n  clearFieldValues = <TField extends DeepKeysOfType<TFormData, any[]>>(\n    field: TField,\n    options?: UpdateMetaOptions,\n  ) => {\n    const fieldValue = this.getFieldValue(field)\n\n    const lastIndex = Array.isArray(fieldValue)\n      ? Math.max((fieldValue as unknown[]).length - 1, 0)\n      : null\n\n    this.setFieldValue(\n      field,\n      [] as any,\n      mergeOpts(options, { dontValidate: true }),\n    )\n\n    if (lastIndex !== null) {\n      for (let i = 0; i <= lastIndex; i++) {\n        const fieldKey = `${field}[${i}]`\n        this.deleteField(fieldKey as never)\n      }\n    }\n\n    const dontValidate = options?.dontValidate ?? false\n    if (!dontValidate) {\n      // validate array change\n      this.validateField(field, 'change')\n    }\n  }\n\n  /**\n   * Resets the field value and meta to default state\n   */\n  resetField = <TField extends DeepKeys<TFormData>>(field: TField) => {\n    this.baseStore.setState((prev) => {\n      return {\n        ...prev,\n        fieldMetaBase: {\n          ...prev.fieldMetaBase,\n          [field]: defaultFieldMeta,\n        },\n        values: this.options.defaultValues\n          ? setBy(prev.values, field, getBy(this.options.defaultValues, field))\n          : prev.values,\n      }\n    })\n  }\n\n  /**\n   * Updates the form's errorMap\n   */\n  setErrorMap = (\n    errorMap: FormValidationErrorMap<\n      TFormData,\n      UnwrapFormValidateOrFn<TOnMount>,\n      UnwrapFormValidateOrFn<TOnChange>,\n      UnwrapFormAsyncValidateOrFn<TOnChangeAsync>,\n      UnwrapFormValidateOrFn<TOnBlur>,\n      UnwrapFormAsyncValidateOrFn<TOnBlurAsync>,\n      UnwrapFormValidateOrFn<TOnSubmit>,\n      UnwrapFormAsyncValidateOrFn<TOnSubmitAsync>,\n      UnwrapFormValidateOrFn<TOnDynamic>,\n      UnwrapFormAsyncValidateOrFn<TOnDynamicAsync>,\n      UnwrapFormAsyncValidateOrFn<TOnServer>\n    >,\n  ) => {\n    batch(() => {\n      Object.entries(errorMap).forEach(([key, value]) => {\n        const errorMapKey = key as ValidationErrorMapKeys\n\n        if (isGlobalFormValidationError(value)) {\n          const { formError, fieldErrors } = normalizeError<TFormData>(value)\n\n          for (const fieldName of Object.keys(\n            this.fieldInfo,\n          ) as DeepKeys<TFormData>[]) {\n            const fieldMeta = this.getFieldMeta(fieldName)\n            if (!fieldMeta) continue\n\n            this.setFieldMeta(fieldName, (prev) => ({\n              ...prev,\n              errorMap: {\n                ...prev.errorMap,\n                [errorMapKey]: fieldErrors?.[fieldName],\n              },\n              errorSourceMap: {\n                ...prev.errorSourceMap,\n                [errorMapKey]: 'form',\n              },\n            }))\n          }\n\n          this.baseStore.setState((prev) => ({\n            ...prev,\n            errorMap: {\n              ...prev.errorMap,\n              [errorMapKey]: formError,\n            },\n          }))\n        } else {\n          this.baseStore.setState((prev) => ({\n            ...prev,\n            errorMap: {\n              ...prev.errorMap,\n              [errorMapKey]: value,\n            },\n          }))\n        }\n      })\n    })\n  }\n\n  /**\n   * Returns form and field level errors\n   */\n  getAllErrors = (): {\n    form: {\n      errors: Array<\n        | UnwrapFormValidateOrFn<TOnMount>\n        | UnwrapFormValidateOrFn<TOnChange>\n        | UnwrapFormAsyncValidateOrFn<TOnChangeAsync>\n        | UnwrapFormValidateOrFn<TOnBlur>\n        | UnwrapFormAsyncValidateOrFn<TOnBlurAsync>\n        | UnwrapFormValidateOrFn<TOnSubmit>\n        | UnwrapFormAsyncValidateOrFn<TOnSubmitAsync>\n        | UnwrapFormValidateOrFn<TOnDynamic>\n        | UnwrapFormAsyncValidateOrFn<TOnDynamicAsync>\n        | UnwrapFormAsyncValidateOrFn<TOnServer>\n      >\n      errorMap: ValidationErrorMap<\n        UnwrapFormValidateOrFn<TOnMount>,\n        UnwrapFormValidateOrFn<TOnChange>,\n        UnwrapFormAsyncValidateOrFn<TOnChangeAsync>,\n        UnwrapFormValidateOrFn<TOnBlur>,\n        UnwrapFormAsyncValidateOrFn<TOnBlurAsync>,\n        UnwrapFormValidateOrFn<TOnSubmit>,\n        UnwrapFormAsyncValidateOrFn<TOnSubmitAsync>,\n        UnwrapFormValidateOrFn<TOnDynamic>,\n        UnwrapFormAsyncValidateOrFn<TOnDynamicAsync>,\n        UnwrapFormAsyncValidateOrFn<TOnServer>\n      >\n    }\n    fields: Record<\n      DeepKeys<TFormData>,\n      { errors: ValidationError[]; errorMap: ValidationErrorMap }\n    >\n  } => {\n    return {\n      form: {\n        errors: this.state.errors,\n        errorMap: this.state.errorMap,\n      },\n      fields: Object.entries(this.state.fieldMeta).reduce(\n        (acc, [fieldName, fieldMeta]) => {\n          if (\n            Object.keys(fieldMeta as AnyFieldMeta).length &&\n            (fieldMeta as AnyFieldMeta).errors.length\n          ) {\n            acc[fieldName as DeepKeys<TFormData>] = {\n              errors: (fieldMeta as AnyFieldMeta).errors,\n              errorMap: (fieldMeta as AnyFieldMeta).errorMap,\n            }\n          }\n\n          return acc\n        },\n        {} as Record<\n          DeepKeys<TFormData>,\n          { errors: ValidationError[]; errorMap: ValidationErrorMap }\n        >,\n      ),\n    }\n  }\n\n  /**\n   * Parses the form's values with a given standard schema and returns\n   * issues (if any). This method does NOT set any internal errors.\n   * @param schema The standard schema to parse the form values with.\n   */\n  parseValuesWithSchema = (schema: StandardSchemaV1<TFormData, unknown>) => {\n    return standardSchemaValidators.validate(\n      { value: this.state.values, validationSource: 'form' },\n      schema,\n    )\n  }\n\n  /**\n   * Parses the form's values with a given standard schema and returns\n   * issues (if any). This method does NOT set any internal errors.\n   * @param schema The standard schema to parse the form values with.\n   */\n  parseValuesWithSchemaAsync = (\n    schema: StandardSchemaV1<TFormData, unknown>,\n  ) => {\n    return standardSchemaValidators.validateAsync(\n      { value: this.state.values, validationSource: 'form' },\n      schema,\n    )\n  }\n}\n\nfunction normalizeError<TFormData>(rawError?: FormValidationError<unknown>): {\n  formError: ValidationError\n  fieldErrors?: Partial<Record<DeepKeys<TFormData>, ValidationError>>\n} {\n  if (rawError) {\n    if (isGlobalFormValidationError(rawError)) {\n      const formError = normalizeError(rawError.form).formError\n      const fieldErrors = rawError.fields\n      return { formError, fieldErrors } as never\n    }\n\n    return { formError: rawError }\n  }\n\n  return { formError: undefined }\n}\n\nfunction getErrorMapKey(cause: ValidationCause) {\n  switch (cause) {\n    case 'submit':\n      return 'onSubmit'\n    case 'blur':\n      return 'onBlur'\n    case 'mount':\n      return 'onMount'\n    case 'server':\n      return 'onServer'\n    case 'dynamic':\n      return 'onDynamic'\n    case 'change':\n    default:\n      return 'onChange'\n  }\n}\n"],"names":["opts"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"FormApi.js","sources":["../../src/FormApi.ts"],"sourcesContent":["import { Derived, Store, batch } from '@tanstack/store'\nimport {\n  deleteBy,\n  determineFormLevelErrorSourceAndValue,\n  evaluate,\n  functionalUpdate,\n  getAsyncValidatorArray,\n  getBy,\n  getSyncValidatorArray,\n  isGlobalFormValidationError,\n  isNonEmptyArray,\n  mergeOpts,\n  setBy,\n  throttleFormState,\n  uuid,\n} from './utils'\nimport { defaultValidationLogic } from './ValidationLogic'\nimport {\n  isStandardSchemaValidator,\n  standardSchemaValidators,\n} from './standardSchemaValidator'\nimport { defaultFieldMeta, metaHelper } from './metaHelper'\nimport { formEventClient } from './EventClient'\n\n// types\nimport type { ValidationLogicFn } from './ValidationLogic'\nimport type {\n  StandardSchemaV1,\n  StandardSchemaV1Issue,\n  TStandardSchemaValidatorValue,\n} from './standardSchemaValidator'\nimport type {\n  AnyFieldApi,\n  AnyFieldMeta,\n  AnyFieldMetaBase,\n  FieldApi,\n} from './FieldApi'\nimport type {\n  ExtractGlobalFormError,\n  FieldManipulator,\n  FormValidationError,\n  FormValidationErrorMap,\n  ListenerCause,\n  UpdateMetaOptions,\n  ValidationCause,\n  ValidationError,\n  ValidationErrorMap,\n  ValidationErrorMapKeys,\n} from './types'\nimport type { DeepKeys, DeepKeysOfType, DeepValue } from './util-types'\nimport type { Updater } from './utils'\n\n/**\n * @private\n */\n// TODO: Add the `Unwrap` type to the errors\ntype FormErrorMapFromValidator<\n  TFormData,\n  TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnDynamic extends undefined | FormValidateOrFn<TFormData>,\n  TOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n> = Partial<\n  Record<\n    DeepKeys<TFormData>,\n    ValidationErrorMap<\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync\n    >\n  >\n>\n\nexport type FormValidateFn<TFormData> = (props: {\n  value: TFormData\n  formApi: FormApi<\n    TFormData,\n    // This is technically an edge-type; which we try to keep non-`any`, but in this case\n    // It's referring to an inaccessible type from the field validate function inner types, so it's not a big deal\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any\n  >\n}) => unknown\n\n/**\n * @private\n */\nexport type FormValidateOrFn<TFormData> =\n  | FormValidateFn<TFormData>\n  | StandardSchemaV1<TFormData, unknown>\n\nexport type UnwrapFormValidateOrFn<\n  TValidateOrFn extends undefined | FormValidateOrFn<any>,\n> = [TValidateOrFn] extends [FormValidateFn<any>]\n  ? ExtractGlobalFormError<ReturnType<TValidateOrFn>>\n  : [TValidateOrFn] extends [StandardSchemaV1<any, any>]\n    ? Record<string, StandardSchemaV1Issue[]>\n    : undefined\n\n/**\n * @private\n */\nexport type FormValidateAsyncFn<TFormData> = (props: {\n  value: TFormData\n  formApi: FormApi<\n    TFormData,\n    // This is technically an edge-type; which we try to keep non-`any`, but in this case\n    // It's referring to an inaccessible type from the field validate function inner types, so it's not a big deal\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any\n  >\n  signal: AbortSignal\n}) => unknown | Promise<unknown>\n\nexport type FormValidator<TFormData, TType, TFn = unknown> = {\n  validate(options: { value: TType }, fn: TFn): ValidationError\n  validateAsync(\n    options: { value: TType },\n    fn: TFn,\n  ): Promise<FormValidationError<TFormData>>\n}\n\ntype ValidationPromiseResult<TFormData> =\n  | {\n      fieldErrors: Partial<Record<DeepKeys<TFormData>, ValidationError>>\n      errorMapKey: ValidationErrorMapKeys\n    }\n  | undefined\n\n/**\n * @private\n */\nexport type FormAsyncValidateOrFn<TFormData> =\n  | FormValidateAsyncFn<TFormData>\n  | StandardSchemaV1<TFormData, unknown>\n\nexport type UnwrapFormAsyncValidateOrFn<\n  TValidateOrFn extends undefined | FormAsyncValidateOrFn<any>,\n> = [TValidateOrFn] extends [FormValidateAsyncFn<any>]\n  ? ExtractGlobalFormError<Awaited<ReturnType<TValidateOrFn>>>\n  : [TValidateOrFn] extends [StandardSchemaV1<any, any>]\n    ? Record<string, StandardSchemaV1Issue[]>\n    : undefined\n\nexport interface FormValidators<\n  TFormData,\n  TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnDynamic extends undefined | FormValidateOrFn<TFormData>,\n  TOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n> {\n  /**\n   * Optional function that fires as soon as the component mounts.\n   */\n  onMount?: TOnMount\n  /**\n   * Optional function that checks the validity of your data whenever a value changes\n   */\n  onChange?: TOnChange\n  /**\n   * Optional onChange asynchronous counterpart to onChange. Useful for more complex validation logic that might involve server requests.\n   */\n  onChangeAsync?: TOnChangeAsync\n  /**\n   * The default time in milliseconds that if set to a number larger than 0, will debounce the async validation event by this length of time in milliseconds.\n   */\n  onChangeAsyncDebounceMs?: number\n  /**\n   * Optional function that validates the form data when a field loses focus, returns a `FormValidationError`\n   */\n  onBlur?: TOnBlur\n  /**\n   * Optional onBlur asynchronous validation method for when a field loses focus returns a ` FormValidationError` or a promise of `Promise<FormValidationError>`\n   */\n  onBlurAsync?: TOnBlurAsync\n  /**\n   * The default time in milliseconds that if set to a number larger than 0, will debounce the async validation event by this length of time in milliseconds.\n   */\n  onBlurAsyncDebounceMs?: number\n  onSubmit?: TOnSubmit\n  onSubmitAsync?: TOnSubmitAsync\n  onDynamic?: TOnDynamic\n  onDynamicAsync?: TOnDynamicAsync\n  onDynamicAsyncDebounceMs?: number\n}\n\n/**\n * @private\n */\nexport interface FormTransform<\n  TFormData,\n  TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnDynamic extends undefined | FormValidateOrFn<TFormData>,\n  TOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnServer extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TSubmitMeta = never,\n> {\n  fn: (\n    formBase: FormApi<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer,\n      TSubmitMeta\n    >,\n  ) => FormApi<\n    TFormData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TOnDynamic,\n    TOnDynamicAsync,\n    TOnServer,\n    TSubmitMeta\n  >\n  deps: unknown[]\n}\n\nexport interface FormListeners<\n  TFormData,\n  TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnDynamic extends undefined | FormValidateOrFn<TFormData>,\n  TOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnServer extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TSubmitMeta = never,\n> {\n  onChange?: (props: {\n    formApi: FormApi<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer,\n      TSubmitMeta\n    >\n    fieldApi: AnyFieldApi\n  }) => void\n  onChangeDebounceMs?: number\n\n  onBlur?: (props: {\n    formApi: FormApi<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer,\n      TSubmitMeta\n    >\n    fieldApi: AnyFieldApi\n  }) => void\n  onBlurDebounceMs?: number\n\n  onMount?: (props: {\n    formApi: FormApi<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer,\n      TSubmitMeta\n    >\n  }) => void\n\n  onSubmit?: (props: {\n    formApi: FormApi<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer,\n      TSubmitMeta\n    >\n    meta: TSubmitMeta\n  }) => void\n}\n\n/**\n * An object representing the base properties of a form, unrelated to any validators\n */\nexport interface BaseFormOptions<in out TFormData, in out TSubmitMeta = never> {\n  /**\n   * Set initial values for your form.\n   */\n  defaultValues?: TFormData\n  /**\n   * onSubmitMeta, the data passed from the handleSubmit handler, to the onSubmit function props\n   */\n  onSubmitMeta?: TSubmitMeta\n}\n\n/**\n * An object representing the options for a form.\n */\nexport interface FormOptions<\n  in out TFormData,\n  in out TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnDynamic extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnServer extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TSubmitMeta = never,\n> extends BaseFormOptions<TFormData, TSubmitMeta> {\n  /**\n   * The form name, used for devtools and identification\n   */\n  formId?: string\n  /**\n   * The default state for the form.\n   */\n  defaultState?: Partial<\n    FormState<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer\n    >\n  >\n  /**\n   * If true, always run async validation, even when sync validation has produced an error. Defaults to undefined.\n   */\n  asyncAlways?: boolean\n  /**\n   * Optional time in milliseconds if you want to introduce a delay before firing off an async action.\n   */\n  asyncDebounceMs?: number\n  /**\n   * If true, allows the form to be submitted in an invalid state i.e. canSubmit will remain true regardless of validation errors. Defaults to undefined.\n   */\n  canSubmitWhenInvalid?: boolean\n  /**\n   * A list of validators to pass to the form\n   */\n  validators?: FormValidators<\n    TFormData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TOnDynamic,\n    TOnDynamicAsync\n  >\n\n  validationLogic?: ValidationLogicFn\n\n  /**\n   * form level listeners\n   */\n  listeners?: FormListeners<\n    TFormData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TOnDynamic,\n    TOnDynamicAsync,\n    TOnServer,\n    TSubmitMeta\n  >\n\n  /**\n   * A function to be called when the form is submitted, what should happen once the user submits a valid form returns `any` or a promise `Promise<any>`\n   */\n  onSubmit?: (props: {\n    value: TFormData\n    formApi: FormApi<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer,\n      TSubmitMeta\n    >\n    meta: TSubmitMeta\n  }) => any | Promise<any>\n  /**\n   * Specify an action for scenarios where the user tries to submit an invalid form.\n   */\n  onSubmitInvalid?: (props: {\n    value: TFormData\n    formApi: FormApi<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer,\n      TSubmitMeta\n    >\n    meta: TSubmitMeta\n  }) => void\n  transform?: FormTransform<\n    NoInfer<TFormData>,\n    NoInfer<TOnMount>,\n    NoInfer<TOnChange>,\n    NoInfer<TOnChangeAsync>,\n    NoInfer<TOnBlur>,\n    NoInfer<TOnBlurAsync>,\n    NoInfer<TOnSubmit>,\n    NoInfer<TOnSubmitAsync>,\n    NoInfer<TOnDynamic>,\n    NoInfer<TOnDynamicAsync>,\n    NoInfer<TOnServer>,\n    NoInfer<TSubmitMeta>\n  >\n}\n\nexport type AnyFormOptions = FormOptions<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any\n>\n\n/**\n * An object representing the validation metadata for a field. Not intended for public usage.\n */\nexport type ValidationMeta = {\n  /**\n   * An abort controller stored in memory to cancel previous async validation attempts.\n   */\n  lastAbortController: AbortController\n}\n\n/**\n * An object representing the field information for a specific field within the form.\n */\nexport type FieldInfo<TFormData> = {\n  /**\n   * An instance of the FieldAPI.\n   */\n  instance: FieldApi<\n    TFormData,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any\n  > | null\n  /**\n   * A record of field validation internal handling.\n   */\n  validationMetaMap: Record<ValidationErrorMapKeys, ValidationMeta | undefined>\n}\n\n/**\n * An object representing the current state of the form.\n */\nexport type BaseFormState<\n  in out TFormData,\n  in out TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnDynamic extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnServer extends undefined | FormAsyncValidateOrFn<TFormData>,\n> = {\n  /**\n   * The current values of the form fields.\n   */\n  values: TFormData\n  /**\n   * The error map for the form itself.\n   */\n  errorMap: ValidationErrorMap<\n    UnwrapFormValidateOrFn<TOnMount>,\n    UnwrapFormValidateOrFn<TOnChange>,\n    UnwrapFormAsyncValidateOrFn<TOnChangeAsync>,\n    UnwrapFormValidateOrFn<TOnBlur>,\n    UnwrapFormAsyncValidateOrFn<TOnBlurAsync>,\n    UnwrapFormValidateOrFn<TOnSubmit>,\n    UnwrapFormAsyncValidateOrFn<TOnSubmitAsync>,\n    UnwrapFormValidateOrFn<TOnDynamic>,\n    UnwrapFormAsyncValidateOrFn<TOnDynamicAsync>,\n    UnwrapFormAsyncValidateOrFn<TOnServer>\n  >\n  /**\n   * An internal mechanism used for keeping track of validation logic in a form.\n   */\n  validationMetaMap: Record<ValidationErrorMapKeys, ValidationMeta | undefined>\n  /**\n   * A record of field metadata for each field in the form, not including the derived properties, like `errors` and such\n   */\n  fieldMetaBase: Partial<Record<DeepKeys<TFormData>, AnyFieldMetaBase>>\n  /**\n   * A boolean indicating if the form is currently in the process of being submitted after `handleSubmit` is called.\n   *\n   * Goes back to `false` when submission completes for one of the following reasons:\n   * - the validation step returned errors.\n   * - the `onSubmit` function has completed.\n   *\n   * Note: if you're running async operations in your `onSubmit` function make sure to await them to ensure `isSubmitting` is set to `false` only when the async operation completes.\n   *\n   * This is useful for displaying loading indicators or disabling form inputs during submission.\n   *\n   */\n  isSubmitting: boolean\n  /**\n   * A boolean indicating if the `onSubmit` function has completed successfully.\n   *\n   * Goes back to `false` at each new submission attempt.\n   *\n   * Note: you can use isSubmitting to check if the form is currently submitting.\n   */\n  isSubmitted: boolean\n  /**\n   * A boolean indicating if the form or any of its fields are currently validating.\n   */\n  isValidating: boolean\n  /**\n   * A counter for tracking the number of submission attempts.\n   */\n  submissionAttempts: number\n  /**\n   * A boolean indicating if the last submission was successful.\n   */\n  isSubmitSuccessful: boolean\n  /**\n   * @private, used to force a re-evaluation of the form state when options change\n   */\n  _force_re_eval?: boolean\n}\n\nexport type DerivedFormState<\n  in out TFormData,\n  in out TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnDynamic extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnServer extends undefined | FormAsyncValidateOrFn<TFormData>,\n> = {\n  /**\n   * A boolean indicating if the form is currently validating.\n   */\n  isFormValidating: boolean\n  /**\n   * A boolean indicating if the form is valid.\n   */\n  isFormValid: boolean\n  /**\n   * The error array for the form itself.\n   */\n  errors: Array<\n    | UnwrapFormValidateOrFn<TOnMount>\n    | UnwrapFormValidateOrFn<TOnChange>\n    | UnwrapFormAsyncValidateOrFn<TOnChangeAsync>\n    | UnwrapFormValidateOrFn<TOnBlur>\n    | UnwrapFormAsyncValidateOrFn<TOnBlurAsync>\n    | UnwrapFormValidateOrFn<TOnSubmit>\n    | UnwrapFormAsyncValidateOrFn<TOnSubmitAsync>\n    | UnwrapFormValidateOrFn<TOnDynamic>\n    | UnwrapFormAsyncValidateOrFn<TOnDynamicAsync>\n    | UnwrapFormAsyncValidateOrFn<TOnServer>\n  >\n  /**\n   * A boolean indicating if any of the form fields are currently validating.\n   */\n  isFieldsValidating: boolean\n  /**\n   * A boolean indicating if all the form fields are valid. Evaluates `true` if there are no field errors.\n   */\n  isFieldsValid: boolean\n  /**\n   * A boolean indicating if any of the form fields have been touched.\n   */\n  isTouched: boolean\n  /**\n   * A boolean indicating if any of the form fields have been blurred.\n   */\n  isBlurred: boolean\n  /**\n   * A boolean indicating if any of the form's fields' values have been modified by the user. Evaluates `true` if the user have modified at least one of the fields. Opposite of `isPristine`.\n   */\n  isDirty: boolean\n  /**\n   * A boolean indicating if none of the form's fields' values have been modified by the user. Evaluates `true` if the user have not modified any of the fields. Opposite of `isDirty`.\n   */\n  isPristine: boolean\n  /**\n   * A boolean indicating if all of the form's fields are the same as default values.\n   */\n  isDefaultValue: boolean\n  /**\n   * A boolean indicating if the form and all its fields are valid. Evaluates `true` if there are no errors.\n   */\n  isValid: boolean\n  /**\n   * A boolean indicating if the form can be submitted based on its current state.\n   */\n  canSubmit: boolean\n  /**\n   * A record of field metadata for each field in the form.\n   */\n  fieldMeta: Partial<Record<DeepKeys<TFormData>, AnyFieldMeta>>\n}\n\nexport interface FormState<\n  in out TFormData,\n  in out TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnDynamic extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnServer extends undefined | FormAsyncValidateOrFn<TFormData>,\n>\n  extends\n    BaseFormState<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer\n    >,\n    DerivedFormState<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer\n    > {}\n\nexport type AnyFormState = FormState<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any\n>\n\nfunction getDefaultFormState<\n  TFormData,\n  TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnDynamic extends undefined | FormValidateOrFn<TFormData>,\n  TOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  TOnServer extends undefined | FormAsyncValidateOrFn<TFormData>,\n>(\n  defaultState: Partial<\n    FormState<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer\n    >\n  >,\n): BaseFormState<\n  TFormData,\n  TOnMount,\n  TOnChange,\n  TOnChangeAsync,\n  TOnBlur,\n  TOnBlurAsync,\n  TOnSubmit,\n  TOnSubmitAsync,\n  TOnDynamic,\n  TOnDynamicAsync,\n  TOnServer\n> {\n  return {\n    values: defaultState.values ?? ({} as never),\n    errorMap: defaultState.errorMap ?? {},\n    fieldMetaBase: defaultState.fieldMetaBase ?? ({} as never),\n    isSubmitted: defaultState.isSubmitted ?? false,\n    isSubmitting: defaultState.isSubmitting ?? false,\n    isValidating: defaultState.isValidating ?? false,\n    submissionAttempts: defaultState.submissionAttempts ?? 0,\n    isSubmitSuccessful: defaultState.isSubmitSuccessful ?? false,\n    validationMetaMap: defaultState.validationMetaMap ?? {\n      onChange: undefined,\n      onBlur: undefined,\n      onSubmit: undefined,\n      onMount: undefined,\n      onServer: undefined,\n      onDynamic: undefined,\n    },\n  }\n}\n\n/**\n * @public\n *\n * A type representing the Form API with all generics set to `any` for convenience.\n */\nexport type AnyFormApi = FormApi<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any\n>\n\n/**\n * We cannot use methods and must use arrow functions. Otherwise, our React adapters\n * will break due to loss of the method when using spread.\n */\n\n/**\n * A class representing the Form API. It handles the logic and interactions with the form state.\n *\n * Normally, you will not need to create a new `FormApi` instance directly. Instead, you will use a framework\n * hook/function like `useForm` or `createForm` to create a new instance for you that uses your framework's reactivity model.\n * However, if you need to create a new instance manually, you can do so by calling the `new FormApi` constructor.\n */\nexport class FormApi<\n  in out TFormData,\n  in out TOnMount extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnChange extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnChangeAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnBlur extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnBlurAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnSubmit extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnSubmitAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnDynamic extends undefined | FormValidateOrFn<TFormData>,\n  in out TOnDynamicAsync extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TOnServer extends undefined | FormAsyncValidateOrFn<TFormData>,\n  in out TSubmitMeta = never,\n> implements FieldManipulator<TFormData, TSubmitMeta> {\n  /**\n   * The options for the form.\n   */\n  options: FormOptions<\n    TFormData,\n    TOnMount,\n    TOnChange,\n    TOnChangeAsync,\n    TOnBlur,\n    TOnBlurAsync,\n    TOnSubmit,\n    TOnSubmitAsync,\n    TOnDynamic,\n    TOnDynamicAsync,\n    TOnServer,\n    TSubmitMeta\n  > = {}\n  baseStore!: Store<\n    BaseFormState<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer\n    >\n  >\n  fieldMetaDerived: Derived<\n    FormState<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer\n    >['fieldMeta']\n  >\n  store: Derived<\n    FormState<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer\n    >\n  >\n  /**\n   * A record of field information for each field in the form.\n   */\n  fieldInfo: Record<DeepKeys<TFormData>, FieldInfo<TFormData>> = {} as any\n\n  get state() {\n    return this.store.state\n  }\n\n  /**\n   * @private\n   */\n  prevTransformArray: unknown[] = []\n\n  /**\n   * @private\n   */\n  timeoutIds: {\n    validations: Record<ValidationCause, ReturnType<typeof setTimeout> | null>\n    listeners: Record<ListenerCause, ReturnType<typeof setTimeout> | null>\n    formListeners: Record<ListenerCause, ReturnType<typeof setTimeout> | null>\n  }\n  /**\n   * @private\n   */\n  _formId: string\n  /**\n   * @private\n   */\n  private _devtoolsSubmissionOverride: boolean\n\n  /**\n   * Constructs a new `FormApi` instance with the given form options.\n   */\n  constructor(\n    opts?: FormOptions<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer,\n      TSubmitMeta\n    >,\n  ) {\n    this.timeoutIds = {\n      validations: {} as Record<ValidationCause, never>,\n      listeners: {} as Record<ListenerCause, never>,\n      formListeners: {} as Record<ListenerCause, never>,\n    }\n\n    this._formId = opts?.formId ?? uuid()\n\n    this._devtoolsSubmissionOverride = false\n\n    this.baseStore = new Store(\n      getDefaultFormState({\n        ...(opts?.defaultState as any),\n        values: opts?.defaultValues ?? opts?.defaultState?.values,\n        isFormValid: true,\n      }),\n    )\n\n    this.fieldMetaDerived = new Derived({\n      deps: [this.baseStore],\n      fn: ({ prevDepVals, currDepVals, prevVal: _prevVal }) => {\n        const prevVal = _prevVal as\n          | Record<DeepKeys<TFormData>, AnyFieldMeta>\n          | undefined\n        const prevBaseStore = prevDepVals?.[0]\n        const currBaseStore = currDepVals[0]\n\n        let originalMetaCount = 0\n\n        const fieldMeta: FormState<\n          TFormData,\n          TOnMount,\n          TOnChange,\n          TOnChangeAsync,\n          TOnBlur,\n          TOnBlurAsync,\n          TOnSubmit,\n          TOnSubmitAsync,\n          TOnDynamic,\n          TOnDynamicAsync,\n          TOnServer\n        >['fieldMeta'] = {}\n\n        for (const fieldName of Object.keys(\n          currBaseStore.fieldMetaBase,\n        ) as Array<keyof typeof currBaseStore.fieldMetaBase>) {\n          const currBaseMeta = currBaseStore.fieldMetaBase[\n            fieldName as never\n          ] as AnyFieldMetaBase\n\n          const prevBaseMeta = prevBaseStore?.fieldMetaBase[\n            fieldName as never\n          ] as AnyFieldMetaBase | undefined\n\n          const prevFieldInfo =\n            prevVal?.[fieldName as never as keyof typeof prevVal]\n\n          const curFieldVal = getBy(currBaseStore.values, fieldName)\n\n          let fieldErrors = prevFieldInfo?.errors\n          if (\n            !prevBaseMeta ||\n            currBaseMeta.errorMap !== prevBaseMeta.errorMap\n          ) {\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            fieldErrors = Object.values(currBaseMeta.errorMap ?? {}).filter(\n              (val) => val !== undefined,\n            )\n\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            const fieldInstance = this.getFieldInfo(fieldName)?.instance\n\n            if (fieldInstance && !fieldInstance.options.disableErrorFlat) {\n              fieldErrors = fieldErrors.flat(1)\n            }\n          }\n\n          // As primitives, we don't need to aggressively persist the same referential value for performance reasons\n          const isFieldValid = !isNonEmptyArray(fieldErrors)\n          const isFieldPristine = !currBaseMeta.isDirty\n          const isDefaultValue =\n            evaluate(\n              curFieldVal,\n              getBy(this.options.defaultValues, fieldName),\n            ) ||\n            evaluate(\n              curFieldVal,\n              // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n              this.getFieldInfo(fieldName)?.instance?.options.defaultValue,\n            )\n\n          if (\n            prevFieldInfo &&\n            prevFieldInfo.isPristine === isFieldPristine &&\n            prevFieldInfo.isValid === isFieldValid &&\n            prevFieldInfo.isDefaultValue === isDefaultValue &&\n            prevFieldInfo.errors === fieldErrors &&\n            currBaseMeta === prevBaseMeta\n          ) {\n            fieldMeta[fieldName] = prevFieldInfo\n            originalMetaCount++\n            continue\n          }\n\n          fieldMeta[fieldName] = {\n            ...currBaseMeta,\n            errors: fieldErrors ?? [],\n            isPristine: isFieldPristine,\n            isValid: isFieldValid,\n            isDefaultValue: isDefaultValue,\n          } satisfies AnyFieldMeta as AnyFieldMeta\n        }\n\n        if (!Object.keys(currBaseStore.fieldMetaBase).length) return fieldMeta\n\n        if (\n          prevVal &&\n          originalMetaCount === Object.keys(currBaseStore.fieldMetaBase).length\n        ) {\n          return prevVal\n        }\n\n        return fieldMeta\n      },\n    })\n\n    this.store = new Derived({\n      deps: [this.baseStore, this.fieldMetaDerived],\n      fn: ({ prevDepVals, currDepVals, prevVal: _prevVal }) => {\n        const prevVal = _prevVal as\n          | FormState<\n              TFormData,\n              TOnMount,\n              TOnChange,\n              TOnChangeAsync,\n              TOnBlur,\n              TOnBlurAsync,\n              TOnSubmit,\n              TOnSubmitAsync,\n              TOnDynamic,\n              TOnDynamicAsync,\n              TOnServer\n            >\n          | undefined\n        const prevBaseStore = prevDepVals?.[0]\n        const currBaseStore = currDepVals[0]\n        const currFieldMeta = currDepVals[1]\n\n        // Computed state\n        const fieldMetaValues = Object.values(currFieldMeta).filter(\n          Boolean,\n        ) as AnyFieldMeta[]\n\n        const isFieldsValidating = fieldMetaValues.some(\n          (field) => field.isValidating,\n        )\n\n        const isFieldsValid = fieldMetaValues.every((field) => field.isValid)\n\n        const isTouched = fieldMetaValues.some((field) => field.isTouched)\n        const isBlurred = fieldMetaValues.some((field) => field.isBlurred)\n        const isDefaultValue = fieldMetaValues.every(\n          (field) => field.isDefaultValue,\n        )\n\n        const shouldInvalidateOnMount =\n          // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n          isTouched && currBaseStore.errorMap?.onMount\n\n        const isDirty = fieldMetaValues.some((field) => field.isDirty)\n        const isPristine = !isDirty\n\n        const hasOnMountError = Boolean(\n          // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n          currBaseStore.errorMap?.onMount ||\n          // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n          fieldMetaValues.some((f) => f?.errorMap?.onMount),\n        )\n\n        const isValidating = !!isFieldsValidating\n\n        // As `errors` is not a primitive, we need to aggressively persist the same referencial value for performance reasons\n        let errors = prevVal?.errors ?? []\n        if (\n          !prevBaseStore ||\n          currBaseStore.errorMap !== prevBaseStore.errorMap\n        ) {\n          errors = Object.values(currBaseStore.errorMap).reduce<\n            Array<\n              | UnwrapFormValidateOrFn<TOnMount>\n              | UnwrapFormValidateOrFn<TOnChange>\n              | UnwrapFormAsyncValidateOrFn<TOnChangeAsync>\n              | UnwrapFormValidateOrFn<TOnBlur>\n              | UnwrapFormAsyncValidateOrFn<TOnBlurAsync>\n              | UnwrapFormValidateOrFn<TOnSubmit>\n              | UnwrapFormAsyncValidateOrFn<TOnSubmitAsync>\n              | UnwrapFormAsyncValidateOrFn<TOnServer>\n            >\n          >((prev, curr) => {\n            if (curr === undefined) return prev\n\n            if (curr && isGlobalFormValidationError(curr)) {\n              prev.push(curr.form as never)\n              return prev\n            }\n            prev.push(curr as never)\n            return prev\n          }, [])\n        }\n\n        const isFormValid = errors.length === 0\n        const isValid = isFieldsValid && isFormValid\n        const submitInvalid = this.options.canSubmitWhenInvalid ?? false\n        const canSubmit =\n          (currBaseStore.submissionAttempts === 0 &&\n            !isTouched &&\n            !hasOnMountError) ||\n          (!isValidating && !currBaseStore.isSubmitting && isValid) ||\n          submitInvalid\n\n        let errorMap = currBaseStore.errorMap\n        if (shouldInvalidateOnMount) {\n          errors = errors.filter(\n            (err) => err !== currBaseStore.errorMap.onMount,\n          )\n          errorMap = Object.assign(errorMap, { onMount: undefined })\n        }\n\n        if (\n          prevVal &&\n          prevBaseStore &&\n          prevVal.errorMap === errorMap &&\n          prevVal.fieldMeta === this.fieldMetaDerived.state &&\n          prevVal.errors === errors &&\n          prevVal.isFieldsValidating === isFieldsValidating &&\n          prevVal.isFieldsValid === isFieldsValid &&\n          prevVal.isFormValid === isFormValid &&\n          prevVal.isValid === isValid &&\n          prevVal.canSubmit === canSubmit &&\n          prevVal.isTouched === isTouched &&\n          prevVal.isBlurred === isBlurred &&\n          prevVal.isPristine === isPristine &&\n          prevVal.isDefaultValue === isDefaultValue &&\n          prevVal.isDirty === isDirty &&\n          evaluate(prevBaseStore, currBaseStore)\n        ) {\n          return prevVal\n        }\n\n        let state = {\n          ...currBaseStore,\n          errorMap,\n          fieldMeta: this.fieldMetaDerived.state,\n          errors,\n          isFieldsValidating,\n          isFieldsValid,\n          isFormValid,\n          isValid,\n          canSubmit,\n          isTouched,\n          isBlurred,\n          isPristine,\n          isDefaultValue,\n          isDirty,\n        } as FormState<\n          TFormData,\n          TOnMount,\n          TOnChange,\n          TOnChangeAsync,\n          TOnBlur,\n          TOnBlurAsync,\n          TOnSubmit,\n          TOnSubmitAsync,\n          TOnDynamic,\n          TOnDynamicAsync,\n          TOnServer\n        >\n\n        // Only run transform if state has shallowly changed - IE how React.useEffect works\n        const transformArray = this.options.transform?.deps ?? []\n        const shouldTransform =\n          transformArray.length !== this.prevTransformArray.length ||\n          transformArray.some((val, i) => val !== this.prevTransformArray[i])\n\n        if (shouldTransform) {\n          const newObj = Object.assign({}, this, { state })\n          // This mutates the state\n          this.options.transform?.fn(newObj)\n          state = newObj.state\n          this.prevTransformArray = transformArray\n        }\n\n        return state\n      },\n    })\n\n    this.handleSubmit = this.handleSubmit.bind(this)\n\n    this.update(opts || {})\n\n    // devtool broadcasts\n    this.store.subscribe(() => {\n      throttleFormState(this)\n    })\n\n    // devtool requests\n    formEventClient.on('request-form-state', (e) => {\n      if (e.payload.id === this._formId) {\n        formEventClient.emit('form-api', {\n          id: this._formId,\n          state: this.store.state,\n          options: this.options,\n        })\n      }\n    })\n\n    formEventClient.on('request-form-reset', (e) => {\n      if (e.payload.id === this._formId) {\n        this.reset()\n      }\n    })\n\n    formEventClient.on('request-form-force-submit', (e) => {\n      if (e.payload.id === this._formId) {\n        this._devtoolsSubmissionOverride = true\n        this.handleSubmit()\n        this._devtoolsSubmissionOverride = false\n      }\n    })\n  }\n\n  get formId(): string {\n    return this._formId\n  }\n\n  /**\n   * @private\n   */\n  runValidator<\n    TValue extends TStandardSchemaValidatorValue<TFormData> & {\n      formApi: AnyFormApi\n    },\n    TType extends 'validate' | 'validateAsync',\n  >(props: {\n    validate: TType extends 'validate'\n      ? FormValidateOrFn<TFormData>\n      : FormAsyncValidateOrFn<TFormData>\n    value: TValue\n    type: TType\n  }): unknown {\n    if (isStandardSchemaValidator(props.validate)) {\n      return standardSchemaValidators[props.type](\n        props.value,\n        props.validate,\n      ) as never\n    }\n\n    return (props.validate as FormValidateFn<any>)(props.value) as never\n  }\n\n  mount = () => {\n    const cleanupFieldMetaDerived = this.fieldMetaDerived.mount()\n    const cleanupStoreDerived = this.store.mount()\n    const cleanup = () => {\n      cleanupFieldMetaDerived()\n      cleanupStoreDerived()\n\n      // broadcast form unmount for devtools\n      formEventClient.emit('form-unmounted', {\n        id: this._formId,\n      })\n    }\n\n    this.options.listeners?.onMount?.({ formApi: this })\n\n    const { onMount } = this.options.validators || {}\n\n    // broadcast form state for devtools on mounting\n    formEventClient.emit('form-api', {\n      id: this._formId,\n      state: this.store.state,\n      options: this.options,\n    })\n\n    // if no validation skip\n    if (!onMount) return cleanup\n\n    // validate\n    this.validateSync('mount')\n    return cleanup\n  }\n\n  /**\n   * Updates the form options and form state.\n   */\n  update = (\n    options?: FormOptions<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync,\n      TOnServer,\n      TSubmitMeta\n    >,\n  ) => {\n    if (!options) return\n\n    const oldOptions = this.options\n\n    // Options need to be updated first so that when the store is updated, the state is correct for the derived state\n    this.options = options\n\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    const shouldUpdateReeval = !!options.transform?.deps?.some(\n      (val, i) => val !== this.prevTransformArray[i],\n    )\n\n    const shouldUpdateValues =\n      options.defaultValues &&\n      !evaluate(options.defaultValues, oldOptions.defaultValues) &&\n      !this.state.isTouched\n\n    const shouldUpdateState =\n      !evaluate(options.defaultState, oldOptions.defaultState) &&\n      !this.state.isTouched\n\n    if (!shouldUpdateValues && !shouldUpdateState && !shouldUpdateReeval) return\n\n    batch(() => {\n      this.baseStore.setState(() =>\n        getDefaultFormState(\n          Object.assign(\n            {},\n            this.state as any,\n\n            shouldUpdateState ? options.defaultState : {},\n\n            shouldUpdateValues\n              ? {\n                  values: options.defaultValues,\n                }\n              : {},\n\n            shouldUpdateReeval\n              ? { _force_re_eval: !this.state._force_re_eval }\n              : {},\n          ),\n        ),\n      )\n    })\n\n    formEventClient.emit('form-api', {\n      id: this._formId,\n      state: this.store.state,\n      options: this.options,\n    })\n  }\n\n  /**\n   * Resets the form state to the default values.\n   * If values are provided, the form will be reset to those values instead and the default values will be updated.\n   *\n   * @param values - Optional values to reset the form to.\n   * @param opts - Optional options to control the reset behavior.\n   */\n  reset = (values?: TFormData, opts?: { keepDefaultValues?: boolean }) => {\n    const { fieldMeta: currentFieldMeta } = this.state\n    const fieldMetaBase = this.resetFieldMeta(currentFieldMeta)\n\n    if (values && !opts?.keepDefaultValues) {\n      this.options = {\n        ...this.options,\n        defaultValues: values,\n      }\n    }\n\n    this.baseStore.setState(() =>\n      getDefaultFormState({\n        ...(this.options.defaultState as any),\n        values:\n          values ??\n          this.options.defaultValues ??\n          this.options.defaultState?.values,\n        fieldMetaBase,\n      }),\n    )\n  }\n\n  /**\n   * Validates all fields using the correct handlers for a given validation cause.\n   */\n  validateAllFields = async (cause: ValidationCause) => {\n    const fieldValidationPromises: Promise<ValidationError[]>[] = [] as any\n    batch(() => {\n      void (Object.values(this.fieldInfo) as FieldInfo<any>[]).forEach(\n        (field) => {\n          if (!field.instance) return\n          const fieldInstance = field.instance\n          // Validate the field\n          fieldValidationPromises.push(\n            // Remember, `validate` is either a sync operation or a promise\n            Promise.resolve().then(() =>\n              fieldInstance.validate(cause, { skipFormValidation: true }),\n            ),\n          )\n          // If any fields are not touched\n          if (!field.instance.state.meta.isTouched) {\n            // Mark them as touched\n            field.instance.setMeta((prev) => ({ ...prev, isTouched: true }))\n          }\n        },\n      )\n    })\n\n    const fieldErrorMapMap = await Promise.all(fieldValidationPromises)\n    return fieldErrorMapMap.flat()\n  }\n\n  /**\n   * Validates the children of a specified array in the form starting from a given index until the end using the correct handlers for a given validation type.\n   */\n  validateArrayFieldsStartingFrom = async <\n    TField extends DeepKeysOfType<TFormData, any[]>,\n  >(\n    field: TField,\n    index: number,\n    cause: ValidationCause,\n  ) => {\n    const currentValue = this.getFieldValue(field)\n\n    const lastIndex = Array.isArray(currentValue)\n      ? Math.max((currentValue as Array<unknown>).length - 1, 0)\n      : null\n\n    // We have to validate all fields that have shifted (at least the current field)\n    const fieldKeysToValidate = [`${field}[${index}]`]\n    for (let i = index + 1; i <= (lastIndex ?? 0); i++) {\n      fieldKeysToValidate.push(`${field}[${i}]`)\n    }\n\n    // We also have to include all fields that are nested in the shifted fields\n    const fieldsToValidate = Object.keys(this.fieldInfo).filter((fieldKey) =>\n      fieldKeysToValidate.some((key) => fieldKey.startsWith(key)),\n    ) as DeepKeys<TFormData>[]\n\n    // Validate the fields\n    const fieldValidationPromises: Promise<ValidationError[]>[] = [] as any\n    batch(() => {\n      fieldsToValidate.forEach((nestedField) => {\n        fieldValidationPromises.push(\n          Promise.resolve().then(() => this.validateField(nestedField, cause)),\n        )\n      })\n    })\n\n    const fieldErrorMapMap = await Promise.all(fieldValidationPromises)\n    return fieldErrorMapMap.flat()\n  }\n\n  /**\n   * Validates a specified field in the form using the correct handlers for a given validation type.\n   */\n  validateField = <TField extends DeepKeys<TFormData>>(\n    field: TField,\n    cause: ValidationCause,\n  ) => {\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    const fieldInstance = this.fieldInfo[field]?.instance\n    if (!fieldInstance) return []\n\n    // If the field is not touched (same logic as in validateAllFields)\n    if (!fieldInstance.state.meta.isTouched) {\n      // Mark it as touched\n      fieldInstance.setMeta((prev) => ({ ...prev, isTouched: true }))\n    }\n\n    return fieldInstance.validate(cause)\n  }\n\n  /**\n   * TODO: This code is copied from FieldApi, we should refactor to share\n   * @private\n   */\n  validateSync = (\n    cause: ValidationCause,\n  ): {\n    hasErrored: boolean\n    fieldsErrorMap: FormErrorMapFromValidator<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync\n    >\n  } => {\n    const validates = getSyncValidatorArray(cause, {\n      ...this.options,\n      form: this,\n      validationLogic: this.options.validationLogic || defaultValidationLogic,\n    })\n\n    let hasErrored = false as boolean\n\n    // This map will only include fields that have errors in the current validation cycle\n    const currentValidationErrorMap: FormErrorMapFromValidator<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync\n    > = {}\n\n    batch(() => {\n      for (const validateObj of validates) {\n        if (!validateObj.validate) continue\n\n        const rawError = this.runValidator({\n          validate: validateObj.validate,\n          value: {\n            value: this.state.values,\n            formApi: this,\n            validationSource: 'form',\n          },\n          type: 'validate',\n        })\n\n        const { formError, fieldErrors } = normalizeError<TFormData>(rawError)\n\n        const errorMapKey = getErrorMapKey(validateObj.cause)\n\n        for (const field of Object.keys(\n          this.state.fieldMeta,\n        ) as DeepKeys<TFormData>[]) {\n          if (this.baseStore.state.fieldMetaBase[field] === undefined) {\n            continue\n          }\n\n          const fieldMeta = this.getFieldMeta(field)\n          if (!fieldMeta) continue\n\n          const {\n            errorMap: currentErrorMap,\n            errorSourceMap: currentErrorMapSource,\n          } = fieldMeta\n\n          const newFormValidatorError = fieldErrors?.[field]\n\n          const { newErrorValue, newSource } =\n            determineFormLevelErrorSourceAndValue({\n              newFormValidatorError,\n              isPreviousErrorFromFormValidator:\n                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n                currentErrorMapSource?.[errorMapKey] === 'form',\n              // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n              previousErrorValue: currentErrorMap?.[errorMapKey],\n            })\n\n          if (newSource === 'form') {\n            currentValidationErrorMap[field] = {\n              ...currentValidationErrorMap[field],\n              [errorMapKey]: newFormValidatorError,\n            }\n          }\n\n          if (\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            currentErrorMap?.[errorMapKey] !== newErrorValue\n          ) {\n            this.setFieldMeta(field, (prev) => ({\n              ...prev,\n              errorMap: {\n                ...prev.errorMap,\n                [errorMapKey]: newErrorValue,\n              },\n              errorSourceMap: {\n                ...prev.errorSourceMap,\n                [errorMapKey]: newSource,\n              },\n            }))\n          }\n        }\n\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (this.state.errorMap?.[errorMapKey] !== formError) {\n          this.baseStore.setState((prev) => ({\n            ...prev,\n            errorMap: {\n              ...prev.errorMap,\n              [errorMapKey]: formError,\n            },\n          }))\n        }\n\n        if (formError || fieldErrors) {\n          hasErrored = true\n        }\n      }\n\n      /**\n       *  when we have an error for onSubmit in the state, we want\n       *  to clear the error as soon as the user enters a valid value in the field\n       */\n      const submitErrKey = getErrorMapKey('submit')\n      if (\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        this.state.errorMap?.[submitErrKey] &&\n        cause !== 'submit' &&\n        !hasErrored\n      ) {\n        this.baseStore.setState((prev) => ({\n          ...prev,\n          errorMap: {\n            ...prev.errorMap,\n            [submitErrKey]: undefined,\n          },\n        }))\n      }\n\n      /**\n       * Clear field-level onSubmit errors when validation passes on non-submit events\n       * This fixes bug #1874 where old submit errors prevented re-validation\n       */\n      if (cause !== 'submit' && !hasErrored) {\n        for (const field of Object.keys(\n          this.state.fieldMeta,\n        ) as DeepKeys<TFormData>[]) {\n          const fieldMeta = this.getFieldMeta(field)\n          if (\n            fieldMeta &&\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            fieldMeta.errorMap?.[submitErrKey] !== undefined &&\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            fieldMeta.errorSourceMap?.[submitErrKey] === 'form'\n          ) {\n            this.setFieldMeta(field, (prev) => ({\n              ...prev,\n              errorMap: {\n                ...prev.errorMap,\n                [submitErrKey]: undefined,\n              },\n              errorSourceMap: {\n                ...prev.errorSourceMap,\n                [submitErrKey]: undefined,\n              },\n            }))\n          }\n        }\n      }\n\n      /**\n       *  when we have an error for onServer in the state, we want\n       *  to clear the error as soon as the user enters a valid value in the field\n       */\n      const serverErrKey = getErrorMapKey('server')\n      if (\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        this.state.errorMap?.[serverErrKey] &&\n        cause !== 'server' &&\n        !hasErrored\n      ) {\n        this.baseStore.setState((prev) => ({\n          ...prev,\n          errorMap: {\n            ...prev.errorMap,\n            [serverErrKey]: undefined,\n          },\n        }))\n      }\n\n      /**\n      * Clear field-level onServer errors when validation passes on non-server events\n      * This fixes bug #1874 where old server errors prevented re-validation\n      */\n      if (cause !== 'server' && !hasErrored) {\n        for (const field of Object.keys(\n          this.state.fieldMeta,\n        ) as DeepKeys<TFormData>[]) {\n          const fieldMeta = this.getFieldMeta(field)\n          if (\n            fieldMeta &&\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            fieldMeta.errorMap?.[serverErrKey] !== undefined &&\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            fieldMeta.errorSourceMap?.[serverErrKey] === 'form'\n          ) {\n            this.setFieldMeta(field, (prev) => ({\n              ...prev,\n              errorMap: {\n                ...prev.errorMap,\n                [serverErrKey]: undefined,\n              },\n              errorSourceMap: {\n                ...prev.errorSourceMap,\n                [serverErrKey]: undefined,\n              },\n            }))\n          }\n        }\n      }\n    })\n\n    return { hasErrored, fieldsErrorMap: currentValidationErrorMap }\n  }\n\n  /**\n   * @private\n   */\n  validateAsync = async (\n    cause: ValidationCause,\n  ): Promise<\n    FormErrorMapFromValidator<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync\n    >\n  > => {\n    const validates = getAsyncValidatorArray(cause, {\n      ...this.options,\n      form: this,\n      validationLogic: this.options.validationLogic || defaultValidationLogic,\n    })\n\n    if (!this.state.isFormValidating) {\n      this.baseStore.setState((prev) => ({ ...prev, isFormValidating: true }))\n    }\n\n    /**\n     * We have to use a for loop and generate our promises this way, otherwise it won't be sync\n     * when there are no validators needed to be run\n     */\n    const promises: Promise<ValidationPromiseResult<TFormData>>[] = []\n\n    let fieldErrorsFromFormValidators:\n      | Partial<Record<DeepKeys<TFormData>, ValidationError>>\n      | undefined\n\n    for (const validateObj of validates) {\n      if (!validateObj.validate) continue\n      const key = getErrorMapKey(validateObj.cause)\n      const fieldValidatorMeta = this.state.validationMetaMap[key]\n\n      fieldValidatorMeta?.lastAbortController.abort()\n      const controller = new AbortController()\n\n      this.state.validationMetaMap[key] = {\n        lastAbortController: controller,\n      }\n\n      promises.push(\n        new Promise<ValidationPromiseResult<TFormData>>(async (resolve) => {\n          let rawError!:\n            | ValidationError\n            | FormValidationError<unknown>\n            | undefined\n          try {\n            rawError = await new Promise((rawResolve, rawReject) => {\n              setTimeout(async () => {\n                if (controller.signal.aborted) return rawResolve(undefined)\n                try {\n                  rawResolve(\n                    await this.runValidator({\n                      validate: validateObj.validate!,\n                      value: {\n                        value: this.state.values,\n                        formApi: this,\n                        validationSource: 'form',\n                        signal: controller.signal,\n                      },\n                      type: 'validateAsync',\n                    }),\n                  )\n                } catch (e) {\n                  rawReject(e)\n                }\n              }, validateObj.debounceMs)\n            })\n          } catch (e: unknown) {\n            rawError = e as ValidationError\n          }\n          const { formError, fieldErrors: fieldErrorsFromNormalizeError } =\n            normalizeError<TFormData>(rawError)\n\n          if (fieldErrorsFromNormalizeError) {\n            fieldErrorsFromFormValidators = fieldErrorsFromFormValidators\n              ? {\n                  ...fieldErrorsFromFormValidators,\n                  ...fieldErrorsFromNormalizeError,\n                }\n              : fieldErrorsFromNormalizeError\n          }\n          const errorMapKey = getErrorMapKey(validateObj.cause)\n\n          for (const field of Object.keys(\n            this.state.fieldMeta,\n          ) as DeepKeys<TFormData>[]) {\n            if (this.baseStore.state.fieldMetaBase[field] === undefined) {\n              continue\n            }\n\n            const fieldMeta = this.getFieldMeta(field)\n            if (!fieldMeta) continue\n\n            const {\n              errorMap: currentErrorMap,\n              errorSourceMap: currentErrorMapSource,\n            } = fieldMeta\n\n            const newFormValidatorError = fieldErrorsFromFormValidators?.[field]\n\n            const { newErrorValue, newSource } =\n              determineFormLevelErrorSourceAndValue({\n                newFormValidatorError,\n                isPreviousErrorFromFormValidator:\n                  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n                  currentErrorMapSource?.[errorMapKey] === 'form',\n                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n                previousErrorValue: currentErrorMap?.[errorMapKey],\n              })\n\n            if (\n              // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n              currentErrorMap?.[errorMapKey] !== newErrorValue\n            ) {\n              this.setFieldMeta(field, (prev) => ({\n                ...prev,\n                errorMap: {\n                  ...prev.errorMap,\n                  [errorMapKey]: newErrorValue,\n                },\n                errorSourceMap: {\n                  ...prev.errorSourceMap,\n                  [errorMapKey]: newSource,\n                },\n              }))\n            }\n          }\n\n          this.baseStore.setState((prev) => ({\n            ...prev,\n            errorMap: {\n              ...prev.errorMap,\n              [errorMapKey]: formError,\n            },\n          }))\n\n          resolve(\n            fieldErrorsFromFormValidators\n              ? { fieldErrors: fieldErrorsFromFormValidators, errorMapKey }\n              : undefined,\n          )\n        }),\n      )\n    }\n\n    let results: ValidationPromiseResult<TFormData>[] = []\n\n    const fieldsErrorMap: FormErrorMapFromValidator<\n      TFormData,\n      TOnMount,\n      TOnChange,\n      TOnChangeAsync,\n      TOnBlur,\n      TOnBlurAsync,\n      TOnSubmit,\n      TOnSubmitAsync,\n      TOnDynamic,\n      TOnDynamicAsync\n    > = {}\n    if (promises.length) {\n      results = await Promise.all(promises)\n      for (const fieldValidationResult of results) {\n        if (fieldValidationResult?.fieldErrors) {\n          const { errorMapKey } = fieldValidationResult\n\n          for (const [field, fieldError] of Object.entries(\n            fieldValidationResult.fieldErrors,\n          )) {\n            const oldErrorMap =\n              fieldsErrorMap[field as DeepKeys<TFormData>] || {}\n            const newErrorMap = {\n              ...oldErrorMap,\n              [errorMapKey]: fieldError,\n            }\n            fieldsErrorMap[field as DeepKeys<TFormData>] = newErrorMap\n          }\n        }\n      }\n    }\n\n    this.baseStore.setState((prev) => ({\n      ...prev,\n      isFormValidating: false,\n    }))\n\n    return fieldsErrorMap\n  }\n\n  /**\n   * @private\n   */\n  validate = (\n    cause: ValidationCause,\n  ):\n    | FormErrorMapFromValidator<\n        TFormData,\n        TOnMount,\n        TOnChange,\n        TOnChangeAsync,\n        TOnBlur,\n        TOnBlurAsync,\n        TOnSubmit,\n        TOnSubmitAsync,\n        TOnDynamic,\n        TOnDynamicAsync\n      >\n    | Promise<\n        FormErrorMapFromValidator<\n          TFormData,\n          TOnMount,\n          TOnChange,\n          TOnChangeAsync,\n          TOnBlur,\n          TOnBlurAsync,\n          TOnSubmit,\n          TOnSubmitAsync,\n          TOnDynamic,\n          TOnDynamicAsync\n        >\n      > => {\n    // Attempt to sync validate first\n    const { hasErrored, fieldsErrorMap } = this.validateSync(cause)\n\n    if (hasErrored && !this.options.asyncAlways) {\n      return fieldsErrorMap\n    }\n\n    // No error? Attempt async validation\n    return this.validateAsync(cause)\n  }\n\n  // Needs to edgecase in the React adapter specifically to avoid type errors\n  handleSubmit(): Promise<void>\n  handleSubmit(submitMeta: TSubmitMeta): Promise<void>\n  handleSubmit(submitMeta?: TSubmitMeta): Promise<void> {\n    return this._handleSubmit(submitMeta)\n  }\n\n  /**\n   * Handles the form submission, performs validation, and calls the appropriate onSubmit or onSubmitInvalid callbacks.\n   */\n  _handleSubmit = async (submitMeta?: TSubmitMeta): Promise<void> => {\n    this.baseStore.setState((old) => ({\n      ...old,\n      // Submission attempts mark the form as not submitted\n      isSubmitted: false,\n      // Count submission attempts\n      submissionAttempts: old.submissionAttempts + 1,\n      isSubmitSuccessful: false, // Reset isSubmitSuccessful at the start of submission\n    }))\n\n    batch(() => {\n      void (Object.values(this.fieldInfo) as FieldInfo<any>[]).forEach(\n        (field) => {\n          if (!field.instance) return\n          // If any fields are not touched\n          if (!field.instance.state.meta.isTouched) {\n            // Mark them as touched\n            field.instance.setMeta((prev) => ({ ...prev, isTouched: true }))\n          }\n        },\n      )\n    })\n\n    const submitMetaArg =\n      submitMeta ?? (this.options.onSubmitMeta as TSubmitMeta)\n\n    if (!this.state.canSubmit && !this._devtoolsSubmissionOverride) {\n      this.options.onSubmitInvalid?.({\n        value: this.state.values,\n        formApi: this,\n        meta: submitMetaArg,\n      })\n      return\n    }\n\n    this.baseStore.setState((d) => ({ ...d, isSubmitting: true }))\n\n    const done = () => {\n      this.baseStore.setState((prev) => ({ ...prev, isSubmitting: false }))\n    }\n\n    await this.validateAllFields('submit')\n\n    if (!this.state.isFieldsValid) {\n      done()\n\n      this.options.onSubmitInvalid?.({\n        value: this.state.values,\n        formApi: this,\n        meta: submitMetaArg,\n      })\n\n      formEventClient.emit('form-submission', {\n        id: this._formId,\n        submissionAttempt: this.state.submissionAttempts,\n        successful: false,\n        stage: 'validateAllFields',\n        errors: (Object.values(this.state.fieldMeta) as AnyFieldMeta[])\n          .map((meta: AnyFieldMeta) => meta.errors)\n          .flat(),\n      })\n      return\n    }\n\n    await this.validate('submit')\n\n    // Fields are invalid, do not submit\n    if (!this.state.isValid) {\n      done()\n\n      this.options.onSubmitInvalid?.({\n        value: this.state.values,\n        formApi: this,\n        meta: submitMetaArg,\n      })\n\n      formEventClient.emit('form-submission', {\n        id: this._formId,\n        submissionAttempt: this.state.submissionAttempts,\n        successful: false,\n        stage: 'validate',\n        errors: this.state.errors,\n      })\n\n      return\n    }\n\n    batch(() => {\n      void (Object.values(this.fieldInfo) as FieldInfo<TFormData>[]).forEach(\n        (field) => {\n          field.instance?.options.listeners?.onSubmit?.({\n            value: field.instance.state.value,\n            fieldApi: field.instance,\n          })\n        },\n      )\n    })\n\n    this.options.listeners?.onSubmit?.({ formApi: this, meta: submitMetaArg })\n\n    try {\n      // Run the submit code\n      await this.options.onSubmit?.({\n        value: this.state.values,\n        formApi: this,\n        meta: submitMetaArg,\n      })\n\n      batch(() => {\n        this.baseStore.setState((prev) => ({\n          ...prev,\n          isSubmitted: true,\n          isSubmitSuccessful: true, // Set isSubmitSuccessful to true on successful submission\n        }))\n\n        formEventClient.emit('form-submission', {\n          id: this._formId,\n          submissionAttempt: this.state.submissionAttempts,\n          successful: true,\n        })\n\n        done()\n      })\n    } catch (err) {\n      this.baseStore.setState((prev) => ({\n        ...prev,\n        isSubmitSuccessful: false, // Ensure isSubmitSuccessful is false if an error occurs\n      }))\n\n      formEventClient.emit('form-submission', {\n        id: this._formId,\n        submissionAttempt: this.state.submissionAttempts,\n        successful: false,\n        stage: 'inflight',\n        onError: err,\n      })\n\n      done()\n\n      throw err\n    }\n  }\n\n  /**\n   * Gets the value of the specified field.\n   */\n  getFieldValue = <TField extends DeepKeys<TFormData>>(\n    field: TField,\n  ): DeepValue<TFormData, TField> => getBy(this.state.values, field)\n\n  /**\n   * Gets the metadata of the specified field.\n   */\n  getFieldMeta = <TField extends DeepKeys<TFormData>>(\n    field: TField,\n  ): AnyFieldMeta | undefined => {\n    return this.state.fieldMeta[field]\n  }\n\n  /**\n   * Gets the field info of the specified field.\n   */\n  getFieldInfo = <TField extends DeepKeys<TFormData>>(\n    field: TField,\n  ): FieldInfo<TFormData> => {\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    return (this.fieldInfo[field] ||= {\n      instance: null,\n      validationMetaMap: {\n        onChange: undefined,\n        onBlur: undefined,\n        onSubmit: undefined,\n        onMount: undefined,\n        onServer: undefined,\n        onDynamic: undefined,\n      },\n    })\n  }\n\n  /**\n   * Updates the metadata of the specified field.\n   */\n  setFieldMeta = <TField extends DeepKeys<TFormData>>(\n    field: TField,\n    updater: Updater<AnyFieldMetaBase>,\n  ) => {\n    this.baseStore.setState((prev) => {\n      return {\n        ...prev,\n        fieldMetaBase: {\n          ...prev.fieldMetaBase,\n          [field]: functionalUpdate(\n            updater,\n            prev.fieldMetaBase[field] as never,\n          ),\n        },\n      }\n    })\n  }\n\n  /**\n   * resets every field's meta\n   */\n  resetFieldMeta = <TField extends DeepKeys<TFormData>>(\n    fieldMeta: Partial<Record<TField, AnyFieldMeta>>,\n  ): Partial<Record<TField, AnyFieldMeta>> => {\n    return Object.keys(fieldMeta).reduce(\n      (acc, key) => {\n        const fieldKey = key as TField\n        acc[fieldKey] = defaultFieldMeta\n        return acc\n      },\n      {} as Partial<Record<TField, AnyFieldMeta>>,\n    )\n  }\n\n  /**\n   * Sets the value of the specified field and optionally updates the touched state.\n   */\n  setFieldValue = <TField extends DeepKeys<TFormData>>(\n    field: TField,\n    updater: Updater<DeepValue<TFormData, TField>>,\n    opts?: UpdateMetaOptions,\n  ) => {\n    const dontUpdateMeta = opts?.dontUpdateMeta ?? false\n    const dontRunListeners = opts?.dontRunListeners ?? false\n    const dontValidate = opts?.dontValidate ?? false\n\n    batch(() => {\n      if (!dontUpdateMeta) {\n        this.setFieldMeta(field, (prev) => ({\n          ...prev,\n          isTouched: true,\n          isDirty: true,\n          errorMap: {\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            ...prev?.errorMap,\n            onMount: undefined,\n          },\n        }))\n      }\n\n      this.baseStore.setState((prev) => {\n        return {\n          ...prev,\n          values: setBy(prev.values, field, updater),\n        }\n      })\n    })\n\n    if (!dontRunListeners) {\n      this.getFieldInfo(field).instance?.triggerOnChangeListener()\n    }\n\n    if (!dontValidate) {\n      this.validateField(field, 'change')\n    }\n  }\n\n  deleteField = <TField extends DeepKeys<TFormData>>(field: TField) => {\n    const subFieldsToDelete = Object.keys(this.fieldInfo).filter((f) => {\n      const fieldStr = field.toString()\n      return f !== fieldStr && f.startsWith(fieldStr)\n    })\n\n    const fieldsToDelete = [...subFieldsToDelete, field]\n\n    // Cleanup the last fields\n    this.baseStore.setState((prev) => {\n      const newState = { ...prev }\n      fieldsToDelete.forEach((f) => {\n        newState.values = deleteBy(newState.values, f)\n        delete this.fieldInfo[f as never]\n        delete newState.fieldMetaBase[f as never]\n      })\n\n      return newState\n    })\n  }\n\n  /**\n   * Pushes a value into an array field.\n   */\n  pushFieldValue = <TField extends DeepKeysOfType<TFormData, any[]>>(\n    field: TField,\n    value: DeepValue<TFormData, TField> extends any[]\n      ? DeepValue<TFormData, TField>[number]\n      : never,\n    options?: UpdateMetaOptions,\n  ) => {\n    this.setFieldValue(\n      field,\n      (prev) => [...(Array.isArray(prev) ? prev : []), value] as any,\n      options,\n    )\n  }\n\n  insertFieldValue = async <TField extends DeepKeysOfType<TFormData, any[]>>(\n    field: TField,\n    index: number,\n    value: DeepValue<TFormData, TField> extends any[]\n      ? DeepValue<TFormData, TField>[number]\n      : never,\n    options?: UpdateMetaOptions,\n  ) => {\n    this.setFieldValue(\n      field,\n      (prev) => {\n        return [\n          ...(prev as DeepValue<TFormData, TField>[]).slice(0, index),\n          value,\n          ...(prev as DeepValue<TFormData, TField>[]).slice(index),\n        ] as any\n      },\n      mergeOpts(options, { dontValidate: true }),\n    )\n\n    const dontValidate = options?.dontValidate ?? false\n    if (!dontValidate) {\n      // Validate the whole array + all fields that have shifted\n      await this.validateField(field, 'change')\n    }\n\n    // Shift down all meta after validating to make sure the new field has been mounted\n    metaHelper(this).handleArrayInsert(field, index)\n\n    if (!dontValidate) {\n      await this.validateArrayFieldsStartingFrom(field, index, 'change')\n    }\n  }\n\n  /**\n   * Replaces a value into an array field at the specified index.\n   */\n  replaceFieldValue = async <TField extends DeepKeysOfType<TFormData, any[]>>(\n    field: TField,\n    index: number,\n    value: DeepValue<TFormData, TField> extends any[]\n      ? DeepValue<TFormData, TField>[number]\n      : never,\n    options?: UpdateMetaOptions,\n  ) => {\n    this.setFieldValue(\n      field,\n      (prev) => {\n        return (prev as DeepValue<TFormData, TField>[]).map((d, i) =>\n          i === index ? value : d,\n        ) as any\n      },\n      mergeOpts(options, { dontValidate: true }),\n    )\n\n    const dontValidate = options?.dontValidate ?? false\n    if (!dontValidate) {\n      // Validate the whole array + all fields that have shifted\n      await this.validateField(field, 'change')\n      await this.validateArrayFieldsStartingFrom(field, index, 'change')\n    }\n  }\n\n  /**\n   * Removes a value from an array field at the specified index.\n   */\n  removeFieldValue = async <TField extends DeepKeysOfType<TFormData, any[]>>(\n    field: TField,\n    index: number,\n    options?: UpdateMetaOptions,\n  ) => {\n    const fieldValue = this.getFieldValue(field)\n\n    const lastIndex = Array.isArray(fieldValue)\n      ? Math.max((fieldValue as Array<unknown>).length - 1, 0)\n      : null\n\n    this.setFieldValue(\n      field,\n      (prev) => {\n        return (prev as DeepValue<TFormData, TField>[]).filter(\n          (_d, i) => i !== index,\n        ) as any\n      },\n      mergeOpts(options, { dontValidate: true }),\n    )\n\n    // Shift up all meta\n    metaHelper(this).handleArrayRemove(field, index)\n\n    if (lastIndex !== null) {\n      const start = `${field}[${lastIndex}]`\n      this.deleteField(start as never)\n    }\n\n    const dontValidate = options?.dontValidate ?? false\n    if (!dontValidate) {\n      // Validate the whole array + all fields that have shifted\n      await this.validateField(field, 'change')\n      await this.validateArrayFieldsStartingFrom(field, index, 'change')\n    }\n  }\n\n  /**\n   * Swaps the values at the specified indices within an array field.\n   */\n  swapFieldValues = <TField extends DeepKeysOfType<TFormData, any[]>>(\n    field: TField,\n    index1: number,\n    index2: number,\n    options?: UpdateMetaOptions,\n  ) => {\n    this.setFieldValue(\n      field,\n      (prev: any) => {\n        const prev1 = prev[index1]!\n        const prev2 = prev[index2]!\n        return setBy(setBy(prev, `${index1}`, prev2), `${index2}`, prev1)\n      },\n      mergeOpts(options, { dontValidate: true }),\n    )\n\n    // Swap meta\n    metaHelper(this).handleArraySwap(field, index1, index2)\n\n    const dontValidate = options?.dontValidate ?? false\n    if (!dontValidate) {\n      // Validate the whole array\n      this.validateField(field, 'change')\n      // Validate the swapped fields\n      this.validateField(`${field}[${index1}]` as DeepKeys<TFormData>, 'change')\n      this.validateField(`${field}[${index2}]` as DeepKeys<TFormData>, 'change')\n    }\n  }\n\n  /**\n   * Moves the value at the first specified index to the second specified index within an array field.\n   */\n  moveFieldValues = <TField extends DeepKeysOfType<TFormData, any[]>>(\n    field: TField,\n    index1: number,\n    index2: number,\n    options?: UpdateMetaOptions,\n  ) => {\n    this.setFieldValue(\n      field,\n      (prev: any) => {\n        const next: any = [...prev]\n        next.splice(index2, 0, next.splice(index1, 1)[0])\n        return next\n      },\n      mergeOpts(options, { dontValidate: true }),\n    )\n\n    // Move meta between index1 and index2\n    metaHelper(this).handleArrayMove(field, index1, index2)\n\n    const dontValidate = options?.dontValidate ?? false\n    if (!dontValidate) {\n      // Validate the whole array\n      this.validateField(field, 'change')\n      // Validate the moved fields\n      this.validateField(`${field}[${index1}]` as DeepKeys<TFormData>, 'change')\n      this.validateField(`${field}[${index2}]` as DeepKeys<TFormData>, 'change')\n    }\n  }\n\n  /**\n   * Clear all values within an array field.\n   */\n  clearFieldValues = <TField extends DeepKeysOfType<TFormData, any[]>>(\n    field: TField,\n    options?: UpdateMetaOptions,\n  ) => {\n    const fieldValue = this.getFieldValue(field)\n\n    const lastIndex = Array.isArray(fieldValue)\n      ? Math.max((fieldValue as unknown[]).length - 1, 0)\n      : null\n\n    this.setFieldValue(\n      field,\n      [] as any,\n      mergeOpts(options, { dontValidate: true }),\n    )\n\n    if (lastIndex !== null) {\n      for (let i = 0; i <= lastIndex; i++) {\n        const fieldKey = `${field}[${i}]`\n        this.deleteField(fieldKey as never)\n      }\n    }\n\n    const dontValidate = options?.dontValidate ?? false\n    if (!dontValidate) {\n      // validate array change\n      this.validateField(field, 'change')\n    }\n  }\n\n  /**\n   * Resets the field value and meta to default state\n   */\n  resetField = <TField extends DeepKeys<TFormData>>(field: TField) => {\n    this.baseStore.setState((prev) => {\n      return {\n        ...prev,\n        fieldMetaBase: {\n          ...prev.fieldMetaBase,\n          [field]: defaultFieldMeta,\n        },\n        values: this.options.defaultValues\n          ? setBy(prev.values, field, getBy(this.options.defaultValues, field))\n          : prev.values,\n      }\n    })\n  }\n\n  /**\n   * Updates the form's errorMap\n   */\n  setErrorMap = (\n    errorMap: FormValidationErrorMap<\n      TFormData,\n      UnwrapFormValidateOrFn<TOnMount>,\n      UnwrapFormValidateOrFn<TOnChange>,\n      UnwrapFormAsyncValidateOrFn<TOnChangeAsync>,\n      UnwrapFormValidateOrFn<TOnBlur>,\n      UnwrapFormAsyncValidateOrFn<TOnBlurAsync>,\n      UnwrapFormValidateOrFn<TOnSubmit>,\n      UnwrapFormAsyncValidateOrFn<TOnSubmitAsync>,\n      UnwrapFormValidateOrFn<TOnDynamic>,\n      UnwrapFormAsyncValidateOrFn<TOnDynamicAsync>,\n      UnwrapFormAsyncValidateOrFn<TOnServer>\n    >,\n  ) => {\n    batch(() => {\n      Object.entries(errorMap).forEach(([key, value]) => {\n        const errorMapKey = key as ValidationErrorMapKeys\n\n        if (isGlobalFormValidationError(value)) {\n          const { formError, fieldErrors } = normalizeError<TFormData>(value)\n\n          for (const fieldName of Object.keys(\n            this.fieldInfo,\n          ) as DeepKeys<TFormData>[]) {\n            const fieldMeta = this.getFieldMeta(fieldName)\n            if (!fieldMeta) continue\n\n            this.setFieldMeta(fieldName, (prev) => ({\n              ...prev,\n              errorMap: {\n                ...prev.errorMap,\n                [errorMapKey]: fieldErrors?.[fieldName],\n              },\n              errorSourceMap: {\n                ...prev.errorSourceMap,\n                [errorMapKey]: 'form',\n              },\n            }))\n          }\n\n          this.baseStore.setState((prev) => ({\n            ...prev,\n            errorMap: {\n              ...prev.errorMap,\n              [errorMapKey]: formError,\n            },\n          }))\n        } else {\n          this.baseStore.setState((prev) => ({\n            ...prev,\n            errorMap: {\n              ...prev.errorMap,\n              [errorMapKey]: value,\n            },\n          }))\n        }\n      })\n    })\n  }\n\n  /**\n   * Returns form and field level errors\n   */\n  getAllErrors = (): {\n    form: {\n      errors: Array<\n        | UnwrapFormValidateOrFn<TOnMount>\n        | UnwrapFormValidateOrFn<TOnChange>\n        | UnwrapFormAsyncValidateOrFn<TOnChangeAsync>\n        | UnwrapFormValidateOrFn<TOnBlur>\n        | UnwrapFormAsyncValidateOrFn<TOnBlurAsync>\n        | UnwrapFormValidateOrFn<TOnSubmit>\n        | UnwrapFormAsyncValidateOrFn<TOnSubmitAsync>\n        | UnwrapFormValidateOrFn<TOnDynamic>\n        | UnwrapFormAsyncValidateOrFn<TOnDynamicAsync>\n        | UnwrapFormAsyncValidateOrFn<TOnServer>\n      >\n      errorMap: ValidationErrorMap<\n        UnwrapFormValidateOrFn<TOnMount>,\n        UnwrapFormValidateOrFn<TOnChange>,\n        UnwrapFormAsyncValidateOrFn<TOnChangeAsync>,\n        UnwrapFormValidateOrFn<TOnBlur>,\n        UnwrapFormAsyncValidateOrFn<TOnBlurAsync>,\n        UnwrapFormValidateOrFn<TOnSubmit>,\n        UnwrapFormAsyncValidateOrFn<TOnSubmitAsync>,\n        UnwrapFormValidateOrFn<TOnDynamic>,\n        UnwrapFormAsyncValidateOrFn<TOnDynamicAsync>,\n        UnwrapFormAsyncValidateOrFn<TOnServer>\n      >\n    }\n    fields: Record<\n      DeepKeys<TFormData>,\n      { errors: ValidationError[]; errorMap: ValidationErrorMap }\n    >\n  } => {\n    return {\n      form: {\n        errors: this.state.errors,\n        errorMap: this.state.errorMap,\n      },\n      fields: Object.entries(this.state.fieldMeta).reduce(\n        (acc, [fieldName, fieldMeta]) => {\n          if (\n            Object.keys(fieldMeta as AnyFieldMeta).length &&\n            (fieldMeta as AnyFieldMeta).errors.length\n          ) {\n            acc[fieldName as DeepKeys<TFormData>] = {\n              errors: (fieldMeta as AnyFieldMeta).errors,\n              errorMap: (fieldMeta as AnyFieldMeta).errorMap,\n            }\n          }\n\n          return acc\n        },\n        {} as Record<\n          DeepKeys<TFormData>,\n          { errors: ValidationError[]; errorMap: ValidationErrorMap }\n        >,\n      ),\n    }\n  }\n\n  /**\n   * Parses the form's values with a given standard schema and returns\n   * issues (if any). This method does NOT set any internal errors.\n   * @param schema The standard schema to parse the form values with.\n   */\n  parseValuesWithSchema = (schema: StandardSchemaV1<TFormData, unknown>) => {\n    return standardSchemaValidators.validate(\n      { value: this.state.values, validationSource: 'form' },\n      schema,\n    )\n  }\n\n  /**\n   * Parses the form's values with a given standard schema and returns\n   * issues (if any). This method does NOT set any internal errors.\n   * @param schema The standard schema to parse the form values with.\n   */\n  parseValuesWithSchemaAsync = (\n    schema: StandardSchemaV1<TFormData, unknown>,\n  ) => {\n    return standardSchemaValidators.validateAsync(\n      { value: this.state.values, validationSource: 'form' },\n      schema,\n    )\n  }\n}\n\nfunction normalizeError<TFormData>(rawError?: FormValidationError<unknown>): {\n  formError: ValidationError\n  fieldErrors?: Partial<Record<DeepKeys<TFormData>, ValidationError>>\n} {\n  if (rawError) {\n    if (isGlobalFormValidationError(rawError)) {\n      const formError = normalizeError(rawError.form).formError\n      const fieldErrors = rawError.fields\n      return { formError, fieldErrors } as never\n    }\n\n    return { formError: rawError }\n  }\n\n  return { formError: undefined }\n}\n\nfunction getErrorMapKey(cause: ValidationCause) {\n  switch (cause) {\n    case 'submit':\n      return 'onSubmit'\n    case 'blur':\n      return 'onBlur'\n    case 'mount':\n      return 'onMount'\n    case 'server':\n      return 'onServer'\n    case 'dynamic':\n      return 'onDynamic'\n    case 'change':\n    default:\n      return 'onChange'\n  }\n}\n"],"names":["opts"],"mappings":"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"}
\ No newline at end of file
