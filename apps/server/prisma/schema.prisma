generator client {
  provider     = "prisma-client"
  output       = "../src/prisma"
  moduleFormat = "esm"
}

datasource db {
  provider = "postgresql"
}

model Account {
  id                    String    @id @default(cuid())
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accountId             String
  providerId            String
  accessToken           String?
  refreshToken          String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  idToken               String?
  password              String?
  createdAt             DateTime
  updatedAt             DateTime

  @@index([userId])
  @@map("account")
}

model Verification {
  id         String    @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime?
  updatedAt  DateTime?

  @@index([identifier])
  @@map("verification")
}

model Session {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  token     String
  expiresAt DateTime
  ipAddress String?
  userAgent String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  impersonatedBy String?

  @@unique([token])
  @@index([userId])
  @@map("session")
}

model User {
  id               String    @id @default(cuid())
  name             String?
  email            String?   @unique
  emailVerified    Boolean   @default(false)
  image            String?
  accounts         Account[]
  sessions         Session[]
  Comments         Comment[]
  Order            Order[]
  role             String    @default("user")
  stripeCustomerId String?   @unique
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  banned     Boolean?
  banReason  String?
  banExpires DateTime?

  @@map("user")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Comment {
  id        String   @id @default(uuid())
  text      String
  productId String
  product   Product  @relation(fields: [productId], references: [id])
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

//PRODUCTS

// Category: Represents a product category (e.g., "Épices", "Vêtements")
// Each category can have its own set of attributes (e.g., Épices: Couleur, Taille, Origine)
model Category {
  id   String @id @default(uuid())
  name String @unique // Category name (e.g., "Épices")

  image   Image  @relation(fields: [imageId], references: [id])
  imageId String @unique

  products   Product[] // All products in this category
  attributes Attribute[] // Attributes available for this category
}

// Attribute: Defines a characteristic for a category (e.g., "Couleur", "Taille")
// Each attribute belongs to a specific category and can have multiple values
model Attribute {
  id   String @id @default(uuid())
  name String // Attribute name (e.g., "Couleur", "Taille")

  category   Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  categoryId String

  values AttributeValue[] // Possible values for this attribute

  @@unique([categoryId, name]) // No duplicate attributes per category
}

// AttributeValue: Specific value for an attribute (e.g., "Noir", "100g")
// These values are combined in ProductVariants to create specific product variations
model AttributeValue {
  id    String @id @default(uuid())
  value String // Attribute value (e.g., "Noir", "Blanc", "100g", "250g")

  attribute   Attribute @relation(fields: [attributeId], references: [id], onDelete: Cascade)
  attributeId String

  productVariants ProductVariant[] // Used in multiple product variants

  @@unique([attributeId, value]) // No duplicate values per attribute
}

model Image {
  id          String  @id @default(uuid())
  keyThumb    String  @unique
  keyMedium   String  @unique
  keyLarge    String  @unique
  urlThumb    String
  urlMedium   String
  urlLarge    String
  altText     String?
  isThumbnail Boolean @default(false)

  product   Product? @relation(fields: [productId], references: [id], onDelete: Cascade)
  productId String?

  category Category?

  @@index([productId, isThumbnail])
}

// Product: Base product without variations (e.g., "Poivre")
// The actual purchasable items are ProductVariants with specific attributes
model Product {
  id          String @id @default(uuid())
  name        String @unique // Product name (e.g., "Poivre")
  slug        String @unique // URL-friendly name (e.g., "poivre")
  description String
  version     Int    @default(0)

  status   ProductStatus @default(DRAFT)
  images   Image[]
  comments Comment[]

  variants ProductVariant[] // All variations of this product (e.g., Poivre Noir 100g, Poivre Blanc 250g)

  category   Category @relation(fields: [categoryId], references: [id], onDelete: Restrict)
  categoryId String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // @@index([name], type: Gin) not possible with prisma, setted in migration.sql manually
  @@index([status])
  @@index([categoryId])
}

// ProductVariant: Specific variation of a product with unique attributes, price, and stock
// Example: "Poivre Noir 100g" (attributeValues: [Noir, 100g], price: 5.99€, stock: 50)
model ProductVariant {
  id        String  @id @default(uuid())
  productId String
  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  attributeValues AttributeValue[] // Combination of attributes (e.g., [Noir, 100g])

  sku      String? @unique // Stock Keeping Unit - unique code (e.g., "POIV-NOIR-100G")
  price    Int // Price in cents (e.g., 1999 = €19.99)
  currency String  @default("EUR")

  stock Int @default(0) // Available stock for this variant

  orderItems OrderItem[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([productId])
  @@index([productId, stock, price])
}

enum ProductStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
}

enum OrderStatus {
  PENDING
  PAID
  FULFILLED
  CANCELLED
  REFUNDED
}

enum ShippingStatus {
  PENDING
  SHIPPED
  DELIVERED
}

model Order {
  id                    String      @id @default(uuid())
  stripeSessionId       String      @unique
  stripePaymentIntentId String?     @unique
  status                OrderStatus @default(PENDING)

  userId String
  user   User        @relation(fields: [userId], references: [id])
  items  OrderItem[]

  subtotalAmount Int // Amount in cents
  taxAmount      Int @default(0) // Amount in cents
  shippingAmount Int @default(0) // Amount in cents
  totalAmount    Int // Amount in cents

  shippingAddress Json?
  shippingStatus  ShippingStatus @default(PENDING)
  trackingNumber  String?

  metadata Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([status])
  @@index([createdAt])
}

model OrderItem {
  id      String @id @default(uuid())
  orderId String
  order   Order  @relation(fields: [orderId], references: [id], onDelete: Cascade)

  productId    String
  productName  String
  productImage String?

  variantId   String?
  variant     ProductVariant? @relation(fields: [variantId], references: [id])
  variantName String?
  variantSku  String?

  unitPrice  Int // Price in cents
  quantity   Int
  totalPrice Int // Amount in cents

  @@index([orderId])
  @@index([productId])
  @@index([variantId])
}
